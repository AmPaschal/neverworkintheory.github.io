---
layout: post
author: Paschal Amusuo
title: "AntiFuzz: Impeding Fuzzing Audits of Binary Executables"
date: 2022-02-13
categories: ["Fuzz Testing", "Security"]
---
<div class="review">
  <p>
    Review goes here.
  </p>
</div>

<blockquote class="abstract">
  <p>
    A general defense strategy in computer security is to increase the cost of
    successful attacks in both computational resources as well as human time.
    In the area of binary security, this is commonly done by using obfuscation
    methods to hinder reverse engineering and the search for software vulnerabilities.
    However, recent trends in automated bug finding changed the modus operandi.
    Nowadays it is very common for bugs to be found by various fuzzing tools.
    Due to ever-increasing amounts of automation and research on better fuzzing
    strategies, large-scale, dragnet-style fuzzing of many hundreds of targets
    becomes viable. As we show, current obfuscation techniques are aimed at
    increasing the cost of human understanding and do little to slow down fuzzing.
  </p>
  <p>
    In this paper, we introduce several techniques to protect a binary executable
    against an analysis with automated bug f inding approaches that are based on
    fuzzing, symbolic/concolic execution, and taint-assisted fuzzing (commonly
    known as hybrid fuzzing). More specifically, we perform a systematic analysis
    of the fundamental assumptions of bug finding tools and develop general
    countermeasures for each assumption. Note that these techniques are not
    designed to target specific implementations of fuzzing tools, but address
    general assumptions that bug finding tools necessarily depend on. Our
    evaluation demonstrates that these techniques effectively impede fuzzing
    audits, while introducing a negligible performance overhead. Just as
    obfuscation techniques increase the amount of human labor needed to find
    a vulnerability, our techniques render automated fuzzing-based approaches futile.
  </p>
</blockquote>


<div class="review">
  <p>
    Fuzzing is one of the most widely used and successful methods of finding
    security vulnerabilities in software programs. Fuzzing tools automatically
    and randomly generates input to a program, and runs the program using these
    inputs until the program crashes. These crashes usually indicate the presence
    of a security vulnerability. A vulnerability is simply a bug that can be
    exploited by an attacker to gain access to or control of a program.
  </p>
  <p>
    But since fuzzing can lead to the detection of vulnerabilities, this also
    means these vulnerabilities can be detected by attackers, who can then use
    it to exploit the program. Can we therefore make our program difficult to
    fuzz, so an attacker can not detect any hidden vulnerability in our program?
    That’s the problem this paper attempts to solve.
  </p>
  <p>
    In this paper, the authors developed various strategies that make fuzzing a
    program difficult. To do this, they identified some assumptions that existing
    fuzzing tools depend on to work successfully. With this, they developed a tool,
    AntiFuzz, that can be used to modify the target program and impede fuzzing.
    Some assumptions and counter-measures include:
  </p>
  <ol>
    <li>
      <p>
        Fuzzers try to generate inputs that can transverse all parts of the program code.
        These fuzzers rely on coverage information obtained from the program during each
        fuzzing run. Hence, if we can make our program return false coverage information,
        fuzzing would be significantly impeded. To achieve this, anti-fuzz returns a new,
        different and fake coverage information for each input to the program.
      </p>
    </li>
    <li>
      <p>
        Fuzzers monitor the operating system in order to detect program crashes, and
        believe that these crashes imply the presence of a security bug. To counter
        this, anti-fuzz sends fake crash signals to the operating systems.
        (Un)fortunately, the fuzzer wouldn’t be able to distinguish between
        the fake and real crashes.
      </p>
    </li>
    <li>
      <p>
        Fuzzers need to execute the program many times per second in order to operate
        efficiently. The authors believe that most input generated by the fuzzers are
        malformed and hence, when AntiFuzz identifies these malformed inputs, it slows
        down the program. While this reduction in program speed would not be noticeable
        by a normal user, it can significantly impede the efficient operation of the fuzzer.
      </p>
    </li>
  </ol>

  <p>
    To verify if their approach actually worked, they used 4 different state-of-the-art
    fuzzers to fuzz a set of target programs which contained several bugs. Their results
    show that Anti-Fuzz successfully prevented the detection of all bugs (previously
    detected without the use of AntiFuzz) when all the counter-measures were applied.
  </p>

  <p>
    I love their approach to impeding fuzzing, because it combines multiple measures.
    Hence, fuzzers would need to not rely on any of the 4 assumptions in order for this
    approach to completely fail. On the other hand, by making the publicly deployed
    and accessible version of a program resistant to fuzzing, this would restrict the
    fuzzing operation to only the program developers, impeding the detection of security
    vulnerabilities by security researchers and white hat hackers who also rely on fuzzing.
  </p>
</div>

<p id="GulerAntifuzz2019" class="bib">
  <cite>GulerAntifuzz2019</cite>
  Emre Güler, Cornelius Aschermann, Ali Abbasi, and Thorsten Holz:
  "<a href="https://www.usenix.org/conference/usenixsecurity19/presentation/guler">AntiFuzz: Impeding Fuzzing Audits of Binary Executables</a>".
  <em>2019 USENIX Security Symposium</em>.
</p>
