<?xml version="1.0" encoding="UTF-8" ?>
<!-- This is a WordPress eXtended RSS file generated by WordPress as an export of your site. -->
<!-- It contains information about your site's posts, pages, comments, categories, and other content. -->
<!-- You may use this file to transfer that content from one site to another. -->
<!-- This file is not intended to serve as a complete backup of your site. -->

<!-- To import this information into a WordPress site follow these steps: -->
<!-- 1. Log in to that site as an administrator. -->
<!-- 2. Go to Tools: Import in the WordPress admin panel. -->
<!-- 3. Install the "WordPress" importer from the list. -->
<!-- 4. Activate & Run Importer. -->
<!-- 5. Upload this file using the form provided on that page. -->
<!-- 6. You will first be asked to map the authors in this export file to users -->
<!--    on the site. For each author, you may choose to map to an -->
<!--    existing user on the site or to create a new user. -->
<!-- 7. WordPress will then import each of the posts, pages, comments, categories, etc. -->
<!--    contained in this file into your site. -->

<!-- generator="WordPress/3.5.2" created="2013-07-22 21:51" -->
<rss version="2.0"
	xmlns:excerpt="http://wordpress.org/export/1.2/excerpt/"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:wp="http://wordpress.org/export/1.2/"
>

<channel>
	<title>It Will Never Work in Theory</title>
	<link>http://www.neverworkintheory.org</link>
	<description>Software development research that is relevant in practice</description>
	<pubDate>Mon, 22 Jul 2013 21:51:45 +0000</pubDate>
	<language>en-US</language>
	<wp:wxr_version>1.2</wp:wxr_version>
	<wp:base_site_url>http://www.neverworkintheory.org</wp:base_site_url>
	<wp:base_blog_url>http://www.neverworkintheory.org</wp:base_blog_url>

	<wp:author><wp:author_id>1</wp:author_id><wp:author_login>jorge</wp:author_login><wp:author_email>jorge@neverworkintheory.org</wp:author_email><wp:author_display_name><![CDATA[Jorge Aranda]]></wp:author_display_name><wp:author_first_name><![CDATA[Jorge]]></wp:author_first_name><wp:author_last_name><![CDATA[Aranda]]></wp:author_last_name></wp:author>
	<wp:author><wp:author_id>2</wp:author_id><wp:author_login>gvwilson</wp:author_login><wp:author_email>gvwilson@third-bit.com</wp:author_email><wp:author_display_name><![CDATA[gvwilson]]></wp:author_display_name><wp:author_first_name><![CDATA[Greg]]></wp:author_first_name><wp:author_last_name><![CDATA[Wilson]]></wp:author_last_name></wp:author>
	<wp:author><wp:author_id>3</wp:author_id><wp:author_login>neil</wp:author_login><wp:author_email>neil@neilernst.net</wp:author_email><wp:author_display_name><![CDATA[Neil Ernst]]></wp:author_display_name><wp:author_first_name><![CDATA[Neil]]></wp:author_first_name><wp:author_last_name><![CDATA[Ernst]]></wp:author_last_name></wp:author>
	<wp:author><wp:author_id>27</wp:author_id><wp:author_login>ChristophTreude</wp:author_login><wp:author_email>ctreude@googlemail.com</wp:author_email><wp:author_display_name><![CDATA[Christoph Treude]]></wp:author_display_name><wp:author_first_name><![CDATA[Christoph]]></wp:author_first_name><wp:author_last_name><![CDATA[Treude]]></wp:author_last_name></wp:author>
	<wp:author><wp:author_id>18</wp:author_id><wp:author_login>LeifSinger</wp:author_login><wp:author_email>leif.singer@inf.uni-hannover.de</wp:author_email><wp:author_display_name><![CDATA[Leif Singer]]></wp:author_display_name><wp:author_first_name><![CDATA[Leif]]></wp:author_first_name><wp:author_last_name><![CDATA[Singer]]></wp:author_last_name></wp:author>
	<wp:author><wp:author_id>6</wp:author_id><wp:author_login>AndreasStefik</wp:author_login><wp:author_email>stefika@gmail.com</wp:author_email><wp:author_display_name><![CDATA[AndreasStefik]]></wp:author_display_name><wp:author_first_name><![CDATA[Andreas]]></wp:author_first_name><wp:author_last_name><![CDATA[Stefik]]></wp:author_last_name></wp:author>
	<wp:author><wp:author_id>28</wp:author_id><wp:author_login>FelienneHermans</wp:author_login><wp:author_email>felienne@gmail.com</wp:author_email><wp:author_display_name><![CDATA[FelienneHermans]]></wp:author_display_name><wp:author_first_name><![CDATA[Felienne]]></wp:author_first_name><wp:author_last_name><![CDATA[Hermans]]></wp:author_last_name></wp:author>
	<wp:author><wp:author_id>178</wp:author_id><wp:author_login>Fayola Peters</wp:author_login><wp:author_email>fayolapeters@gmail.com</wp:author_email><wp:author_display_name><![CDATA[Fayola Peters]]></wp:author_display_name><wp:author_first_name><![CDATA[Fayola]]></wp:author_first_name><wp:author_last_name><![CDATA[Peters]]></wp:author_last_name></wp:author>

	<wp:category><wp:term_id>16</wp:term_id><wp:category_nicename>announcements</wp:category_nicename><wp:category_parent></wp:category_parent><wp:cat_name><![CDATA[Announcements]]></wp:cat_name></wp:category>
	<wp:category><wp:term_id>38</wp:term_id><wp:category_nicename>book-reviews</wp:category_nicename><wp:category_parent></wp:category_parent><wp:cat_name><![CDATA[Book Reviews]]></wp:cat_name></wp:category>
	<wp:category><wp:term_id>36</wp:term_id><wp:category_nicename>case-studies</wp:category_nicename><wp:category_parent></wp:category_parent><wp:cat_name><![CDATA[Case Studies]]></wp:cat_name></wp:category>
	<wp:category><wp:term_id>47</wp:term_id><wp:category_nicename>code-generation</wp:category_nicename><wp:category_parent></wp:category_parent><wp:cat_name><![CDATA[Code Generation]]></wp:cat_name></wp:category>
	<wp:category><wp:term_id>5</wp:term_id><wp:category_nicename>code-ownership</wp:category_nicename><wp:category_parent></wp:category_parent><wp:cat_name><![CDATA[Code Ownership]]></wp:cat_name></wp:category>
	<wp:category><wp:term_id>18</wp:term_id><wp:category_nicename>code-review</wp:category_nicename><wp:category_parent></wp:category_parent><wp:cat_name><![CDATA[Code Review]]></wp:cat_name></wp:category>
	<wp:category><wp:term_id>9</wp:term_id><wp:category_nicename>code-smells</wp:category_nicename><wp:category_parent></wp:category_parent><wp:cat_name><![CDATA[Code Smells]]></wp:cat_name></wp:category>
	<wp:category><wp:term_id>37</wp:term_id><wp:category_nicename>collaboration</wp:category_nicename><wp:category_parent></wp:category_parent><wp:cat_name><![CDATA[Collaboration]]></wp:cat_name></wp:category>
	<wp:category><wp:term_id>46</wp:term_id><wp:category_nicename>conferences</wp:category_nicename><wp:category_parent></wp:category_parent><wp:cat_name><![CDATA[Conferences]]></wp:cat_name></wp:category>
	<wp:category><wp:term_id>20</wp:term_id><wp:category_nicename>controlled-experiments</wp:category_nicename><wp:category_parent></wp:category_parent><wp:cat_name><![CDATA[Controlled Experiments]]></wp:cat_name></wp:category>
	<wp:category><wp:term_id>30</wp:term_id><wp:category_nicename>documentation</wp:category_nicename><wp:category_parent></wp:category_parent><wp:cat_name><![CDATA[Documentation]]></wp:cat_name></wp:category>
	<wp:category><wp:term_id>31</wp:term_id><wp:category_nicename>education</wp:category_nicename><wp:category_parent></wp:category_parent><wp:cat_name><![CDATA[Education]]></wp:cat_name></wp:category>
	<wp:category><wp:term_id>28</wp:term_id><wp:category_nicename>estimation</wp:category_nicename><wp:category_parent></wp:category_parent><wp:cat_name><![CDATA[Estimation]]></wp:cat_name></wp:category>
	<wp:category><wp:term_id>14</wp:term_id><wp:category_nicename>experience-reports</wp:category_nicename><wp:category_parent></wp:category_parent><wp:cat_name><![CDATA[Experience Reports]]></wp:cat_name></wp:category>
	<wp:category><wp:term_id>4</wp:term_id><wp:category_nicename>general</wp:category_nicename><wp:category_parent></wp:category_parent><wp:cat_name><![CDATA[General]]></wp:cat_name></wp:category>
	<wp:category><wp:term_id>33</wp:term_id><wp:category_nicename>literature-reviews</wp:category_nicename><wp:category_parent></wp:category_parent><wp:cat_name><![CDATA[Literature Reviews]]></wp:cat_name></wp:category>
	<wp:category><wp:term_id>27</wp:term_id><wp:category_nicename>meta</wp:category_nicename><wp:category_parent></wp:category_parent><wp:cat_name><![CDATA[Meta]]></wp:cat_name></wp:category>
	<wp:category><wp:term_id>15</wp:term_id><wp:category_nicename>metrics</wp:category_nicename><wp:category_parent></wp:category_parent><wp:cat_name><![CDATA[Metrics]]></wp:cat_name></wp:category>
	<wp:category><wp:term_id>7</wp:term_id><wp:category_nicename>mining</wp:category_nicename><wp:category_parent></wp:category_parent><wp:cat_name><![CDATA[Mining]]></wp:cat_name></wp:category>
	<wp:category><wp:term_id>23</wp:term_id><wp:category_nicename>noticed</wp:category_nicename><wp:category_parent></wp:category_parent><wp:cat_name><![CDATA[Noticed]]></wp:cat_name></wp:category>
	<wp:category><wp:term_id>19</wp:term_id><wp:category_nicename>open-source</wp:category_nicename><wp:category_parent></wp:category_parent><wp:cat_name><![CDATA[Open Source]]></wp:cat_name></wp:category>
	<wp:category><wp:term_id>11</wp:term_id><wp:category_nicename>organizational-studies</wp:category_nicename><wp:category_parent></wp:category_parent><wp:cat_name><![CDATA[Organizational Studies]]></wp:cat_name></wp:category>
	<wp:category><wp:term_id>17</wp:term_id><wp:category_nicename>pair-programming</wp:category_nicename><wp:category_parent></wp:category_parent><wp:cat_name><![CDATA[Pair Programming]]></wp:cat_name></wp:category>
	<wp:category><wp:term_id>34</wp:term_id><wp:category_nicename>practices</wp:category_nicename><wp:category_parent></wp:category_parent><wp:cat_name><![CDATA[Practices]]></wp:cat_name></wp:category>
	<wp:category><wp:term_id>22</wp:term_id><wp:category_nicename>programming-languages</wp:category_nicename><wp:category_parent></wp:category_parent><wp:cat_name><![CDATA[Programming Languages]]></wp:cat_name></wp:category>
	<wp:category><wp:term_id>12</wp:term_id><wp:category_nicename>qualitative-studies</wp:category_nicename><wp:category_parent></wp:category_parent><wp:cat_name><![CDATA[Qualitative Studies]]></wp:cat_name></wp:category>
	<wp:category><wp:term_id>6</wp:term_id><wp:category_nicename>quality</wp:category_nicename><wp:category_parent></wp:category_parent><wp:cat_name><![CDATA[Quality]]></wp:cat_name></wp:category>
	<wp:category><wp:term_id>21</wp:term_id><wp:category_nicename>quantitative-studies</wp:category_nicename><wp:category_parent></wp:category_parent><wp:cat_name><![CDATA[Quantitative Studies]]></wp:cat_name></wp:category>
	<wp:category><wp:term_id>45</wp:term_id><wp:category_nicename>questions</wp:category_nicename><wp:category_parent></wp:category_parent><wp:cat_name><![CDATA[Questions]]></wp:cat_name></wp:category>
	<wp:category><wp:term_id>10</wp:term_id><wp:category_nicename>refactoring</wp:category_nicename><wp:category_parent></wp:category_parent><wp:cat_name><![CDATA[Refactoring]]></wp:cat_name></wp:category>
	<wp:category><wp:term_id>40</wp:term_id><wp:category_nicename>reproducibility</wp:category_nicename><wp:category_parent></wp:category_parent><wp:cat_name><![CDATA[Reproducibility]]></wp:cat_name></wp:category>
	<wp:category><wp:term_id>35</wp:term_id><wp:category_nicename>scientific-computing</wp:category_nicename><wp:category_parent></wp:category_parent><wp:cat_name><![CDATA[Scientific Computing]]></wp:cat_name></wp:category>
	<wp:category><wp:term_id>24</wp:term_id><wp:category_nicename>survey</wp:category_nicename><wp:category_parent></wp:category_parent><wp:cat_name><![CDATA[Survey]]></wp:cat_name></wp:category>
	<wp:category><wp:term_id>25</wp:term_id><wp:category_nicename>testing</wp:category_nicename><wp:category_parent></wp:category_parent><wp:cat_name><![CDATA[Testing]]></wp:cat_name></wp:category>
	<wp:category><wp:term_id>26</wp:term_id><wp:category_nicename>tools</wp:category_nicename><wp:category_parent></wp:category_parent><wp:cat_name><![CDATA[Tools]]></wp:cat_name></wp:category>
	<wp:category><wp:term_id>1</wp:term_id><wp:category_nicename>uncategorized</wp:category_nicename><wp:category_parent></wp:category_parent><wp:cat_name><![CDATA[Uncategorized]]></wp:cat_name></wp:category>
	<wp:category><wp:term_id>8</wp:term_id><wp:category_nicename>usability</wp:category_nicename><wp:category_parent></wp:category_parent><wp:cat_name><![CDATA[Usability]]></wp:cat_name></wp:category>
	<wp:category><wp:term_id>13</wp:term_id><wp:category_nicename>verification</wp:category_nicename><wp:category_parent></wp:category_parent><wp:cat_name><![CDATA[Verification]]></wp:cat_name></wp:category>
	<wp:category><wp:term_id>32</wp:term_id><wp:category_nicename>video</wp:category_nicename><wp:category_parent></wp:category_parent><wp:cat_name><![CDATA[Video]]></wp:cat_name></wp:category>
	<wp:tag><wp:term_id>43</wp:term_id><wp:tag_slug>architecture</wp:tag_slug><wp:tag_name><![CDATA[architecture]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>44</wp:term_id><wp:tag_slug>nfr</wp:tag_slug><wp:tag_name><![CDATA[NFR]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>29</wp:term_id><wp:tag_slug>requirements</wp:tag_slug><wp:tag_name><![CDATA[requirements]]></wp:tag_name></wp:tag>
	<wp:term><wp:term_id>41</wp:term_id><wp:term_taxonomy>nav_menu</wp:term_taxonomy><wp:term_slug>main</wp:term_slug><wp:term_name><![CDATA[Main]]></wp:term_name></wp:term>

	<generator>http://wordpress.org/?v=3.5.2</generator>

	<item>
		<title>Theory and practice</title>
		<link>http://www.neverworkintheory.org/?p=6</link>
		<pubDate>Mon, 27 Jun 2011 21:41:32 +0000</pubDate>
		<dc:creator>jorge</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=6</guid>
		<description></description>
		<content:encoded><![CDATA[People have been building complex software for over sixty years, but until recently, only a handful of researchers had studied how it was actually done. Many people had opinions---often very strong ones---but most of these were based on personal anecdotes, or on the kind of "it's obvious" reasoning that led Aristotle to conclude that heavy objects fall faster than light ones.

To make matters worse, many of the studies that were done were crippled by lack of generality, artificiality, or small sample sizes. As a result, while software engineering billed itself as a "hard" science, rigor was much less common than in "soft" disciplines like marketing, which has gone from the gut instincts of <em>Mad Men</em> to being a quantitative, analytic discipline.

Over the last fifteen years, though, there has been a sea change. Instead of just inventing new tools or processes, describing their application to toy problems in academic journals, and then wondering why practitioners ignored them, a growing number of software development researchers have been looking to real life for both questions and answers. In doing so, some are increasing the sophistication of their quantitative research toolkit, putting the power of statistics and data mining to good use as they plow through massive amounts of electronic records. Others have used rigorous qualitative techniques from anthropology and business studies to deal with complexities that <em>t</em>-tests and data mining algorithms cannot handle.

Sadly, most people in industry still don't know what researchers have found out, or even what kinds of questions they could answer. One reason is their belief that software engineering research is so divorced from real-world problems that it has nothing of value to offer them (an impression that is reinforced by how irrelevant most popular software engineering textbooks seem to the undergraduates who are forced to wade through them, and by how little software most software engineering professors have ever built).

Another reason is many programmers' disdain for qualitative research methods, which are often dismissed out of hand (and out of ignorance) as "soft". A third reason is ignorance---often willful---among practitioners themselves. People will cling to creationism, refuse to accept the reality of anthropogenic climate change, or insist that vaccines cause autism; it is therefore no surprise that many programmers continue to act as if a couple of pints and a quotation from some self-appointed guru constitute "proof" that one programming language is better than another.

The aim of this blog is to be a bridge between theory and practice. Each week, we will highlight some of the most useful results from studies past and present. We hope that this will encourage researchers and practitioners to talk about what we know, what we think we know that ain't actually so, why we believe some things but not others, and what questions should be tackled next.]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>6</wp:post_id>
		<wp:post_date>2011-06-27 14:41:32</wp:post_date>
		<wp:post_date_gmt>2011-06-27 21:41:32</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>theory-and-practice</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="general"><![CDATA[General]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>2</wp:comment_id>
			<wp:comment_author><![CDATA[Announcing &#8220;It will never work in theory&#8221; | Catenary]]></wp:comment_author>
			<wp:comment_author_email></wp:comment_author_email>
			<wp:comment_author_url>http://catenary.wordpress.com/2011/06/28/announcing-it-will-never-work-in-theory/</wp:comment_author_url>
			<wp:comment_author_IP>76.74.248.138</wp:comment_author_IP>
			<wp:comment_date>2011-06-28 15:47:28</wp:comment_date>
			<wp:comment_date_gmt>2011-06-28 22:47:28</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[[...] so we created It will never work in theory, a new software development research blog. As we explain in the introductory post, we want this blog to be a bridge between research and practice. To begin with, it&#8217;s modeled [...]]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type>pingback</wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1309301248.9363";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1309301314.6967";s:7:"message";s:44:"jorge changed the comment status to approved";s:5:"event";s:15:"status-approved";s:4:"user";s:5:"jorge";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>3</wp:comment_id>
			<wp:comment_author><![CDATA[Cliff McCollum]]></wp:comment_author>
			<wp:comment_author_email>cliffmcc@gmail.com</wp:comment_author_email>
			<wp:comment_author_url>http://leadingsoftware.ca</wp:comment_author_url>
			<wp:comment_author_IP>64.251.77.193</wp:comment_author_IP>
			<wp:comment_date>2011-06-28 16:53:49</wp:comment_date>
			<wp:comment_date_gmt>2011-06-28 23:53:49</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[I'm really excited about the conversations this blog might create. Hopefully the right people will choose to get involved. There's so much to learn.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1309305230.0084";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1309305253.4614";s:7:"message";s:44:"jorge changed the comment status to approved";s:5:"event";s:15:"status-approved";s:4:"user";s:5:"jorge";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>4</wp:comment_id>
			<wp:comment_author><![CDATA[Will Sargent]]></wp:comment_author>
			<wp:comment_author_email>will.sargent@gmail.com</wp:comment_author_email>
			<wp:comment_author_url>http://tersesystems.com</wp:comment_author_url>
			<wp:comment_author_IP>99.27.43.230</wp:comment_author_IP>
			<wp:comment_date>2011-06-28 18:46:25</wp:comment_date>
			<wp:comment_date_gmt>2011-06-29 01:46:25</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[I really like the evidence based software engineering site: http://www.dur.ac.uk/ebse/

There's also a book, "A Handbook of Software and Systems Engineering: Empirical Observations, Laws and Theories" which attempts to formalize the papers into one place.  It's a good read, although some of the laws are a bit out of date (i.e. CASE tools).]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1309311985.4791";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>5</wp:comment_id>
			<wp:comment_author><![CDATA[Mauro Botelho]]></wp:comment_author>
			<wp:comment_author_email>mauro@e-botelho.com</wp:comment_author_email>
			<wp:comment_author_url>http://www.e-botelho.com</wp:comment_author_url>
			<wp:comment_author_IP>98.242.102.94</wp:comment_author_IP>
			<wp:comment_date>2011-06-28 18:49:01</wp:comment_date>
			<wp:comment_date_gmt>2011-06-29 01:49:01</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[As Cliff, this is something that I'm very interested on.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:14:"1309312141.896";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>6</wp:comment_id>
			<wp:comment_author><![CDATA[Jorge Aranda]]></wp:comment_author>
			<wp:comment_author_email>jarandag@gmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>142.104.21.214</wp:comment_author_IP>
			<wp:comment_date>2011-06-29 10:45:23</wp:comment_date>
			<wp:comment_date_gmt>2011-06-29 17:45:23</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Thanks Will. Yes, the EBSE project is a good resource, too.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>4</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1309369523.1108";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:5:"jorge";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>9</wp:comment_id>
			<wp:comment_author><![CDATA[Steven Clarke]]></wp:comment_author>
			<wp:comment_author_email>stevencl@microsoft.com</wp:comment_author_email>
			<wp:comment_author_url>http://blogs.msdn.com/b/stevencl/</wp:comment_author_url>
			<wp:comment_author_IP>94.245.127.15</wp:comment_author_IP>
			<wp:comment_date>2011-06-30 02:46:51</wp:comment_date>
			<wp:comment_date_gmt>2011-06-30 09:46:51</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[I work in the Visual Studio user experience team, so I think that makes me a practitioner, but I'm not a creationist, I believe in anthropogenic climate change and I make sure my children's vaccinations are all up to date. And thankfully I'm not unique amongst my fellow practitioners :-).

While I do agree with some of the reasons stated for the lack of uptake of research into industry, I don't agree that one of them is wilful ignorance on the part of the practitioners. Instead, I believe aligning the research with the business objectives is one of the largest obstacles. Without alignment, it's almost impossible for the research to have an impact. Of course, business objectives are typically confidential so it's not always easy to find out what a business really cares about.

We're lucky at Microsoft to have Microsoft Research (MSR) but we still face the challenge of deriving maximum value from the work that MSR does. The most successful strategy so far has been to enter into a semi formal partnership between the research organisation and the business unit. Such a partnership for example resulted in the Code Canvas work by Kael Rowan and Rob Deline (http://research.microsoft.com/en-us/projects/codecanvas/).

Such a partnership helps each side understand what each other's main priorities and objectives are and how they can work together to achieve those objectives.

Another thing that might be worth pointing out is that it might well be the case that some of the research is having an impact, but it might not always be obvious. In my own experience for example, we've used Thomas Green's Cognitive Dimensions framework for a number of years now when considering the user experience of our APIs and frameworks, but we don't publish this work as extensively as we'd like to. Writing and publishing papers isn't as high a priority for my group as it would be if we were a research organisation.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[true]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1309427211.8893";s:7:"message";s:35:"Akismet caught this comment as spam";s:5:"event";s:10:"check-spam";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1309461783.4389";s:7:"message";s:39:"jorge reported this comment as not spam";s:5:"event";s:10:"report-ham";s:4:"user";s:5:"jorge";}]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_user_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_user</wp:meta_key>
				<wp:meta_value><![CDATA[jorge]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1309463427.3037";s:7:"message";s:44:"jorge changed the comment status to approved";s:5:"event";s:15:"status-approved";s:4:"user";s:5:"jorge";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>11</wp:comment_id>
			<wp:comment_author><![CDATA[Jorge Aranda]]></wp:comment_author>
			<wp:comment_author_email>jarandag@gmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>24.68.65.123</wp:comment_author_IP>
			<wp:comment_date>2011-06-30 13:29:36</wp:comment_date>
			<wp:comment_date_gmt>2011-06-30 20:29:36</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Thanks for your comments, Steven. I was actually a research intern at Rob DeLine's group a few years ago, and it's great to see that its Code Canvas project is picking up so much strength.

<blockquote>While I do agree with some of the reasons stated for the lack of uptake of research into industry, I don’t agree that one of them is wilful ignorance on the part of the practitioners.</blockquote>

I don't mean at all to suggest that practitioners are somehow anti-science. Merely that software development has more than its share of dogma and unsubstantiated claims; claims that sometimes fly in the face of what the best current research is telling us.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>9</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1309465776.8652";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:5:"jorge";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>18</wp:comment_id>
			<wp:comment_author><![CDATA[Rafael de F. Ferreira]]></wp:comment_author>
			<wp:comment_author_email>public@rafaelferreira.net</wp:comment_author_email>
			<wp:comment_author_url>http://www.rafaelferreira.net/</wp:comment_author_url>
			<wp:comment_author_IP>200.184.133.245</wp:comment_author_IP>
			<wp:comment_date>2011-07-01 08:46:08</wp:comment_date>
			<wp:comment_date_gmt>2011-07-01 15:46:08</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Somewhere you guys stated that Lambda the Ultimate was an inspiration for this site. One of the nice things about LtU that could perhaps be replicated here is the open forum (with strict etiquette rules to avoid flames and trolls) where interesting posts can be promoted to the front page.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1309535168.8005";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>19</wp:comment_id>
			<wp:comment_author><![CDATA[Jorge Aranda]]></wp:comment_author>
			<wp:comment_author_email>jorge@neverworkintheory.org</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>24.68.65.123</wp:comment_author_IP>
			<wp:comment_date>2011-07-02 07:32:21</wp:comment_date>
			<wp:comment_date_gmt>2011-07-02 14:32:21</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Thanks Rafael, that's a good suggestion. We'll probably include a forum soon.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>18</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:14:"1309617141.735";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:5:"jorge";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>5747</wp:comment_id>
			<wp:comment_author><![CDATA[Lucky industry girl finds fulfillment in academia | The CHISEL Group, University of Victoria, BC]]></wp:comment_author>
			<wp:comment_author_email></wp:comment_author_email>
			<wp:comment_author_url>http://thechiselgroup.org/2013/02/01/lucky-industry-girl-finds-fulfillment-in-academia/</wp:comment_author_url>
			<wp:comment_author_IP>66.155.8.237</wp:comment_author_IP>
			<wp:comment_date>2013-02-01 14:34:44</wp:comment_date>
			<wp:comment_date_gmt>2013-02-01 22:34:44</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[[...] read a great comment from one of our alumni, Jorge Aranda, who spent time with local tech companies trying to find solutions to some of their process [...]]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type>pingback</wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";d:1359758084.3588631153106689453125;s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
		<title>Ownership, experience, and defects</title>
		<link>http://www.neverworkintheory.org/?p=9</link>
		<pubDate>Mon, 27 Jun 2011 21:44:15 +0000</pubDate>
		<dc:creator>jorge</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=9</guid>
		<description></description>
		<content:encoded><![CDATA[<em><a title="Foyzur Rahman's website" href="http://csiflabs.cs.ucdavis.edu/~foyzur/">Foyzur Rahman</a> and <a title="Prem Devanbu's website" href="http://www.cs.ucdavis.edu/~devanbu/">Premkumar Devanbu</a>, <strong><a href="http://macbeth.cs.ucdavis.edu/icse2011.pdf">"Ownership, Experience and Defects: A Fine-Grained Study of Authorship"</a></strong>. ICSE 2011:</em>
<blockquote>Recent research indicates that “people” factors such as ownership, experience, organizational structure, and geographic distribution have a big impact on software quality. Understanding these factors, and properly deploying people resources can help managers improve quality outcomes. This paper considers the impact of code ownership and developer experience on software quality. In a large project, a ﬁle might be entirely owned by a single developer, or worked on by many. Some previous research indicates that more developers working on a ﬁle might lead to more defects. Prior research considered this phenomenon at the level of modules or ﬁles, and thus does not tease apart and study the eﬀect of contributions of different developers to each module or ﬁle. We exploit a modern version control system to examine this issue at a ﬁne-grained level. Using version history, we examine contributions to code fragments that are actually repaired to ﬁx bugs. Are these code fragments “implicated” in bugs the result of contributions from many? or from one? Does experience matter? What type of experience? We ﬁnd that implicated code is more strongly associated with a single developer’s contribution; our ﬁndings also indicate that an author’s specialized experience in the target ﬁle is more important than general experience. Our ﬁndings suggest that quality control eﬀorts could be proﬁtably targeted at changes made by single developers with limited prior experience on that ﬁle.</blockquote>
The findings are a bit hard to parse from the abstract, but the upshot is that (a) code worked on by a single developer (as opposed to many developers) is more often implicated in defects, and that (b) while a developer's general experience in a project is not correlated with the rate of defects introduced in it, the developer's experience with <em>the file in question</em>, in particular, is correlated with a lesser likelihood of introducing defects in it.]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>9</wp:post_id>
		<wp:post_date>2011-06-27 14:44:15</wp:post_date>
		<wp:post_date_gmt>2011-06-27 21:44:15</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>ownership-experience-and-defects</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="code-ownership"><![CDATA[Code Ownership]]></category>
		<category domain="category" nicename="mining"><![CDATA[Mining]]></category>
		<category domain="category" nicename="quality"><![CDATA[Quality]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>7</wp:comment_id>
			<wp:comment_author><![CDATA[Software Carpentry &raquo; It Will Never Work in Theory]]></wp:comment_author>
			<wp:comment_author_email></wp:comment_author_email>
			<wp:comment_author_url>http://software-carpentry.org/2011/06/it-will-never-work-in-theory/</wp:comment_author_url>
			<wp:comment_author_IP>69.163.247.75</wp:comment_author_IP>
			<wp:comment_date>2011-06-29 15:09:02</wp:comment_date>
			<wp:comment_date_gmt>2011-06-29 22:09:02</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[[...] Rahman and Devanbu&#8216;s &#8220;Ownership, Experience, and Defects: A Fine-Grained Study of Authorship&#8221;, which found that code worked on by one developer (rather than many) is more often implicated in defects, but that a developer&#8217;s experience with a particular file (rather than the project in general) reduces defect rates. [...]]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type>pingback</wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1309385342.8449";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>8</wp:comment_id>
			<wp:comment_author><![CDATA[Robert Kern]]></wp:comment_author>
			<wp:comment_author_email>robert.kern@gmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>216.62.213.237</wp:comment_author_IP>
			<wp:comment_date>2011-06-29 16:50:24</wp:comment_date>
			<wp:comment_date_gmt>2011-06-29 23:50:24</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[The paper's link is currently broken for me. The coauthor seems to have it available, though. http://macbeth.cs.ucdavis.edu/icse2011.pdf]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1309391424.1373";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>10</wp:comment_id>
			<wp:comment_author><![CDATA[Jorge Aranda]]></wp:comment_author>
			<wp:comment_author_email>jarandag@gmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>24.68.65.123</wp:comment_author_IP>
			<wp:comment_date>2011-06-30 12:05:42</wp:comment_date>
			<wp:comment_date_gmt>2011-06-30 19:05:42</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Thanks Robert; I've fixed it above, too.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>8</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1309460742.8222";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:5:"jorge";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>12</wp:comment_id>
			<wp:comment_author><![CDATA[MSN]]></wp:comment_author>
			<wp:comment_author_email>msn.foo.bar+nwit@gmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>66.62.245.82</wp:comment_author_IP>
			<wp:comment_date>2011-06-30 14:03:28</wp:comment_date>
			<wp:comment_date_gmt>2011-06-30 21:03:28</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Interesting! I found a similar Microsoft Research paper testing out the effects of ownership and contribution for Vista and Windows 7:

http://www.cabird.com/papers/bird2011dtm.pdf]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1309467808.9032";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>13</wp:comment_id>
			<wp:comment_author><![CDATA[Jorge Aranda]]></wp:comment_author>
			<wp:comment_author_email>jarandag@gmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>24.68.65.123</wp:comment_author_IP>
			<wp:comment_date>2011-06-30 14:17:17</wp:comment_date>
			<wp:comment_date_gmt>2011-06-30 21:17:17</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[That's Bird & Co.'s FSE 2011 paper---since FSE will take place in September, it hasn't been presented yet: you got it fresh from the oven!

Just skimming it, it seems to me a pretty good paper. We'll add a separate entry for it later on...]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>12</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1309468637.1407";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:5:"jorge";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
		<title>Refactoring pipe-like mashups for end-user programmers</title>
		<link>http://www.neverworkintheory.org/?p=13</link>
		<pubDate>Mon, 27 Jun 2011 21:46:08 +0000</pubDate>
		<dc:creator>jorge</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=13</guid>
		<description></description>
		<content:encoded><![CDATA[<em><a title="Kathryn Stolee's website" href="http://cse.unl.edu/~kstolee/index.html">Kathryn Stolee</a> and <a title="Sebastian Elbaum's website" href="http://cse.unl.edu/~elbaum/content/">Sebastian Elbaum</a>, <a href="http://cse.unl.edu/~kstolee/icse2011.pdf"><strong>"Refactoring Pipe-like Mashups for End-User Programmers"</strong></a>. ICSE 2011:</em>
<blockquote>Mashups are becoming increasingly popular as end users are able to easily access, manipulate, and compose data from many web sources. We have observed, however, that mashups tend to suffer from deficiencies that propagate as mashups are reused. To address these deficiencies, we would like to bring some of the benefits of software engineering techniques to the end users creating these programs. In this work, we focus on identifying code smells indicative of the deficiencies we observed in web mashups programmed in the popular Yahoo! Pipes environment. Through an empirical study, we explore the impact of those smells on end-user programmers and observe that users generally prefer mashups without smells. We then introduce refactorings targeting those smells, reducing the complexity of the mashup programs, increasing their abstraction, updating broken data sources and dated components, and standardizing their structures to fit the community development patterns. Our assessment of a large sample of mashups shows that smells are present in 81% of them and that the proposed refactorings can reduce the number of smelly mashups to 16%, illustrating the potential of refactoring to support the thousands of end users programming mashups.</blockquote>
A great use of computer science-y automation to improve end-user programs. In this case the beneficiaries are <a href="http://pipes.yahoo.com/pipes/">Yahoo! Pipes</a> users, but the same <em>code smell -&gt; refactor</em> principle can easily be used in other web mashups, and eventually in other kinds of end-user programs.]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>13</wp:post_id>
		<wp:post_date>2011-06-27 14:46:08</wp:post_date>
		<wp:post_date_gmt>2011-06-27 21:46:08</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>refactoring-pipe-like-mashups-for-end-user-programmers</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="code-smells"><![CDATA[Code Smells]]></category>
		<category domain="category" nicename="refactoring"><![CDATA[Refactoring]]></category>
		<category domain="category" nicename="usability"><![CDATA[Usability]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Organizational volatility and its effects on software</title>
		<link>http://www.neverworkintheory.org/?p=17</link>
		<pubDate>Mon, 27 Jun 2011 21:47:12 +0000</pubDate>
		<dc:creator>jorge</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=17</guid>
		<description></description>
		<content:encoded><![CDATA[<em><a title="Audris Mockus' website" href="http://mockus.us/">Audris Mockus</a>, <strong><a href="http://mockus.us/papers/orgQuality.pdf">"Organizational Volatility and its Effects on Software"</a></strong>. FSE 2010:</em>
<blockquote>The key premise of an organization is to allow more efficient production, including production of high quality software. To achieve that, an organization defines roles and reporting relationships. Therefore, changes in organization’s structure are likely to affect product’s quality. We propose and investigate a relationship between developer-centric measures of organizational change and the probability of customer-reported defects in the context of a large software project. We find that the proximity to an organizational change is significantly associated with reductions in software quality. We also replicate results of several prior studies of software quality supporting findings that code, change, and developer characteristics affect fault-proneness. In contrast to prior studies we find that distributed development decreases quality. Furthermore, recent departures from an organization were associated with increased probability of customer-reported defects, thus demonstrating that in the observed context the organizational change reduces product quality.</blockquote>
The influx of newcomers into an organization does not seem to increase defects in its software, perhaps because newcomers get simple tasks at the start. However, other changes to the organization (and especially departures from it) hurt its software significantly. In his paper, Mockus notes that organizational volatility is <em>not</em> the main driver of defects---that would be the technical complexity of the code. But his organizational change measures still explain over 20% of the variance in fault-proneness of the code.]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>17</wp:post_id>
		<wp:post_date>2011-06-27 14:47:12</wp:post_date>
		<wp:post_date_gmt>2011-06-27 21:47:12</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>organizational-volatility-and-its-effects-on-software</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="mining"><![CDATA[Mining]]></category>
		<category domain="category" nicename="organizational-studies"><![CDATA[Organizational Studies]]></category>
		<category domain="category" nicename="quality"><![CDATA[Quality]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>About</title>
		<link>http://www.neverworkintheory.org/?page_id=27</link>
		<pubDate>Tue, 28 Jun 2011 04:45:57 +0000</pubDate>
		<dc:creator>jorge</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?page_id=27</guid>
		<description></description>
		<content:encoded><![CDATA[People have been building complex software for over sixty years, but  until recently, only a handful of researchers had studied how it was  actually done. Many people had opinions---often very strong ones---but  most of these were based on personal anecdotes, or on the kind of "it's  obvious" reasoning that led Aristotle to conclude that heavy objects  fall faster than light ones.

To make matters worse, many of the studies that were done were  crippled by lack of generality, artificiality, or small sample sizes. As  a result, while software engineering billed itself as a "hard" science,  rigor was much less common than in "soft" disciplines like marketing,  which has gone from the gut instincts of <em>Mad Men</em> to being a quantitative, analytic discipline.

Over the last fifteen years, though, there has been a sea change.  Instead of just inventing new tools or processes, describing their  application to toy problems in academic journals, and then wondering why  practitioners ignored them, a growing number of software development  researchers have been looking to real life for both questions and  answers. In doing so, some are increasing the sophistication of their  quantitative research toolkit, putting the power of statistics and data  mining to good use as they plow through massive amounts of electronic  records. Others have used rigorous qualitative techniques from  anthropology and business studies to deal with complexities that <em>t</em>-tests and data mining algorithms cannot handle.

Sadly, most people in industry still don't know what researchers have  found out, or even what kinds of questions they could answer. One  reason is their belief that software engineering research is so divorced  from real-world problems that it has nothing of value to offer them (an  impression that is reinforced by how irrelevant most popular software  engineering textbooks seem to the undergraduates who are forced to wade  through them, and by how little software most software engineering  professors have ever built).

Another reason is many programmers' disdain for qualitative research  methods, which are often dismissed out of hand (and out of ignorance) as  "soft". A third reason is ignorance---often willful---among  practitioners themselves. People will cling to creationism, refuse to  accept the reality of anthropogenic climate change, or insist that  vaccines cause autism; it is therefore no surprise that many programmers  continue to act as if a couple of pints and a quotation from some  self-appointed guru constitute "proof" that one programming language is  better than another.

The aim of this blog is to be a bridge between theory and practice.  Each week, we will highlight some of the most useful results from  studies past and present. We hope that this will encourage researchers  and practitioners to talk about what we know, what we think we know that  ain't actually so, why we believe some things but not others, and what  questions should be tackled next.]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>27</wp:post_id>
		<wp:post_date>2011-06-27 21:45:57</wp:post_date>
		<wp:post_date_gmt>2011-06-28 04:45:57</wp:post_date_gmt>
		<wp:comment_status>closed</wp:comment_status>
		<wp:ping_status>closed</wp:ping_status>
		<wp:post_name>about</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>page</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wp_page_template</wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Contact us</title>
		<link>http://www.neverworkintheory.org/?page_id=31</link>
		<pubDate>Wed, 29 Jun 2011 00:06:14 +0000</pubDate>
		<dc:creator>jorge</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?page_id=31</guid>
		<description></description>
		<content:encoded><![CDATA[Do you have pointers for interesting software development research that should be featured here? Ideas about how to improve this site? Please send a word to <a href="mailto:jorge@neverworkintheory.org">jorge@neverworkintheory.org</a>.

~~~~~ o ~~~~~

<strong>Current collaborators (in alphabetic order):</strong>
<ul>
	<li><a href="http://cuevano.ca/">Jorge Aranda</a>, software developer</li>
	<li><a href="http://neilernst.net/">Neil Ernst</a>, researcher at the Software Engineering Institute of Carnegie Mellon</li>
	<li><a href="http://www.felienne.com/">Felienne Hermans</a>, assistant professor at Delft University of Technology</li>
	<li><a href="http://www.fayolapeters.com/">Fayola Peters</a>, graduate research assistant and PhD candidate at West Virginia University</li>
	<li><a href="http://leif.me/">Leif Singer</a>, postdoctoral fellow at the University of Victoria, BC</li>
	<li><a href="http://ctreude.ca/">Christoph Treude</a>, postdoctoral fellow at McGill University</li>
	<li><a href="http://third-bit.com/">Greg Wilson</a>, leader of the <a href="http://software-carpentry.org/">Software Carpentry</a> project</li>
</ul>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>31</wp:post_id>
		<wp:post_date>2011-06-28 17:06:14</wp:post_date>
		<wp:post_date_gmt>2011-06-29 00:06:14</wp:post_date_gmt>
		<wp:comment_status>closed</wp:comment_status>
		<wp:ping_status>closed</wp:ping_status>
		<wp:post_name>contact-us</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>30</wp:menu_order>
		<wp:post_type>page</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[no]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wp_page_template</wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>sharing_disabled</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Let&#039;s Go to the Whiteboard</title>
		<link>http://www.neverworkintheory.org/?p=40</link>
		<pubDate>Fri, 01 Jul 2011 04:18:57 +0000</pubDate>
		<dc:creator>gvwilson</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=40</guid>
		<description></description>
		<content:encoded><![CDATA[<a href="http://www.i-cherubini.it/mauro/blog/">Mauro Cherubini</a>, <a href="http://research.microsoft.com/en-us/people/ginav/">Gina Venolia</a>, <a href="http://research.microsoft.com/en-us/people/rdeline/">Rob DeLine</a>, and <a href="http://faculty.washington.edu/ajko/">Andrew J. Ko</a>: “<a href="http://www.i-cherubini.it/mauro/publications/index.php?dir=&amp;file=Cherubini_Lets-Go-to-the-Whiteboard-How-and-Why-Software-Developers-Use-Drawings_2007.pdf">Let's Go to the Whiteboard: How and Why Software Developers Use Drawings</a>”. <a href="http://www.chi2007.org/">CHI 2007</a>.
<blockquote><em>Software developers are rooted in the written form of their code, yet they often draw diagrams representing their code. Unfortunately, we still know little about how and why they create these diagrams, and so there is little research to inform the design of visual tools to support developers' work. This paper presents findings from semi-structured interviews that have been validated with a structured survey. Results show that most of the diagrams had a transient nature because of the high cost of changing whiteboard sketches to electronic renderings. Diagrams that documented design decisions were often externalized in these temporary drawings and then subsequently lost. Current visualization tools and the software development practices that we observed do not solve these issues, but these results suggest several directions for future research.</em></blockquote>
A lot of people have pointed out that formal diagrammatic notations for software, like UML, are taught much more often than they're used. This paper goes a long way toward explaining the reason: in almost all cases, developers use diagrams as a way of keeping track of bits of conversation while talking to each other, rather than as archival documentation for the benefit of people who weren't there at the time, and the cost of turning the first into the second is so great that almost no-one ever does it voluntarily.  As well as explaining one aspect of real-world software development, this paper is also a great example of how qualitative methods can produce answers that quantitative investigation never could.]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>40</wp:post_id>
		<wp:post_date>2011-06-30 21:18:57</wp:post_date>
		<wp:post_date_gmt>2011-07-01 04:18:57</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>lets-go-to-the-whiteboard</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="qualitative-studies"><![CDATA[Qualitative Studies]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>14</wp:comment_id>
			<wp:comment_author><![CDATA[Dirkjan Ochtman]]></wp:comment_author>
			<wp:comment_author_email>dirkjan@ochtman.nl</wp:comment_author_email>
			<wp:comment_author_url>http://dirkjan.ochtman.nl/</wp:comment_author_url>
			<wp:comment_author_IP>109.32.139.178</wp:comment_author_IP>
			<wp:comment_date>2011-06-30 23:36:00</wp:comment_date>
			<wp:comment_date_gmt>2011-07-01 06:36:00</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Hmm. I've found that just making a picture of the whiteboard, even if it's just with a crappy phone camera, goes a long way towards making the discussion/notes accessible for later use.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1309502160.3696";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>15</wp:comment_id>
			<wp:comment_author><![CDATA[Phil Ruse]]></wp:comment_author>
			<wp:comment_author_email>phil.ruse@gmail.com</wp:comment_author_email>
			<wp:comment_author_url>http://blog.philruse.com</wp:comment_author_url>
			<wp:comment_author_IP>86.182.131.41</wp:comment_author_IP>
			<wp:comment_date>2011-07-01 06:13:32</wp:comment_date>
			<wp:comment_date_gmt>2011-07-01 13:13:32</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Ditto, Dirkjan! We've gotten into the habit of taking snapshots of the whiteboard with the phone camera and dumping them on the intranet. Possibly not the most elegant solution!]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1309526012.1048";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>16</wp:comment_id>
			<wp:comment_author><![CDATA[gvwilson]]></wp:comment_author>
			<wp:comment_author_email>gvwilson@third-bit.com</wp:comment_author_email>
			<wp:comment_author_url>http://third-bit.com/</wp:comment_author_url>
			<wp:comment_author_IP>70.67.183.54</wp:comment_author_IP>
			<wp:comment_date>2011-07-01 06:51:19</wp:comment_date>
			<wp:comment_date_gmt>2011-07-01 13:51:19</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[We take pictures of whiteboard doodles too, but our experience is the same as what Cherubini et al report: people who weren't part of the conversation find them difficult or impossible to understand without their creator(s) present to explain them.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>15</wp:comment_parent>
			<wp:comment_user_id>2</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1309528279.7243";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:8:"gvwilson";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>17</wp:comment_id>
			<wp:comment_author><![CDATA[Rafael de F. Ferreira]]></wp:comment_author>
			<wp:comment_author_email>public@rafaelferreira.net</wp:comment_author_email>
			<wp:comment_author_url>http://www.rafaelferreira.net/</wp:comment_author_url>
			<wp:comment_author_IP>200.184.133.245</wp:comment_author_IP>
			<wp:comment_date>2011-07-01 08:42:08</wp:comment_date>
			<wp:comment_date_gmt>2011-07-01 15:42:08</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Fowler's discussion of UML modes - UML as a sketch, UML as a blueprint and UML as a programming language - seem relevant here: http://martinfowler.com/bliki/UmlMode.html]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1309534928.8515";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
		<title>Specification and Verification: The Spec# Experience</title>
		<link>http://www.neverworkintheory.org/?p=47</link>
		<pubDate>Fri, 01 Jul 2011 04:28:06 +0000</pubDate>
		<dc:creator>gvwilson</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=47</guid>
		<description></description>
		<content:encoded><![CDATA[<a href="http://research.microsoft.com/en-us/people/mbarnett/">Mike Barnett</a>, <a href="http://research.microsoft.com/en-us/people/maf/">Manuel Fähndrich</a>, <a href="http://research.microsoft.com/en-us/um/people/leino/">K. Rustan M. Leino</a>, <a href="http://www.pm.inf.ethz.ch/people/pmueller">Peter Müller</a>, <a href="http://research.microsoft.com/en-us/people/schulte/">Wolfram Schulte</a>, and <a href="http://research.microsoft.com/en-us/people/hermanv/">Herman Venter</a>: “<a href="http://research.microsoft.com/en-us/um/people/leino/papers/krml196.pdf">Specification and Verification: The Spec# Experience</a>”.  <a href="http://2011.icse-conferences.org/">ICSE 2011</a>
<blockquote><em>Spec# is a programming system that facilitates the development of correct software. The Spec# language extends C# with contracts that allow programmers to express their design intent in the code. The Spec# tool suite consists of a compiler that emits run-time checks for contracts, a static program verifier that attempts to mathematically prove the correctness of programs, and an integration into the Visual Studio development environment. Spec# shows how contracts and verifiers can be integrated seamlessly into the software development process. This paper reflects on the six-year history of the Spec# project, scientific contributions it has made, remaining challenges for tools that seek to establish program correctness, and prospects of incorporating verification into everyday software engineering.</em></blockquote>
A plethora of testing tools and static analyzers "suddenly" became mainstream a decade ago after years of hard work and experimentation by their creators.  Today, program verification tools are poised to become part of every serious developer's toolbox in the same way, not least because of the challenges of concurrent programming.  This experience report describes what a mature verification tool can do, and what its creators learned while building it and trying to persuade people to adopt it.  Even if you're not using C#, it offers a lot of insight into things to come.]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>47</wp:post_id>
		<wp:post_date>2011-06-30 21:28:06</wp:post_date>
		<wp:post_date_gmt>2011-07-01 04:28:06</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>specification-and-verification-the-spec-experience</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="experience-reports"><![CDATA[Experience Reports]]></category>
		<category domain="category" nicename="verification"><![CDATA[Verification]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Requirements Prioritization in Agile Projects: Insights from a Case Study</title>
		<link>http://www.neverworkintheory.org/?p=54</link>
		<pubDate>Mon, 04 Jul 2011 19:55:03 +0000</pubDate>
		<dc:creator>neil</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=54</guid>
		<description></description>
		<content:encoded><![CDATA[<a href="http://www.utwente.nl/ewi/is/staff/pages/racheva.doc/" target="_blank">Zornitza Racheva</a>, <a href="http://www.utwente.nl/ewi/is/staff/pages/daneva.doc/" target="_blank">Maya Daneva</a>, <a href="http://www.tu-braunschweig.de/sse/mitarbeiter/herrmann" target="_blank">Andrea Herrmann</a>, Klaus Sikkel and <a href="http://wwwhome.cs.utwente.nl/~roelw/" target="_blank">Roel Wieringa</a>, "<a href="http://eprints.eemcs.utwente.nl/18159/01/RE10_camera_ready.pdf" target="_blank">Do We Know Enough About Requirements Prioritization in Agile Projects: Insights from a Case Study</a>". <a href="http://www.re10.org/" target="_blank">RE10</a>.
<blockquote>Requirements prioritization is an essential mechanism of agile software development approaches. It maximizes the value delivered to the clients and accommodates changing requirements. This paper presents results of an exploratory cross-case study on agile prioritization and business value delivery processes in eight software organizations. We found that some explicit and fundamental assumptions of agile requirement prioritization approaches, as described in the agile literature on best practices, do not hold in all agile project contexts in our study. These are (i) the driving role of the client in the value creation process, (ii) the prevailing position of business value as a main prioritization criterion, (iii) the role of the prioritization process for project goal achievement. This implies that these assumptions have to be reframed and that the approaches to requirements prioritization for value creation need to be extended.</blockquote>
Mention the phrase "requirements engineering" to many software developers and you'll get a groan. For a long time, requirements engineering (elicitation, analysis, modeling, etc.) has been seen as something you do to satisfy the paper-pushers. There's even a derogatory acronym: BRUF, Big Requirements Up Front. Nevertheless, the fact remains that we typically build software to satisfy a user, even if the user is ourselves. Doing so requires us to think about what we should build, and, hopefully, why we are building it. While requirements may take different forms (user stories, tasks, use cases), they remain fundamental to the process of building software.

This paper points out that the problem of prioritizing requirements is even more of a concern in agile methodologies than other approaches. This is because short cycle times require frequent prioritization of the backlog. To do so, both XP and Scrum, for instance, call for an involved customer. However, this study found that this was rarely possible, and that as a result prioritization was done by the developers. Customers either found planning meetings too technical, or were not aware of their own requirements. They also found a difference in the understanding of the "value" of a requirement: there is a distinct difference between the value for the customer and the value for the developer. For example, developers might prefer to re-use solutions from other projects. Racheva et al. did find, though, that the notion of frequent, short iterations with re-prioritization was highly useful, in particular for dealing with new information and unclear requirements.]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>54</wp:post_id>
		<wp:post_date>2011-07-04 12:55:03</wp:post_date>
		<wp:post_date_gmt>2011-07-04 19:55:03</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>requirements-prioritization-in-agile-projects-insights-from-a-case-study</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="organizational-studies"><![CDATA[Organizational Studies]]></category>
		<category domain="category" nicename="qualitative-studies"><![CDATA[Qualitative Studies]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[3]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>771</wp:comment_id>
			<wp:comment_author><![CDATA[Kevin Patrick]]></wp:comment_author>
			<wp:comment_author_email>simplichat@gmail.com</wp:comment_author_email>
			<wp:comment_author_url>http://www.knowledgehut.com</wp:comment_author_url>
			<wp:comment_author_IP>122.166.230.117</wp:comment_author_IP>
			<wp:comment_date>2012-01-06 03:38:36</wp:comment_date>
			<wp:comment_date_gmt>2012-01-06 11:38:36</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Any info on Walking Skeleton method of agile Prioritizing?]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1325849917.0712";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
		<title>The Confounding Effect of Class Size on the Validity of Object-Oriented Metrics</title>
		<link>http://www.neverworkintheory.org/?p=58</link>
		<pubDate>Thu, 07 Jul 2011 13:08:53 +0000</pubDate>
		<dc:creator>gvwilson</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=58</guid>
		<description></description>
		<content:encoded><![CDATA[<a href="http://ehip.blogs.com/about.html">Khaled El Emam</a>, Saida Benlarbi, Nishith Goel, and Shesh N. Rai: "<a href="http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?arnumber=935855">The Confounding Effect of Class Size on the Validity of Object-Oriented Metrics</a>". IEEE Transasctions on Software Engineering, 27(7), July 2001.
<blockquote><em>Much effort has been devoted to the development and empirical validation of object-oriented metrics. The empirical validations performed thus far would suggest that a core set of validated metrics is close to being identified. However, none of these studies allow for the potentially confounding effect of class size. In this paper, we demonstrate a strong size confounding effect and question the results of previous object-oriented metrics validation studies. We first investigated whether there is a confounding effect of class size in validation studies of object-oriented metrics and show that, based on previous work, there is reason to believe that such an effect exists. We then describe a detailed empirical methodology for identifying those effects. Finally, we perform a study on a large C++ telecommunications framework to examine if size is really a confounder. This study considered the Chidamber and Kemerer metrics and a subset of the Lorenz and Kidd metrics. The dependent variable was the incidence of a fault attributable to a field failure (fault-proneness of a class). Our findings indicate that, before controlling for size, the results are very similar to previous studies: the metrics that are expected to be validated are indeed associated with fault-proneness. After controlling for size, none of the metrics we studied were associated with fault-proneness any more. This demonstrates a strong size confounding effect and casts doubt on the results of previous object-oriented metrics validation studies. It is recommended that previous validation studies be reexamined to determine whether their conclusions would still hold after controlling for size and that future validation studies should always control for size.</em></blockquote>
We all know that some programs are more complex than others, but can we actually quantify that?  Ever since the early 1970s, researchers have invented metrics (such as <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity">cyclomatic complexity</a> or <a href="http://en.wikipedia.org/wiki/Coupling_%28computer_programming%29">coupling</a> and <a href="http://en.wikipedia.org/wiki/Cohesion_%28computer_science%29">cohesion</a>), then validated them by seeing how well they correlate with things like post-release bug counts.  The idea is that if what we mean by "complex" is "hard to understand", complex software should have more bugs than simple software, and a measure that can predict the likely number of bugs in a product before it's released would be a very useful thing.

El Emam and his colleagues repeated some of those experiments using bivariate analysis so that they could allocate a share of the blame to code size (measured by number of lines) and the metric in question.  It turned out that code size accounted for all of the significant variation: in other words, the object-oriented metrics they looked at didn't have any actual predictive power once they normalized for the number of lines of code.  Herraiz and Hassan's chapter in <a href="http://www.amazon.com/Making-Software-Really-Works-Believe/dp/0596808321"><em>Making Software</em></a>, which reports on an even larger study using open source software, reached the same conclusion:
<blockquote><em>...for non-header files written in C language, all the complexity metrics are highly correlated with lines of code, and therefore the more complex metrics provide no further information that could not be measured simply with lines of code... In our opinion, there is a clear lesson from this study: syntactic complexity metrics cannot capture the whole picture of software complexity. Complexity metrics that are exclusively based on the structure of the program or the properties of the text...do not provide information on the amount of effort that is needed to comprehend a piece of code—or, at least, no more information than lines of code do.</em></blockquote>
This emphatically <em>doesn't</em> mean that trying to measure software is a waste of time: Weyuker and Ostrand's chapter in that same book shows that it is possible to predict which files are likely to contain the most bugs.  What it does mean, though, is that figuring out whether some new measure actually tells us something we didn't already know is harder than it seems.]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>58</wp:post_id>
		<wp:post_date>2011-07-07 06:08:53</wp:post_date>
		<wp:post_date_gmt>2011-07-07 13:08:53</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>the-confounding-effect-of-class-size-on-the-validity-of-object-oriented-metrics</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="metrics"><![CDATA[Metrics]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>26</wp:comment_id>
			<wp:comment_author><![CDATA[Robert Brewer]]></wp:comment_author>
			<wp:comment_author_email>fumanchu@aminus.org</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>99.30.180.185</wp:comment_author_IP>
			<wp:comment_date>2011-07-07 06:43:06</wp:comment_date>
			<wp:comment_date_gmt>2011-07-07 13:43:06</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[We might rather wonder why and how more lines of code leads to various complexity signals.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1310046186.9589";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>87</wp:comment_id>
			<wp:comment_author><![CDATA[Neil Ernst]]></wp:comment_author>
			<wp:comment_author_email>neil@neilernst.net</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>128.100.3.161</wp:comment_author_IP>
			<wp:comment_date>2011-08-17 08:44:59</wp:comment_date>
			<wp:comment_date_gmt>2011-08-17 15:44:59</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[@David, one good LOC tool is SLOCcount: http://www.dwheeler.com/sloccount/]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1313595899.5439";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>86</wp:comment_id>
			<wp:comment_author><![CDATA[David Bamber]]></wp:comment_author>
			<wp:comment_author_email>dbamber@gmail.com</wp:comment_author_email>
			<wp:comment_author_url>http://bmbr.co</wp:comment_author_url>
			<wp:comment_author_IP>194.48.204.3</wp:comment_author_IP>
			<wp:comment_date>2011-08-17 05:20:23</wp:comment_date>
			<wp:comment_date_gmt>2011-08-17 12:20:23</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[I am a software developer and have never been involved in a team which has used measurement techniques.

I am convinced that a team employing a 'maximum lines of code per method' approach would develop good maintainable code.

Can anyone recommend any open source/free software tools to provide these measurements.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1313583623.1242";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>5784</wp:comment_id>
			<wp:comment_author><![CDATA[Experimental Assessment of Software Metrics Using Automated Refactoring - It Will Never Work in Theory]]></wp:comment_author>
			<wp:comment_author_email></wp:comment_author_email>
			<wp:comment_author_url>http://www.neverworkintheory.org/?p=488</wp:comment_author_url>
			<wp:comment_author_IP>64.90.54.151</wp:comment_author_IP>
			<wp:comment_date>2013-02-12 09:33:17</wp:comment_date>
			<wp:comment_date_gmt>2013-02-12 17:33:17</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[[...] impact and applicability of software metrics continues to be a subject of debate, especially since there are many metrics that measure similar properties, like cohesion. This [...]]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type>pingback</wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";d:1360690397.9588680267333984375;s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
		<title>Webinars on the Architecture of Open Source Applications July 13 and 20</title>
		<link>http://www.neverworkintheory.org/?p=61</link>
		<pubDate>Mon, 11 Jul 2011 13:42:40 +0000</pubDate>
		<dc:creator>gvwilson</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=61</guid>
		<description></description>
		<content:encoded><![CDATA[Smart Bear Software is hosting two online panel discussions about <a href="http://aosabook.org"><em>The Architecture of Open Source Applications</em></a>, at 1:00 pm EST on Wednesday, July 13, and again at the same time (with different panelists) a week later. You can sign up <a href="http://www2.smartbear.com/OpenSource_webinar.html">on their site</a>; we look forward to seeing/hearing from lots of you.]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>61</wp:post_id>
		<wp:post_date>2011-07-11 06:42:40</wp:post_date>
		<wp:post_date_gmt>2011-07-11 13:42:40</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>webinars-on-the-architecture-of-open-source-applications-july-13-and-20</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="announcements"><![CDATA[Announcements]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>31</wp:comment_id>
			<wp:comment_author><![CDATA[Adrian Schroeter]]></wp:comment_author>
			<wp:comment_author_email>adrian.schroeter@googlemail.com</wp:comment_author_email>
			<wp:comment_author_url>http://adrian-schroeter.com</wp:comment_author_url>
			<wp:comment_author_IP>142.104.21.213</wp:comment_author_IP>
			<wp:comment_date>2011-07-11 14:11:44</wp:comment_date>
			<wp:comment_date_gmt>2011-07-11 21:11:44</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[is there a way to record and share the recording of the webinars?]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1310418704.7872";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
		<title>The social dynamics of pair programming</title>
		<link>http://www.neverworkintheory.org/?p=64</link>
		<pubDate>Mon, 11 Jul 2011 22:05:53 +0000</pubDate>
		<dc:creator>jorge</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=64</guid>
		<description></description>
		<content:encoded><![CDATA[<em>Jan Chong and Tom Hurlbutt, "<strong><a href="http://www.google.com/url?sa=t&amp;source=web&amp;cd=1&amp;ved=0CB0QFjAA&amp;url=http%3A%2F%2Fciteseerx.ist.psu.edu%2Fviewdoc%2Fdownload%3Fdoi%3D10.1.1.87.1533%26rep%3Drep1%26type%3Dpdf&amp;rct=j&amp;q=the%20social%20dynamics%20of%20pair%20programming&amp;ei=a24bTtHQOKnUiAKO4NDSBQ&amp;usg=AFQjCNELrxgJ2ufweGy570BFktmXYU4Cew&amp;sig2=dUBk-znGe2jTobTgsQ4UCg&amp;cad=rja">The Social Dynamics of Pair Programming</a></strong>". ICSE 2007.</em>
<blockquote><em>This paper presents data from a four month ethnographic study of professional pair programmers from two software development teams. Contrary to the current conception of pair programmers, the pairs in this study did not hew to the separate roles of “driver ” and “navigator”. Instead, the observed programmers moved together through different phases of the task, considering and discussing issues at the same strategic “range” or level of abstraction and in largely the same role. This form of interaction was reinforced by frequent switches in keyboard control during pairing and the use of dual keyboards. The distribution of expertise among the members of a pair had a strong influence on the tenor of pair programming interaction. Keyboard control had a consistent secondary effect on decision-making within the pair. These findings have implications for software development managers and practitioners as well as for the design of software development tools.</em></blockquote>
The myth of the driver/navigator split in pair programming is very pervasive: I've found it in almost all descriptions of pair programming I've seen, and in the language that programming pairs use to refer to the work that they do. However, Chong and Hurlbutt report that, effectively, programming pairs perform the same mixed role throughout their collaboration. They also have some interesting observations on the effect of keyboard control and expertise differentials within the pair.

Their suggested implications for pair programming (discussed in Section 6):
<ul>
	<li><strong>Move beyond the "driver" and the "navigator".</strong> This artificial role distinction only muddles the learning process of a new practice.</li>
	<li><strong>Help programmers stay focused and engaged.</strong> The authors suggest this can be achieved with good hardware support (hardware that supports, for instance, fast keyboard switching between pairs).</li>
	<li><strong>Consider differentials in programmer knowledge.</strong> Too great a difference is not productive.</li>
	<li><strong>Avoid pair rotation late in a task.</strong> Re-pair based on task completion, not on day cycles.</li>
</ul>
The latter two suggestions seem commonplace in the firms that I've observed that do some pair programming, but I've found that the former two still need wider dissemination. What is your experience?]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>64</wp:post_id>
		<wp:post_date>2011-07-11 15:05:53</wp:post_date>
		<wp:post_date_gmt>2011-07-11 22:05:53</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>the-social-dynamics-of-pair-programming</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="pair-programming"><![CDATA[Pair Programming]]></category>
		<category domain="category" nicename="qualitative-studies"><![CDATA[Qualitative Studies]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>32</wp:comment_id>
			<wp:comment_author><![CDATA[Cliff McCollum]]></wp:comment_author>
			<wp:comment_author_email>cliffmcc@gmail.com</wp:comment_author_email>
			<wp:comment_author_url>http://leadingsoftware.ca</wp:comment_author_url>
			<wp:comment_author_IP>64.251.77.193</wp:comment_author_IP>
			<wp:comment_date>2011-07-11 15:12:29</wp:comment_date>
			<wp:comment_date_gmt>2011-07-11 22:12:29</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[In my personal experience with pair-programming, I'd agree with all four of these suggestions. I've never seen programmers actually adhere to the "driver" and "navigator" roles. More often the two roles seem to be "keyboard-jockey" and "finger-pointer", which have nothing to do with process and everything to do with the limitations of desks and operating systems. Given that some tools, like IntelliJ IDEA, allow developers to work on the same code at the same time, I'd love to see a study of pair-programming where everyone had these low-friction collaboration tools.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1310422350.0362";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>33</wp:comment_id>
			<wp:comment_author><![CDATA[Laurent Bossavit]]></wp:comment_author>
			<wp:comment_author_email>laurent.ice@bossavit.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>81.64.220.205</wp:comment_author_IP>
			<wp:comment_date>2011-07-12 01:04:55</wp:comment_date>
			<wp:comment_date_gmt>2011-07-12 08:04:55</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[While I agree with the conclusion, it seems an unwarranted leap from a single study's observations to calling the driver/navigator split a "myth".

The point of an ethnographic study is that it will reveal a richer picture of a phenomenon than you could get from reading a dry, abstract description. However the key question raised by any such study is how well it generalizes to other situations. Two teams might not be enough of a sample for the conclusion that *no* experienced pair programming team *ever* shows a driver/navigator split - you'd need more citations at least.

This type of study should ideally result in generating new hypotheses about the phenomenon, which can then be tested in such a way that the conclusions will be more general.

On this topic I have a particular fondness for Sallyann Bryant's studies. For instance: http://portal.acm.org/citation.cfm?id=1380285 on "Pair programming and the mysterious role of the navigator". This also comes to similar conclusions on the navigator role, but for me the most important takeaway is this: "a key factor in the success of pair programming may be the associated increase in talk at an intermediate level of abstraction".

This captures the essence of pairing as far as I'm concerned - it is a discipline of "programming out loud".]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1310457895.9265";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>35</wp:comment_id>
			<wp:comment_author><![CDATA[Jorge Aranda]]></wp:comment_author>
			<wp:comment_author_email>jorge@neverworkintheory.org</wp:comment_author_email>
			<wp:comment_author_url>http://www.neverworkintheory.org/</wp:comment_author_url>
			<wp:comment_author_IP>24.68.65.123</wp:comment_author_IP>
			<wp:comment_date>2011-07-12 08:52:16</wp:comment_date>
			<wp:comment_date_gmt>2011-07-12 15:52:16</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Bryant's observations are very good, too; thanks for pointing them out.

But I want to point out that while it may be overreaching to conclude that there is no driver/navigator split from a single study, this has nothing to do with the <em>kind</em> of study it is: you should be equally suspicious with a single survey, or experiment, or anything. In our case, what would be news right now would be a study that reports on pairs that consistently adhere to this driver/navigator split, and how do they manage to overcome the challenges to this dynamic that arise from the nature of pair programming.

You're right in that the strength of ethnographic studies is that they reveal a richer picture of a phenomenon. Ideally, as in the case of Chong and Hurlbutt's study, this richer picture helps <em>explain</em> the phenomenon. The authors point out several reasons for the difficulty of engaging in a driver/navigator dynamic: the pair's interactions, their shared context, and, in one team, hardware affordances (keyboard switching).]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>33</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1310485936.9018";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:5:"jorge";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>36</wp:comment_id>
			<wp:comment_author><![CDATA[Karl Beecher]]></wp:comment_author>
			<wp:comment_author_email>k.s.beecher@googlemail.com</wp:comment_author_email>
			<wp:comment_author_url>http://computerfloss.com/blog</wp:comment_author_url>
			<wp:comment_author_IP>160.45.118.27</wp:comment_author_IP>
			<wp:comment_date>2011-07-14 04:54:14</wp:comment_date>
			<wp:comment_date_gmt>2011-07-14 11:54:14</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[I broadly agree. For me, the problem is that driver/navigator is too restrictive. There is a much broader range of possible behaviours which I would not have expected until I actually saw them (although I have seen pairs that do something very approximate to driver/observer most of the time).

In our research group we're studying a series of pair programmers (albeit *distributed* pair programmers) as part of an experiment now. The group has been doing it long before I joined them, but I've personally been surprised how varied and dynamic pair programmers can be; far richer patterns of behaviour than a simple driver/observer model consistently can account for.

Great site by the way!]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1310644454.6186";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>39</wp:comment_id>
			<wp:comment_author><![CDATA[Jorge Aranda]]></wp:comment_author>
			<wp:comment_author_email>jorge@neverworkintheory.org</wp:comment_author_email>
			<wp:comment_author_url>http://www.neverworkintheory.org/</wp:comment_author_url>
			<wp:comment_author_IP>24.68.65.123</wp:comment_author_IP>
			<wp:comment_date>2011-07-14 12:48:24</wp:comment_date>
			<wp:comment_date_gmt>2011-07-14 19:48:24</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Ah, I see you're working on Saros! I'm looking forward to reading what you guys find out---I was very amused by Lutz Prechelt's description of your quest for participants, in the CHASE workshop proceedings.

Thanks for your comments.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>36</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1310672904.5974";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:5:"jorge";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>6393</wp:comment_id>
			<wp:comment_author><![CDATA[Jorge Aranda]]></wp:comment_author>
			<wp:comment_author_email>jorge@neverworkintheory.org</wp:comment_author_email>
			<wp:comment_author_url>http://www.neverworkintheory.org/</wp:comment_author_url>
			<wp:comment_author_IP>96.50.29.161</wp:comment_author_IP>
			<wp:comment_date>2013-05-09 08:17:07</wp:comment_date>
			<wp:comment_date_gmt>2013-05-09 15:17:07</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Thanks for chipping in, Sallyann. I'm very curious about distributed pair programming too---and skeptical on its effectiveness.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>6392</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";d:1368112627.57398700714111328125;s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:5:"jorge";}]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>6392</wp:comment_id>
			<wp:comment_author><![CDATA[Sallyann freudenberg]]></wp:comment_author>
			<wp:comment_author_email>Sallyann.freudenberg@gmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>109.155.117.46</wp:comment_author_IP>
			<wp:comment_date>2013-05-09 08:01:20</wp:comment_date>
			<wp:comment_date_gmt>2013-05-09 15:01:20</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[I was previously Sallyann Bryant. My studies were across 4 different companies, some of which I studied several teams. In all I analysed 15,000 sentences of pair programmer dialogue. They were all collocated. I would be fascinated to see how the roles are similar and different in distributed pairs !]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";d:1368111681.4210159778594970703125;s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
		<title>Bibliography</title>
		<link>http://www.neverworkintheory.org/?page_id=69</link>
		<pubDate>Sun, 17 Jul 2011 13:26:04 +0000</pubDate>
		<dc:creator>gvwilson</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?page_id=69</guid>
		<description></description>
		<content:encoded><![CDATA[<ul>
<li id="ameller12">David Ameller, Claudia Ayala, Jordi Cabot, and Xavier Franch. <a href="http://www.neverworkintheory.org/?p=439">How do software architects
  consider non-functional requirements: An exploratory study</a>. In <cite>20th IEEE International Requirements Engineering Conference (RE'12)</cite>, Chicago, IL, September 2012.</li>
	<li id="anda2009">Bente C.D. Anda, Dag I.K. Sjøberg, and Audris Mockus. <a href="http://www.neverworkintheory.org/?p=159">Variability and reproducibility in software engineering: A study of four companies that developed the same system</a>. <cite>IEEE Transactions on Software Engineering</cite>, 35(3), May-June 2009. (<a href="http://dx.doi.org/10.1109/TSE.2008.89">doi:10.1109/TSE.2008.89</a>)</li>
	<li id="appel2011">Sven Appel, Jörg Liebeg, Benjamin Brandl, Christian Lengauer, and Christian Kästner. <a href="http://www.neverworkintheory.org/?p=188">Semistructured merge: Rethinking merge in revision control systems</a>. In <cite>19th ACM SIGSOFT Symposium and the 13th European Conference on the Foundations of Software Engineering (ESCE'11)</cite>, 2011. (<a href="http://dx.doi.org/10.1145/2025113.2025141">doi:10.1145/2025113.2025141</a>)</li>
	<li id="barnett2011">Mike Barnett, Manuel Fähndrich, K. Rustan M. Leino, Peter Müller, Wolfram Schulte, and Herman Venter. <a href="http://www.neverworkintheory.org/?p=47">Specification and verification: The Spec# experience</a>. <cite>Communications of the ACM</cite>, 54, June 2011. (<a href="http://dx.doi.org/10.1145/1953122.1953145">doi:10.1145/1953122.1953145</a>)</li>
	<li id="barr2012">Earl T. Barr, Christian Bird, Peter C. Rigby, Abram Hindle, Daniel M. German, and Premkumar Devanbu. <a href="http://www.neverworkintheory.org/?p=327">Cohesive and isolated development with branches</a>. In <cite>15th International Conference on Fundamental Approaches to Software Engineering (FASE'12)</cite>, March 2012.</li>
	<li id="barzilay2012">Ohad Barzilay. <a href="http://www.neverworkintheory.org/?p=315">Example embedding</a>. In <cite>10th SIGPLAN Symposium on New Ideas, New Paradigms, and Reflections on Programming and Software (Onward'11)</cite>, ONWARD '11, pages 137–144, New York, NY, USA, 2011. ACM. (<a href="http://dx.doi.org/10.1145/2089131.2089135">doi:10.1145/2089131.2089135</a>)</li>
	<li id="beck2011">Fabian Beck and Stephan Diehl. <a href="http://www.neverworkintheory.org/?p=185">On the congruence of modularity and code coupling</a>. In <cite>19th ACM SIGSOFT Symposium and the 13th European Conference on the Foundations of Software Engineering (ESCE'11)</cite>, 2011. (<a href="http://dx.doi.org/10.1145/2025113.2025162">doi:10.1145/2025113.2025162</a>)</li>
	<li id="benari2011">Mordechai Ben-Ari, Roman Bednarik, Ronit Ben-Bassat Levy, Gil Ebel, Andrés Moreno, Niko Myller, and Erkki Sutinen. <a href="http://www.neverworkintheory.org/?p=239">A decade of research and development on program animation: The Jeliot experience</a>. <cite>Journal of Visual Languages &amp; Computing</cite>, 22(5):375–384, 2011. (<a href="http://dx.doi.org/10.1016/j.jvlc.2011.04.004">doi:10.1016/j.jvlc.2011.04.004</a>)</li>
	<li id="bettenburg2008">Nicolas Bettenburg, Sascha Just, Adrian Schröter, Cathrin Weiss, Rahul Premraj, and Thomas Zimmermann. <a href="http://www.neverworkintheory.org/?p=131">What makes a good bug report?</a>. In <cite>16th ACM SIGSOFT International Symposium on Foundations of Software Engineering (FSE'08)</cite>, 2008. (<a href="http://dx.doi.org/10.1145/1453101.1453146">doi:10.1145/1453101.1453146</a>)</li>
	<li id="bird2011">Christian Bird, Nachiappan Nagappan, Brendan Murphy, Harald Gall, and Premkumar Devanbu. <a href="http://www.neverworkintheory.org/?p=142">Don't touch my code! examining the effects of ownership on software quality</a>. In <cite>19th ACM SIGSOFT Symposium and the 13th European Conference on the Foundations of Software Engineering (ESCE'11)</cite>, 2011. (<a href="http://dx.doi.org/10.1145/2025113.2025119">doi:10.1145/2025113.2025119</a>)</li>
	<li id="bluedorn1999">Allen C. Bluedorn, Daniel B. Turban, and Mary Sue Love. <a href="http://www.neverworkintheory.org/?p=254">The effects of stand-up and sit-down meeting formats on meeting outcomes</a>. <cite>Journal of Applied Psychology</cite>, 84(2), 1999. (<a href="http://dx.doi.org/10.1037/0021-9010.84.2.277">doi:10.1037/0021-9010.84.2.277</a>)</li>
	<li id="brun2011">Yuriy Brun, Reid Holmes, Michael D. Ernst, and David Notkin. <a href="http://www.neverworkintheory.org/?p=152">Proactive detection of collaboration conflicts</a>. In <cite>19th ACM SIGSOFT Symposium and the 13th European Conference on the Foundations of Software Engineering (ESCE'11)</cite>, 2011. (<a href="http://dx.doi.org/10.1145/2025113.2025139">doi:10.1145/2025113.2025139</a>)</li>
	<li id="cherubini2007">Mauro Cherubini, Gina Venolia, Rob DeLine, and Andrew J. Ko. <a href="http://www.neverworkintheory.org/?p=40">Let's go to the whiteboard: How and why software developers use drawings</a>. In <cite>2007 SIGCHI Conference on Human Factors in Computing Systems (CHI'07)</cite>, 2007. (<a href="http://dx.doi.org/10.1145/1240624.1240714">doi:10.1145/1240624.1240714</a>)</li>
	<li id="chong2007">Jan Chong and Tom Hurlbut. <a href="http://www.neverworkintheory.org/?p=64">The social dynamics of pair programming</a>. In <cite>29th international Conference on Software Engineering (ICSE'07)</cite>, 2007. (<a href="http://dx.doi.org/10.1109/ICSE.2007.87">doi:10.1109/ICSE.2007.87</a>)</li>
	<li id="cruzlemus2009">José A. Cruz-Lemus, Marcela Genero, M. Esperanza Manso, Sandro Morasca, and Mario Piattini. <a href="http://www.neverworkintheory.org/?p=108">Assessing the understandability of UML statechart diagrams with composite states: A family of empirical studies</a>. <cite>Empirical Software Engineering</cite>, 14:685–719, 2009. (<a href="http://dx.doi.org/10.1007/s10664-009-9106-z">doi:10.1007/s10664-009-9106-z</a>)</li>
	<li id="dabbish2012">Laura Dabbish, Colleen Stuart, Jason Tsay, and Jim Herbsleb. <a href="http://www.neverworkintheory.org/?p=286">Social coding in github: Transparency and collaboration in an open software repository</a>. In <cite>The 2012 ACM Conference on Computer Supported Cooperative Work (CSCW'12)</cite>, 2012. (<a href="http://dx.doi.org/10.1145/2145204.2145396">doi:10.1145/2145204.2145396</a>)</li>
	<li id="dagenais2010">Barthélémy Dagenais and Martin P. Robillard. <a href="http://www.neverworkintheory.org/?p=115">Creating and evolving developer documentation: Understanding the decisions of open source contributors</a>. In <cite>18th ACM SIGSOFT international symposium on Foundations of Software engineering (FSE'10)</cite>, 2010. (<a href="http://dx.doi.org/10.1145/1882291.1882312">doi:10.1145/1882291.1882312</a>)</li>
	<li id="dzidek2008">Wojciech J. Dzidek, Erik Arisholm, and Lionel C. Briand. <a href="http://www.neverworkintheory.org/?p=108">A realistic empirical evaluation of the costs and benefits of UML in software maintenance</a>. <cite>IEEE Transactions on Software Engineering</cite>, 34(3), May-June 2008. (<a href="http://dx.doi.org/10.1109/TSE.2008.15">doi:10.1109/TSE.2008.15</a>)</li>
	<li id="elemam2001">Khaled El Emam, Saida Benlarbi, Nishith Goel, and Shesh N. Rai. <a href="http://www.neverworkintheory.org/?p=58">The confounding effect of class size on the validity of object-oriented metrics</a>. <cite>IEEE Transactions on Software Engineering</cite>, 27(7), July 2001. (<a href="http://dx.doi.org/10.1109/32.935855">doi:10.1109/32.935855</a>)</li>
	<li id="giger2001">Emanuel Giger, Martin Pinzger, and Harald Gall. <a href="http://www.neverworkintheory.org/?p=185">Using the Gini coefficient for bug prediction in Eclipse</a>. In <cite>12th International Workshop on Principles of Software Evolution and the 7th Annual ERCIM Workshop on Software Evolution</cite>, 2011. (<a href="http://dx.doi.org/10.1145/2024445.2024455">doi:10.1145/2024445.2024455</a>)</li>
	<li id="hanenberg2010">Stefan Hanenberg. <a href="http://www.neverworkintheory.org/?p=432">An experiment about static and dynamic type systems: doubts about the positive impact of static type systems on development time</a>. In <cite>International Conference on Object Oriented Programming Systems, Languages and Applications (OOPSLA'10)</cite>, 2010. (<a href="http://dx.doi.org/10.1145/1932682.1869462">doi:10.1145/1932682.1869462</a>)</li>
	<li id="hannay2011">Jo E. Hannay, Erik Arisholm, Harald Engvik, and Dag I. K. Sjøberg. <a href="http://www.neverworkintheory.org/?p=83">Effects of personality on pair programming</a>. <cite>IEEE Transactions on Software Engineering</cite>, 36(1), January-February 2011. (<a href="http://dx.doi.org/10.1109/TSE.2009.41">doi:10.1109/TSE.2009.41</a>)</li>
	<li id="hindle2012">Abram Hindle, Earl Barr, Zhendong Su, Prem Devanbu, and Mark Gabel. <a href="http://www.neverworkintheory.org/?p=308">On the naturalness of software</a>. In <cite>34th International Conference on Software Engineering (ICSE'12)</cite>, 2012.</li>
	<li id="hundhausen2011">Christopher Hundhausen, Pawan Agarwal, and Michael Trevisan. <a href="http://www.neverworkintheory.org/?p=233">Online vs. face-to-face pedagogical code reviews: An empirical comparison</a>. In <cite>42nd ACM Technical Symposium on Computer Science Education (SIGCSE'11)</cite>, 2011. (<a href="http://dx.doi.org/10.1145/1953163.1953201">doi:10.1145/1953163.1953201</a>)</li>
	<li id="jermann2012">Patrick Jermann and Marc-Antoine Nussli. <a href="http://www.neverworkintheory.org/?p=281">Effects of sharing text selections on gaze recurrence and interaction quality in a pair programming task</a>. In <cite>The 2012 ACM Conference on Computer Supported Cooperative Work (CSCW'12)</cite>, 2012. (<a href="http://dx.doi.org/10.1145/2024445.2024455">doi:10.1145/2024445.2024455</a>)</li>
	<li id="jorgensen2012">Magne Jörgensen and Stein Grimstad. <a href="http://www.neverworkintheory.org/?p=359">Software development estimation biases: the role of interdependence</a>. <cite>IEEE Transactions on Software Engineering</cite>, 38(3), 2012. (<a href="http://dx.doi.org/10.1109/TSE.2011.40">doi:10.1109/TSE.2011.40</a>)</li>
	<li id="kapser2008">Cory J. Kapser and Michael W. Godfrey. <a href="http://www.neverworkintheory.org/?p=102">'cloning considered harmful' considered harmful</a>. In <cite>13th Working Conference on Reverse Engineering (WCRE'06)</cite>, 2006. (<a href="http://dx.doi.org/10.1145/2145204.2145371">doi:10.1145/2145204.2145371</a>)</li>
	<li id="khomh2012">Foutse Khomh, Tejinder Dhaliwal, Ying Zou, and Bram Adams. <a href="http://www.neverworkintheory.org/?p=341">Do faster releases improve software quality? an empirical case study of mozilla firefox</a>. In <cite>9th IEEE Working Conference on Mining Software Repositories (MSR'12)</cite>, June 2012.</li>
	<li id="kinshumann2011">Kinshuman Kinshumann, Kirk Glerum, Steve Greenberg, Gabriel Aul, Vince Orgovan, Greg Nichols, David Grant, Gretchen Loihle, and Galen Hunt. <a href="http://www.neverworkintheory.org/?p=76">Debugging in the (very) large: Ten years of implementation and experience</a>. <cite>Communications of the ACM</cite>, 54(7), July 2011. (<a href="http://dx.doi.org/10.1145/1965724.1965749">doi:10.1145/1965724.1965749</a>)</li>
	<li id="kocaguneli2011">Ekrem Kocaguneli, Tim Menzies, and Jacky Keung. <a href="http://www.neverworkintheory.org/?p=301">On the value of ensemble effort estimation</a>. <cite>IEEE Transactions on Software Engineering</cite>, 2011. (<a href="http://dx.doi.org/10.1109/TSE.2011.111">doi:10.1109/TSE.2011.111</a>)</li>
	<li id="delucia2010">Andrea De Lucia, Carmine Gravino, Rocco Oliveto, and Genoveffa Tortora. <a href="http://www.neverworkintheory.org/?p=108">An experimental comparison of ER and UML class diagrams for data modelling</a>. <cite>Empirical Software Engineering</cite>, 15:455–492, 2010. (<a href="http://dx.doi.org/10.1007/s10664-009-9127-7">doi:10.1007/s10664-009-9127-7</a>)</li>
	<li id="marinescu2011">Cristina Marinescu. <a href="http://www.neverworkintheory.org/?p=185">Are the classes that use exceptions defect prone?</a>. In <cite>12th International Workshop on Principles of Software Evolution and the 7th Annual ERCIM Workshop on Software Evolution</cite>, 2011. (<a href="http://dx.doi.org/10.1145/2024445.2024456">doi:10.1145/2024445.2024456</a>)</li>
	<li id="mcintosh2011">Shane McIntosh, Bram Adams, Thanh H. D. Nguyen, Yasutaka Kamei, and Ahmed E. Hassan. <a href="http://www.neverworkintheory.org/?p=97">An empirical study of build maintenance effort</a>. In <cite>33rd International Conference on Software Engineering (ICSE'11)</cite>, 2011. (<a href="http://dx.doi.org/10.1145/1985793.1985813">doi:10.1145/1985793.1985813</a>)</li>
	<li id="mcleod2011">Laurie McLeod and Stephen G. MacDonell. <a href="http://www.neverworkintheory.org/?p=248">Factors that affect software systems development project outcomes: A survey of research</a>. <cite>ACM Computing Surveys</cite>, 43, October 2011. (<a href="http://dx.doi.org/10.1145/1978802.1978803">doi:10.1145/1978802.1978803</a>)</li>
	<li id="meneely2011">Andrew Meneely, Pete Rotella, and Laurie Williams. <a href="http://www.neverworkintheory.org/?p=146">Does adding manpower also affect quality? an empirical, longitudinal analysis</a>. In <cite>19th ACM SIGSOFT Symposium and the 13th European Conference on the Foundations of Software Engineering (ESCE'11)</cite>, 2011. (<a href="http://dx.doi.org/10.1145/2025113.2025128">doi:10.1145/2025113.2025128</a>)</li>
	<li id="mockus2010">Audris Mockus. <a href="http://www.neverworkintheory.org/?p=17">Organizational volatility and its effects on software</a>. In <cite>18th ACM SIGSOFT international symposium on Foundations of Software engineering (FSE'10)</cite>, 2010. (<a href="http://dx.doi.org/10.1145/1882291.1882311">doi:10.1145/1882291.1882311</a>)</li>
	<li id="moe2010">Nils Brede Moe, Torgeir Dingsøyr, and Tore Dybå. <a href="http://www.neverworkintheory.org/?p=87">A teamwork model for understanding an agile team: A case study of a Scrum project</a>. <cite>Information and Software Technology</cite>, 52(5), May 2010. (<a href="http://dx.doi.org/10.1016/j.infsof.2009.11.004">doi:10.1016/j.infsof.2009.11.004</a>)</li>
	<li id="nagappan2008">Nachiappan Nagappan, E. Michael Maximilien, Thirumalesh Bhat, and Laurie Wiliams. <a href="http://www.neverworkintheory.org/?p=271">Realizing quality improvement through test driven development: results and experiences of four industrial teams</a>. <cite>Empirical Software Engineering</cite>, 13:289–302, 2008. (<a href="http://dx.doi.org/10.1007/s10664-008-9062-z">doi:10.1007/s10664-008-9062-z</a>)</li>
	<li id="pankratius2012">Victor Pankratius, Felix Schmidt, and Gilda Garretón. <a href="http://www.neverworkintheory.org/?p=375">Combining functional and imperative programming for multicore software: An empirical study evaluating scala and java</a>. In <cite>34th International Conference on Software Engineering (ICSE'12)</cite>, 2012.</li>
	<li id="parnin2012">Chris Parnin, Christoph Treude, Lars Grammel, and Margaret-Anne Storey. <a href="http://www.neverworkintheory.org/?p=357">Crowd documentation: Exploring the coverage and the dynamics of api discussions on stack overflow</a>. <cite>Georgia Tech Technical Report</cite>, 2012.</li>
	<li id="posnett2011">Daryl Posnett, Abram Hindle, and Prem Devanbu. <a href="http://www.neverworkintheory.org/?p=262">Got issues? do new features and code improvements affect defects?</a>. In <cite>18th Working Conference on Reverse Engineering (WCRE'11)</cite>, 2011. (<a href="http://dx.doi.org/10.1109/WCRE.2011.33">doi:10.1109/WCRE.2011.33</a>)</li>
	<li id="prabhu2011">Prakash Prabhu, Thomas B. Jablin, Arun Raman, Yun Zhang, Jialu Huang, Hanjun Kim, Nick P. Johnson, Feng Liu, Soumyadeep Ghosh, Stephen Beard, Taewook Oh, Matthew Zoufaly, David Walker, and David I. August. <a href="http://liberty.princeton.edu/Publications/sc11_survey.pdf">A survey of the practice of computational science</a>. In <cite>International Conference for High Performance Computing, Networking, Storage and Analysis (SC'11)</cite>, pages 19:1–19:12, 2011. (<a href="http://dx.doi.org/10.1145/2063348.2063374">doi:10.1145/2063348.2063374</a>)</li>
	<li id="racheva2010">Zornitza Racheva, Maya Daneva, Andrea Herrmann, Klaus Sikkel, and Roel Wieringa. <a href="http://www.neverworkintheory.org/?p=54">Do we know enough about requirements prioritization in agile projects: Insights from a case study</a>. In <cite>18th IEEE International Requirements Engineering Conference (RE'10)</cite>, 2010. (<a href="http://dx.doi.org/10.1109/RE.2010.27">doi:10.1109/RE.2010.27</a>)</li>
	<li id="rahman2011">Foyzur Rahman and Premkumar Devanbu. <a href="http://www.neverworkintheory.org/?p=9">Ownership, experience and defects: A fine-grained study of authorship</a>. In <cite>33rd International Conference on Software Engineering (ICSE'11)</cite>, 2011. (<a href="http://dx.doi.org/10.1145/1985793.1985860">doi:10.1145/1985793.1985860</a>)</li>
	<li id="rigby2011">Peter C. Rigby and Margaret-Anne Storey. <a href="http://www.neverworkintheory.org/?p=72">Understanding broadcast based peer review on open source projects</a>. In <cite>33rd International Conference on Software Engineering (ICSE'11)</cite>, 2011. (<a href="http://dx.doi.org/10.1145/1985793.1985867">doi:10.1145/1985793.1985867</a>)</li>
	<li id="robillard2011">Martin P. Robillard and Rob DeLine. <a href="http://www.neverworkintheory.org/?p=220">A field study of API learning obstacles</a>. <cite>Empirical Software Engineering</cite>, 16(6), December 2011. (<a href="http://dx.doi.org/10.1007/s10664-010-9150-8">doi:10.1007/s10664-010-9150-8</a>)</li>
	<li id="rossbach2010">Christopher J. Rossbach, Owen S. Hofmann, and Emmett Witchel. <a href="http://www.neverworkintheory.org/?p=122">Is transactional programming actually easier?</a>. In <cite>15th ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming (PPoPP'10)</cite>, 2010. (<a href="http://dx.doi.org/10.1145/1837853.1693462">doi:10.1145/1837853.1693462</a>)</li>
	<li id="sim2012">Susan Elliott Sim, Rosalva Gallardo-Valencia, Kavita Philip, Medha Umarji, Megha Agarwala, Cristina V. Lopes, and Sukanya Ratanotayanon. <a href="http://www.neverworkintheory.org/?p=294">Software reuse through methodical component reuse and amethodical snippet remixing</a>. In <cite>The 2012 ACM Conference on Computer Supported Cooperative Work (CSCW'12)</cite>, 2012. (<a href="http://dx.doi.org/10.1145/2145204.2145407">doi:10.1145/2145204.2145407</a>)</li>
	<li id="stefik2011">Andreas Stefik, Susanna Siebert, Melissa Stefik, and Kim Slattery. <a href="http://www.neverworkintheory.org/?p=197">An empirical comparison of the accuracy rates of novices using the Quorum, Perl, and Randomo programming languages</a>. In <cite>Workshop on Evaluation and Usability of Programming Languages and Tools (PLATEAU'11)</cite>, 2011.</li>
	<li id="stolee2011">Kathryn Stolee and Sebastian Elbaum. <a href="http://www.neverworkintheory.org/?p=13">Refactoring pipe-like mashups for end-user programmers</a>. In <cite>33rd International Conference on Software Engineering (ICSE'11)</cite>, 2011. (<a href="http://dx.doi.org/10.1145/1985793.1985805">doi:10.1145/1985793.1985805</a>)</li>
	<li id="stylos2007">Jeffrey Stylos and Steven Clarke. <a href="http://www.neverworkintheory.org/?p=91">Usability implications of requiring parameters in objects' constructors</a>. In <cite>29th international Conference on Software Engineering (ICSE'07)</cite>, 2007. (<a href="http://dx.doi.org/10.1109/ICSE.2007.92">doi:10.1109/ICSE.2007.92</a>)</li>
	<li id="tew2011">Allison Elliott Tew and Mark Guzdial. <a href="http://www.neverworkintheory.org/?p=230">The FCS1: A language independent assessment of CS1 knowledge</a>. In <cite>42nd ACM Technical Symposium on Computer Science Education (SIGCSE'11)</cite>, 2011. (<a href="http://dx.doi.org/10.1145/1953163.1953200">doi:10.1145/1953163.1953200</a>)</li>
	<li id="wicherts2011">Jelte M. Wicherts, Marjan Bakker, and Dylan Molenaar. <a href="http://www.neverworkintheory.org/?p=348">Willingness to share research data is related to the strength of the evidence and the quality of reporting of statistical results</a>. <cite>PLoS ONE</cite>, 6(11):e26828, 11 2011. (<a href="http://dx.doi.org/10.1371/journal.pone.0026828">doi:10.1371/journal.pone.0026828</a>)</li>
	<li id="wilkerson2011">Jerod W. Wilkerson, Jay F. Nunamaker, and Rick Mercer. <a href="http://www.neverworkintheory.org/?p=139">Comparing the defect reduction benefits of code inspection and test-driven development</a>. <cite>IEEE Transactions on Software Engineering</cite>, 2011.</li>
	<li id="yin2011">Zuoning Yin, Ding Yuan, Yuanyuan Zhou, Shankar Pasupathy, and Lakshmi Bairavasundaram. <a href="http://www.neverworkintheory.org/?p=188">How do fixes become bugs?</a>. In <cite>19th ACM SIGSOFT Symposium and the 13th European Conference on the Foundations of Software Engineering (ESCE'11)</cite>, 2011. (<a href="http://dx.doi.org/10.1145/2025113.2025121">doi:10.1145/2025113.2025121</a>)</li>
</ul>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>69</wp:post_id>
		<wp:post_date>2011-07-17 06:26:04</wp:post_date>
		<wp:post_date_gmt>2011-07-17 13:26:04</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>bibliography</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>10</wp:menu_order>
		<wp:post_type>page</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[3]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wp_page_template</wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>100</wp:comment_id>
			<wp:comment_author><![CDATA[Over at &#8220;Never Work in Theory&#8221;&#8230; | Catenary]]></wp:comment_author>
			<wp:comment_author_email></wp:comment_author_email>
			<wp:comment_author_url>http://catenary.wordpress.com/2011/08/24/over-at-never-work-in-theory/</wp:comment_author_url>
			<wp:comment_author_IP>72.233.2.2</wp:comment_author_IP>
			<wp:comment_date>2011-08-24 15:36:05</wp:comment_date>
			<wp:comment_date_gmt>2011-08-24 22:36:05</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[[...] a reminder&#8212;over at the Never Work in Theory blog, we&#8217;ve already got about a couple dozen papers with empirical findings that (we think) are relevant for software practice. They&#8217;re beginning [...]]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type>pingback</wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:14:"1314225365.814";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
		<title>Understanding Broadcast Based Peer Review on Open Source Projects</title>
		<link>http://www.neverworkintheory.org/?p=72</link>
		<pubDate>Mon, 18 Jul 2011 23:37:35 +0000</pubDate>
		<dc:creator>jorge</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=72</guid>
		<description></description>
		<content:encoded><![CDATA[<em><a href="http://helium.cs.uvic.ca/drupal/index.php">Peter C. Rigby</a> and <a href="http://webhome.cs.uvic.ca/~mstorey">Margaret-Anne Storey</a>, <strong><a href="http://helium.cs.uvic.ca/other/Rigby2011ICSE.pdf">"Understanding Broadcast Based Peer Review on Open Source Projects"</a></strong>. ICSE 2011.</em>
<blockquote>Software peer review has proven to be a successful technique in open source software (OSS) development. In contrast to industry, where reviews are typically assigned to speciﬁc individuals, changes are broadcast to hundreds of potentially interested stakeholders. Despite concerns that reviews may be ignored, or that discussions will deadlock because too many uninformed stakeholders are involved, we ﬁnd that this approach works well in practice. In this paper, we describe an empirical study to investigate the mechanisms and behaviours that developers use to ﬁnd code changes they are competent to review. We also explore how stakeholders interact with one another during the review process. We manually examine hundreds of reviews across ﬁve high proﬁle OSS projects. Our ﬁndings provide insights into the simple, community-wide techniques that developers use to eﬀectively manage large quantities of reviews. The themes that emerge from our study are enriched and validated by interviewing long-serving core developers.</blockquote>
Rigby and Storey's report won't surprise people steeped in the open source development culture, but everyone else may find it instructive. If you are used to assigning code reviews to some of your peers, to have other reviews assigned to you, and to only work on the items in your queue, the broadcast method of many open source projects (that is, broadcast your patch to the mailing list and hope it will be picked up, improved, and accepted by others) may seem entirely dysfunctional. Still, for the most part it works very well, and the authors explain how and why. If you don't have time for the full paper, the last section provides a good summary of its findings.

<em>(Full disclosure: I'm currently affiliated with Dr. Storey's lab.)</em>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>72</wp:post_id>
		<wp:post_date>2011-07-18 16:37:35</wp:post_date>
		<wp:post_date_gmt>2011-07-18 23:37:35</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>understanding-broadcast-based-peer-review-on-open-source-projects</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="code-review"><![CDATA[Code Review]]></category>
		<category domain="category" nicename="open-source"><![CDATA[Open Source]]></category>
		<category domain="category" nicename="qualitative-studies"><![CDATA[Qualitative Studies]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>45</wp:comment_id>
			<wp:comment_author><![CDATA[Cliff McCollum]]></wp:comment_author>
			<wp:comment_author_email>cliffmcc@gmail.com</wp:comment_author_email>
			<wp:comment_author_url>http://leadingsoftware.ca</wp:comment_author_url>
			<wp:comment_author_IP>64.251.77.193</wp:comment_author_IP>
			<wp:comment_date>2011-07-18 16:54:06</wp:comment_date>
			<wp:comment_date_gmt>2011-07-18 23:54:06</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Interesting summary. I didn't see anything in the paper about the critical mass of developers required for the broadcast method to work. Obviously with a team of two, broadcast == assignment. At some size, assignment could give way to effective broadcasting, but I'd be curious to know what that is. Even at a team size of five or six, I imagine that broadcast wouldn't be significantly different from assignment.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1311033246.7179";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>46</wp:comment_id>
			<wp:comment_author><![CDATA[Jorge Aranda]]></wp:comment_author>
			<wp:comment_author_email>jorge@neverworkintheory.org</wp:comment_author_email>
			<wp:comment_author_url>http://www.neverworkintheory.org/</wp:comment_author_url>
			<wp:comment_author_IP>142.104.21.214</wp:comment_author_IP>
			<wp:comment_date>2011-07-18 17:04:25</wp:comment_date>
			<wp:comment_date_gmt>2011-07-19 00:04:25</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[My understanding is that small projects are starving for contributors, so yes, broadcast would equal assignment to all core developers. Rigby and Storey's analysis is at several orders of magnitude greater than that; it'd be nice to have a similar report for projects just getting by with a few contributors.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>45</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1311033865.0661";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:5:"jorge";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
		<title>Debugging in the (Very) Large</title>
		<link>http://www.neverworkintheory.org/?p=76</link>
		<pubDate>Tue, 19 Jul 2011 01:27:51 +0000</pubDate>
		<dc:creator>gvwilson</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=76</guid>
		<description></description>
		<content:encoded><![CDATA[Kinshuman Kinshumann, Kirk Glerum, Steve Greenberg, Gabriel Aul, Vince Orgovan, Greg Nichols, David Grant, Gretchen Loihle, and Galen Hunt: <a href="http://cacm.acm.org/magazines/2011/7/109883-debugging-in-the-very-large/abstract">Debugging in the (Very) Large: Ten Years of Implementation and Experience</a>. <em>Communications of the ACM</em>, 54(7), July 2011.
<blockquote><em>Windows Error Reporting (WER) is a distributed system that automates the processing of error reports coming from an installed base of a billion machines. WER has collected billions of error reports in 10 years of operation. It collects error data automatically and classifies errors into buckets, which are used to prioritize developer effort and report fixes to users. WER uses a progressive approach to data collection, which minimizes overhead for most reports yet allows developers to collect detailed information when needed. WER takes advantage of its scale to use error statistics as a tool in debugging; this allows developers to isolate bugs that cannot be found at smaller scale. WER has been designed for efficient operation at large scale: one pair of database servers records all the errors that occur on all Windows computers worldwide.</em></blockquote>
Engineering is in part what we do when quantitative differences become qualitative differences—when the ten pounds that we can lift easily becomes twenty, then two hundred. This paper is a very readable overview of how Microsoft's error reporting team has handled such a change in scale. WER's carefully-tuned bucketing and aggregation helps developers pinpoint errors and prioritize their work, so that the things that will affect the most people get the most attention. The authors' discussion of how this works, and of the insights that such big data can provide, are a great example of how innovative practices can open up new areas of research.]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>76</wp:post_id>
		<wp:post_date>2011-07-18 18:27:51</wp:post_date>
		<wp:post_date_gmt>2011-07-19 01:27:51</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>debugging-in-the-very-large</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="experience-reports"><![CDATA[Experience Reports]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Guidelines</title>
		<link>http://www.neverworkintheory.org/?page_id=203</link>
		<pubDate>Wed, 26 Oct 2011 13:57:12 +0000</pubDate>
		<dc:creator>gvwilson</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?page_id=203</guid>
		<description></description>
		<content:encoded><![CDATA[We welcome critical discussion of the papers discussed here, and of our comments on them, but abusive language of any form will be removed. Please also ask yourself the following questions when posting:

<em>1. Would you express your opinion so strongly if the paper had come to the opposite conclusion?</em> For example, if it had found that doing X actually did improve code quality, or that Y <em>wasn't</em> better than Z, would you be as upset as you are?

<em>2. Are you criticizing the paper's actual claims?</em> If it says that P holds for novices who are learning how to program, there is no point saying, "But no experienced programmer would do that!" Similarly, if the paper compares examples found on the web that were created using tool F with equivalent examples created using the authors' new tool G, the fact that those examples aren't on the web is irrelevant.

<em>3. Are your criticisms of the paper's statistics numerical?</em> It's meaningless to say, "The paper's sample size is too small," without some quantification.

<em>4. Are you employing proof by rhetoric?</em> The statement, "It's obvious that J," is verbal bullying, not proof. And many "obvious" things aren't actually true: that's why we do studies.

Finally, we strongly prefer commenters to identify themselves, as it encourages civility and moderation. We are therefore much more likely to let strongly-worded comments stand if their authors are willing to stand behind their words, just as the authors of the papers we present are required to stand behind theirs.]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>203</wp:post_id>
		<wp:post_date>2011-10-26 06:57:12</wp:post_date>
		<wp:post_date_gmt>2011-10-26 13:57:12</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>closed</wp:ping_status>
		<wp:post_name>guidelines</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>20</wp:menu_order>
		<wp:post_type>page</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wp_page_template</wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title></title>
		<link>http://www.neverworkintheory.org/?p=392</link>
		<pubDate>Fri, 06 Jul 2012 03:50:51 +0000</pubDate>
		<dc:creator>jorge</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=392</guid>
		<description></description>
		<content:encoded><![CDATA[ ]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>392</wp:post_id>
		<wp:post_date>2012-07-05 20:50:51</wp:post_date>
		<wp:post_date_gmt>2012-07-06 03:50:51</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>392</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>1</wp:menu_order>
		<wp:post_type>nav_menu_item</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="nav_menu" nicename="main"><![CDATA[Main]]></category>
		<wp:postmeta>
			<wp:meta_key>_menu_item_type</wp:meta_key>
			<wp:meta_value><![CDATA[post_type]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_menu_item_parent</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_object_id</wp:meta_key>
			<wp:meta_value><![CDATA[203]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_object</wp:meta_key>
			<wp:meta_value><![CDATA[page]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_target</wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_classes</wp:meta_key>
			<wp:meta_value><![CDATA[a:1:{i:0;s:0:"";}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_xfn</wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_url</wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title></title>
		<link>http://www.neverworkintheory.org/?p=393</link>
		<pubDate>Fri, 06 Jul 2012 03:50:51 +0000</pubDate>
		<dc:creator>jorge</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=393</guid>
		<description></description>
		<content:encoded><![CDATA[ ]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>393</wp:post_id>
		<wp:post_date>2012-07-05 20:50:51</wp:post_date>
		<wp:post_date_gmt>2012-07-06 03:50:51</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>393</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>2</wp:menu_order>
		<wp:post_type>nav_menu_item</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="nav_menu" nicename="main"><![CDATA[Main]]></category>
		<wp:postmeta>
			<wp:meta_key>_menu_item_type</wp:meta_key>
			<wp:meta_value><![CDATA[post_type]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_menu_item_parent</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_object_id</wp:meta_key>
			<wp:meta_value><![CDATA[69]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_object</wp:meta_key>
			<wp:meta_value><![CDATA[page]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_target</wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_classes</wp:meta_key>
			<wp:meta_value><![CDATA[a:1:{i:0;s:0:"";}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_xfn</wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_url</wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title></title>
		<link>http://www.neverworkintheory.org/?p=394</link>
		<pubDate>Fri, 06 Jul 2012 03:50:52 +0000</pubDate>
		<dc:creator>jorge</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=394</guid>
		<description></description>
		<content:encoded><![CDATA[ ]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>394</wp:post_id>
		<wp:post_date>2012-07-05 20:50:52</wp:post_date>
		<wp:post_date_gmt>2012-07-06 03:50:52</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>394</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>3</wp:menu_order>
		<wp:post_type>nav_menu_item</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="nav_menu" nicename="main"><![CDATA[Main]]></category>
		<wp:postmeta>
			<wp:meta_key>_menu_item_type</wp:meta_key>
			<wp:meta_value><![CDATA[post_type]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_menu_item_parent</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_object_id</wp:meta_key>
			<wp:meta_value><![CDATA[31]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_object</wp:meta_key>
			<wp:meta_value><![CDATA[page]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_target</wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_classes</wp:meta_key>
			<wp:meta_value><![CDATA[a:1:{i:0;s:0:"";}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_xfn</wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_url</wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title></title>
		<link>http://www.neverworkintheory.org/?p=395</link>
		<pubDate>Fri, 06 Jul 2012 03:50:52 +0000</pubDate>
		<dc:creator>jorge</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=395</guid>
		<description></description>
		<content:encoded><![CDATA[ ]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>395</wp:post_id>
		<wp:post_date>2012-07-05 20:50:52</wp:post_date>
		<wp:post_date_gmt>2012-07-06 03:50:52</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>395</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>4</wp:menu_order>
		<wp:post_type>nav_menu_item</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="nav_menu" nicename="main"><![CDATA[Main]]></category>
		<wp:postmeta>
			<wp:meta_key>_menu_item_type</wp:meta_key>
			<wp:meta_value><![CDATA[post_type]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_menu_item_parent</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_object_id</wp:meta_key>
			<wp:meta_value><![CDATA[27]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_object</wp:meta_key>
			<wp:meta_value><![CDATA[page]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_target</wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_classes</wp:meta_key>
			<wp:meta_value><![CDATA[a:1:{i:0;s:0:"";}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_xfn</wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_url</wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Effects of Personality on Pair Programming</title>
		<link>http://www.neverworkintheory.org/?p=83</link>
		<pubDate>Tue, 26 Jul 2011 21:21:53 +0000</pubDate>
		<dc:creator>jorge</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=83</guid>
		<description></description>
		<content:encoded><![CDATA[<em><a href="http://simula.no/people/johannay">Jo E. Hannay</a>, <a href="http://simula.no/people/erika">Erik Arisholm</a>, Harald Engvik, and <a href="http://heim.ifi.uio.no/~dagsj/">Dag I. K. Sjøberg</a>. <strong><a href="http://simula.no/research/se/publications/Simula.SE.305/simula_pdf_file">Effects of Personality on Pair Programming</a>.</strong> TSE 36(1), 2010.</em>
<blockquote>Personality tests in various guises are commonly used in recruitment and career counseling industries. Such tests have also been considered as instruments for predicting the job performance of software professionals both individually and in teams. However, research suggests that other human-related factors such as motivation, general mental ability, expertise, and task complexity also affect the performance in general. This paper reports on a study of the impact of the Big Five personality traits on the performance of pair programmers together with the impact of expertise and task complexity. The study involved 196 software professionals in three countries forming 98 pairs. The analysis consisted of a confirmatory part and an exploratory part. The results show that: 1) Our data do not confirm a meta-analysis-based model of the impact of certain personality traits on performance and 2) personality traits, in general, have modest predictive value on pair programming performance compared with expertise, task complexity, and country. We conclude that more effort should be spent on investigating other performance-related predictors such as expertise, and task complexity, as well as other promising predictors, such as programming skill and learning. We also conclude that effort should be spent on elaborating on the effects of personality on various measures of collaboration, which, in turn, may be used to predict and influence performance. Insights into such malleable, rather than static, factors may then be used to improve pair programming performance.</blockquote>
The topic of personality often comes up in discussions of pair programming efficiency: whether you need to do an extravert to reap its benefits, whether the contrast in personality with your peer is important, and so on. Many research studies have addressed these questions; Hannay &amp; Co's is a good place to start reading about them. They report: "we found no strong indications that personality affects pair programming performance or pair gain in a consistent manner", and suggest that industry and research should "focus on other predictors of performance, including expertise and task complexity" instead, as these factors overshadow any personality effects.]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>83</wp:post_id>
		<wp:post_date>2011-07-26 14:21:53</wp:post_date>
		<wp:post_date_gmt>2011-07-26 21:21:53</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>effects-of-personality-on-pair-programming</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="controlled-experiments"><![CDATA[Controlled Experiments]]></category>
		<category domain="category" nicename="pair-programming"><![CDATA[Pair Programming]]></category>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>A teamwork model for understanding an agile team</title>
		<link>http://www.neverworkintheory.org/?p=87</link>
		<pubDate>Tue, 02 Aug 2011 16:00:54 +0000</pubDate>
		<dc:creator>jorge</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=87</guid>
		<description></description>
		<content:encoded><![CDATA[<em>Nils Brede Moe, <a href="http://www.idi.ntnu.no/~dingsoyr/">Torgeir Dingsøyr</a>, and <a href="http://www.sintef.no/home/Contact-us/All-employees/?EmpId=302">Tore Dybå</a>. <strong><a href="http://www.sintef.no/home/Publications/Publication/?page=128772">"A teamwork model for understanding an agile team: A case study of a Scrum project."</a></strong> IST 52, 2010.</em>
<blockquote><strong>Context:</strong> Software development depends significantly on team performance, as does any process that involves human interaction.

<strong>Objective:</strong> Most current development methods argue that teams should self-manage. Our objective is thus to provide a better understanding of the nature of self-managing agile teams, and the teamwork challenges that arise when introducing such teams.

<strong>Method:</strong> We conducted extensive fieldwork for 9 months in a software development company that introduced Scrum. We focused on the human sensemaking, on how mechanisms of teamwork were understood by the people involved.

<strong>Results:</strong> We describe a project through Dickinson and McIntyre’s teamwork model, focusing on the inter-relations between essential teamwork components. Problems with team orientation, team leadership and coordination in addition to highly specialized skills and corresponding division of work were important barriers for achieving team effectiveness.

<strong>Conclusion:</strong> Transitioning from individual work to self-managing teams requires a reorientation not only by developers but also by management. This transition takes time and resources, but should not be neglected. In addition to Dickinson and McIntyre’s teamwork components, we found trust and shared mental models to be of fundamental importance.</blockquote>
There are at least two things in this paper that are relevant for practice. The first is the fairly detailed account of what went right and wrong when this team tried to implement Scrum. The second is the emphasis on self-management and its challenges: for a lot of people today, Agile means short iterations, daily stand-up meetings and unit testing. The self-management aspect (the idea that teams should be autonomous, self-regulating, to actually have power) is often ignored---which is too bad, because it really is at the core of the Agile manifesto and its implementations. Moe &amp; Co show why this is a problem, and how switching to Scrum is more about organizational reorientation than about programming practices.

<em>(<strong>Note:</strong> The link to this paper does not have the PDF available yet, but the authors tell me it will be made available there soon. If you don't have access to it and you are interested in reading it sooner rather than later, kindly requesting a copy from the authors directly through email often works.)</em>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>87</wp:post_id>
		<wp:post_date>2011-08-02 09:00:54</wp:post_date>
		<wp:post_date_gmt>2011-08-02 16:00:54</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>a-teamwork-model-for-understanding-an-agile-team</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="organizational-studies"><![CDATA[Organizational Studies]]></category>
		<category domain="category" nicename="qualitative-studies"><![CDATA[Qualitative Studies]]></category>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Usability Implications of Requiring Parameters in Objects&#039; Constructors</title>
		<link>http://www.neverworkintheory.org/?p=91</link>
		<pubDate>Wed, 27 Jul 2011 01:49:09 +0000</pubDate>
		<dc:creator>gvwilson</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=91</guid>
		<description></description>
		<content:encoded><![CDATA[Jeffrey Stylos and Steven Clarke: "<a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.62.2807&amp;rep=rep1&amp;type=pdf">Usability Implications of Requiring Parameters in Objects' Constructors</a>." <em>ICSE 2007</em>.
<blockquote><em>The usability of APIs is increasingly important to programmer productivity. Based on experience with usability studies of specific APIs, techniques were explored for studying the usability of design choices common to many APIs. A comparative study was performed to assess how professional programmers use APIs with required parameters in objects' constructors as opposed to parameterless "default" constructors. It was hypothesized that required parameters would create more usable and self-documenting APIs by guiding programmers toward the correct use of objects and preventing errors. However, in the study, it was found that, contrary to expectations, programmers strongly preferred and were more effective with APIs that did not require constructor parameters. Participants' behavior was analyzed using the cognitive dimensions framework, and revealing that required constructor parameters interfere with common learning strategies, causing undesirable premature commitment.</em></blockquote>
Programmers argue endlessly about whether language X is more "natural" or more "expressive" than language Y (see, for example, <a href="http://www.jroller.com/scolebourne/entry/reversed_type_declarations">this recent post</a> by Stephen Colbourne about C-style vs. Pascal-style variable declarations). Almost without exception, these arguments are based on personal experience and anecdote, rather than on the kind of careful empirical analysis that has become the norm among serious usability professionals.

This paper by Stylos and Clarke is a good introduction to how such analyses can be done, and the insights they yield. Their work is based on the <a href="http://en.wikipedia.org/wiki/Cognitive_dimensions_of_notations">cognitive dimensions</a> frameowork developed by Green and Petre in the early 1990s, which Clarke has successfully applied to new APIs at Microsoft (see for example <a href="http://brad_abrams.members.winisp.net/Projects/APIDesignPapers/MeasuringAPIUsability.pdf">this writeup</a> from 2004). Those interested in the area should also check out the <a href="http://ecs.victoria.ac.nz/Events/PLATEAU/WebHome">PLATEAU workshops</a>, which have run annually since 2009.]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>91</wp:post_id>
		<wp:post_date>2011-07-26 18:49:09</wp:post_date>
		<wp:post_date_gmt>2011-07-27 01:49:09</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>usability-implications-of-requiring-parameters-in-objects-constructors</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="usability"><![CDATA[Usability]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>An Empirical Study of Build Maintenance Effort</title>
		<link>http://www.neverworkintheory.org/?p=97</link>
		<pubDate>Tue, 09 Aug 2011 17:54:27 +0000</pubDate>
		<dc:creator>gvwilson</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=97</guid>
		<description></description>
		<content:encoded><![CDATA[Shane McIntosh, Bram Adams, Thanh H. D. Nguyen, Yasutaka Kamei, and Ahmed E. Hassan: "An Empirical Study of Build Maintenance Effort". ICSE 2011
<blockquote><em>The build system of a software project is responsible for transforming source code and other development artifacts into executable programs and deliverables. Similar to source code, build system specifications require maintenance to cope with newly implemented features, changes to imported Application Program Interfaces (APIs), and source code restructuring. In this paper, we mine the version histories of one proprietary and nine open source projects of different sizes and domain to analyze the overhead that build maintenance imposes on developers. We split our analysis into two dimensions: (1) Build Coupling, i.e., how frequently source code changes require build changes, and (2) Build Ownership, i.e., the proportion of developers responsible for build maintenance. Our results indicate that, despite the difference in scale, the build system churn rate is comparable to that of the source code, and build changes induce more relative churn on the build system than source code changes induce on the source code. Furthermore, build maintenance yields up to a 27% overhead on source code development and a 44% overhead on test development. Up to 79% of source code developers and 89% of test code developers are significantly impacted by build maintenance, yet investment in build experts can reduce the proportion of impacted developers to 22% of source code developers and 24% of test code developers.</em></blockquote>
One of the many reasons software projects fail is poor estimation, and one of the reasons people estimate badly is that they don't keep track of what's happened before. This paper provides a baseline for both how much effort is required to keep the build system in working order, and how much those figures can be improved. If you have similar numbers for your current project, or if you'd be willing to share data with McIntosh et al so that they could help us all do our jobs better, they'd enjoy hearing from you.]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>97</wp:post_id>
		<wp:post_date>2011-08-09 10:54:27</wp:post_date>
		<wp:post_date_gmt>2011-08-09 17:54:27</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>an-empirical-study-of-build-maintenance-effort</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="experience-reports"><![CDATA[Experience Reports]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>70</wp:comment_id>
			<wp:comment_author><![CDATA[Kim Moir]]></wp:comment_author>
			<wp:comment_author_email>kim.moir@gmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>199.246.40.54</wp:comment_author_IP>
			<wp:comment_date>2011-08-09 13:32:16</wp:comment_date>
			<wp:comment_date_gmt>2011-08-09 20:32:16</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Thanks, this is a very interesting paper.  It also confirms what I've always said, but is rarely implemented: investing in release engineering is productive for the entire team.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1312921936.7535";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>117</wp:comment_id>
			<wp:comment_author><![CDATA[Shane McIntosh]]></wp:comment_author>
			<wp:comment_author_email>shanemcintosh@acm.org</wp:comment_author_email>
			<wp:comment_author_url>http://sailhome.cs.queensu.ca/~shane/</wp:comment_author_url>
			<wp:comment_author_IP>128.221.197.58</wp:comment_author_IP>
			<wp:comment_date>2011-08-31 07:36:20</wp:comment_date>
			<wp:comment_date_gmt>2011-08-31 14:36:20</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Thanks for sharing our paper with your readers. :-)

We would certainly be interested in hearing about build maintenance figures from other projects, or to work with raw data from interested parties. Feel free to follow up with us!]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:14:"1314801380.647";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
		<title>&quot;Cloning considered harmful&quot; considered harmful</title>
		<link>http://www.neverworkintheory.org/?p=102</link>
		<pubDate>Tue, 16 Aug 2011 18:45:29 +0000</pubDate>
		<dc:creator>jorge</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=102</guid>
		<description></description>
		<content:encoded><![CDATA[<em>Cory J. Kapser and <a href="http://plg.uwaterloo.ca/~migod/">Michael W. Godfrey</a>. <strong><a href="http://plg.uwaterloo.ca/~migod/papers/2008/emse08-ClonePatterns.pdf">"Cloning considered harmful" considered harmful: patterns of cloning in software</a>.</strong> Empirical Software Engineering 13, 2008.</em>
<blockquote><em>Literature on the topic of code cloning often asserts that duplicating code within a software system is a bad practice, that it causes harm to the system’s design and should be avoided. However, in our studies, we have found significant evidence that cloning is often used in a variety of ways as a principled engineering tool. For example, one way to evaluate possible new features for a system is to clone the affected subsystems and introduce the new features there, in a kind of sandbox testbed. As features mature and become stable within the experimental subsystems, they can be migrated incrementally into the stable code base; in this way, the risk of introducing instabilities in the stable version is minimized. This paper describes several patterns of cloning that we have observed in our case studies and discusses the advantages and disadvantages associated with using them. We also examine through a case study the frequencies of these clones in two medium-sized open source software systems, the Apache web server and the Gnumeric spreadsheet application. In this study, we found that as many as 71% of the clones could be considered to have a positive impact on the maintainability of the software system.</em></blockquote>
Lots of people, both in industry and in academia, would say that copy-pasting code is bad practice: if you find yourself copy-pasting code (or, in academic parlance, creating "code clones"), you should refactor it: abstract the repeated code into its own method and call it from all the original copies. That way, if you need to change it, or if it has some bugs, you only have to fix it in one place. Some researchers have built pretty sophisticated tools that will help you find your code clones, so that you can go and exterminate them wherever they are.

Kapser and Godfrey, however, explore <em>why</em> developers create code clones, and find out (both through argument and through an empirical evaluation) that many code clones are actually OK. In their paper they discuss several kinds of clones---those that are caused, for instance, by platform variations, boiler-plating, or language idioms---and show that often the right approach is to go ahead and copy-paste code. But they note that whether to clone or not is a decision that requires some thinking on a case by case basis:
<blockquote>(...) the results of the case study identify a set of patterns that are most often harmful, namely <em>verbatim snippets</em> and <em>parameterized code</em>. While there were several examples of good usage of these clone patterns, the majority were deemed harmful. This may be an indication that developers should avoid this form of cloning. On the other hand several patterns were found to be mostly good: <em>boiler-plating</em>, <em>replicate and specialize</em>, and <em>cross-cutting concerns</em>. While not always good, when used with care (as with any form of design or implementation decision) these patterns are more likely to achieve an overall beneficial effect on the software system.</blockquote>
In other words: don't demonize code clones, but don't let them slide unquestioningly either.]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>102</wp:post_id>
		<wp:post_date>2011-08-16 11:45:29</wp:post_date>
		<wp:post_date_gmt>2011-08-16 18:45:29</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>cloning-considered-harmful-considered-harmful</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="code-smells"><![CDATA[Code Smells]]></category>
		<category domain="category" nicename="qualitative-studies"><![CDATA[Qualitative Studies]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>81</wp:comment_id>
			<wp:comment_author><![CDATA[Jorge Aranda]]></wp:comment_author>
			<wp:comment_author_email>jorge@neverworkintheory.org</wp:comment_author_email>
			<wp:comment_author_url>http://www.neverworkintheory.org/</wp:comment_author_url>
			<wp:comment_author_IP>142.104.112.182</wp:comment_author_IP>
			<wp:comment_date>2011-08-16 14:57:29</wp:comment_date>
			<wp:comment_date_gmt>2011-08-16 21:57:29</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[<blockquote>The question I have is whether the widespread aversion to code clones is what causes the majority of observed instances of code cloning to be helpful.</blockquote>

An excellent question that would have to be answered through some other means!]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>80</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1313531849.4688";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:5:"jorge";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>79</wp:comment_id>
			<wp:comment_author><![CDATA[Jorge Aranda]]></wp:comment_author>
			<wp:comment_author_email>jorge@neverworkintheory.org</wp:comment_author_email>
			<wp:comment_author_url>http://www.neverworkintheory.org/</wp:comment_author_url>
			<wp:comment_author_IP>142.104.112.182</wp:comment_author_IP>
			<wp:comment_date>2011-08-16 14:05:45</wp:comment_date>
			<wp:comment_date_gmt>2011-08-16 21:05:45</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[The one I linked to above (ESE 2008) is an extended version from the older one, and I think it's more cohesive: it includes details from their case studies. But it's longer. Still, if I were to recommend just one, it'd be that one.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>78</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1313528745.4247";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:5:"jorge";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>80</wp:comment_id>
			<wp:comment_author><![CDATA[Robert Kern]]></wp:comment_author>
			<wp:comment_author_email>robert.kern@gmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>216.62.213.237</wp:comment_author_IP>
			<wp:comment_date>2011-08-16 14:41:38</wp:comment_date>
			<wp:comment_date_gmt>2011-08-16 21:41:38</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[The question I have is whether the widespread aversion to code clones is what causes the majority of observed instances of code cloning to be helpful. A better ratio to estimate would be the fraction of "good" clones versus the number of times one is *tempted* to clone code. This, of course, is much less measurable, if at all. That would help you determine the balance between "demonization" of clones and "let[ting] them slide".

That said, I do like their breakdown of cloning patterns and how to evaluate and manage each.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1313530898.7809";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>78</wp:comment_id>
			<wp:comment_author><![CDATA[Julius Davies]]></wp:comment_author>
			<wp:comment_author_email>juliusdavies@gmail.com</wp:comment_author_email>
			<wp:comment_author_url>http://juliusdavies.ca/</wp:comment_author_url>
			<wp:comment_author_IP>128.189.213.148</wp:comment_author_IP>
			<wp:comment_date>2011-08-16 14:01:47</wp:comment_date>
			<wp:comment_date_gmt>2011-08-16 21:01:47</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[What a great title!

Speaking of clones, which version of the paper do you like better?  Journal version (Emp. Soft. Engr. 2008) or conference version (WCRE-2006)?]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1313528507.9037";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>6625</wp:comment_id>
			<wp:comment_author><![CDATA[How, and Why, Process Metrics Are Better - It Will Never Work in Theory]]></wp:comment_author>
			<wp:comment_author_email></wp:comment_author_email>
			<wp:comment_author_url>http://www.neverworkintheory.org/?p=565</wp:comment_author_url>
			<wp:comment_author_IP>64.90.54.151</wp:comment_author_IP>
			<wp:comment_date>2013-07-07 04:37:51</wp:comment_date>
			<wp:comment_date_gmt>2013-07-07 11:37:51</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[[...] some of these myths. One example is code cloning being considered as bad practice. But why? A past review of Kapser and Godfrey&#8217;s work stated that many code clones are actually OK. Kapser and Godfrey [...]]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type>pingback</wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";d:1373197071.9566600322723388671875;s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_as_submitted</wp:meta_key>
				<wp:meta_value><![CDATA[a:51:{s:15:"comment_post_ID";i:102;s:14:"comment_author";s:71:"How, and Why, Process Metrics Are Better - It Will Never Work in Theory";s:18:"comment_author_url";s:39:"http://www.neverworkintheory.org/?p=565";s:20:"comment_author_email";s:0:"";s:15:"comment_content";s:217:"[...] some of these myths. One example is code cloning being considered as bad practice. But why? A past review of Kapser and Godfrey&#8217;s work stated that many code clones are actually OK. Kapser and Godfrey [...]";s:12:"comment_type";s:8:"pingback";s:7:"user_ip";s:12:"64.90.54.151";s:10:"user_agent";s:50:"The Incutio XML-RPC PHP Library -- WordPress/3.5.2";s:8:"referrer";N;s:4:"blog";s:32:"http://www.neverworkintheory.org";s:9:"blog_lang";s:5:"en_US";s:12:"blog_charset";s:5:"UTF-8";s:9:"permalink";s:39:"http://www.neverworkintheory.org/?p=102";s:21:"akismet_comment_nonce";s:6:"failed";s:15:"SERVER_SOFTWARE";s:6:"Apache";s:11:"REQUEST_URI";s:11:"/xmlrpc.php";s:4:"PATH";s:29:"/bin:/usr/bin:/sbin:/usr/sbin";s:9:"RAILS_ENV";s:10:"production";s:9:"FCGI_ROLE";s:9:"RESPONDER";s:9:"UNIQUE_ID";s:24:"UdlTDUBaNpMAAEyv2agAAAAE";s:10:"SCRIPT_URL";s:11:"/xmlrpc.php";s:10:"SCRIPT_URI";s:43:"http://www.neverworkintheory.org/xmlrpc.php";s:4:"dsid";s:8:"18100032";s:14:"ds_id_18100032";s:0:"";s:7:"DH_USER";s:11:"yorchopolis";s:15:"HTTP_USER_AGENT";s:50:"The Incutio XML-RPC PHP Library -- WordPress/3.5.2";s:9:"HTTP_HOST";s:25:"www.neverworkintheory.org";s:11:"HTTP_ACCEPT";s:3:"*/*";s:12:"CONTENT_TYPE";s:8:"text/xml";s:20:"HTTP_ACCEPT_ENCODING";s:29:"deflate;q=1.0, compress;q=0.5";s:14:"CONTENT_LENGTH";s:3:"279";s:16:"SERVER_SIGNATURE";s:0:"";s:11:"SERVER_NAME";s:25:"www.neverworkintheory.org";s:11:"SERVER_ADDR";s:12:"64.90.54.151";s:11:"SERVER_PORT";s:2:"80";s:11:"REMOTE_ADDR";s:12:"64.90.54.151";s:13:"DOCUMENT_ROOT";s:39:"/home/yorchopolis/neverworkintheory.org";s:12:"SERVER_ADMIN";s:31:"webmaster@neverworkintheory.org";s:15:"SCRIPT_FILENAME";s:50:"/home/yorchopolis/neverworkintheory.org/xmlrpc.php";s:11:"REMOTE_PORT";s:5:"48495";s:17:"GATEWAY_INTERFACE";s:7:"CGI/1.1";s:15:"SERVER_PROTOCOL";s:8:"HTTP/1.0";s:14:"REQUEST_METHOD";s:4:"POST";s:12:"QUERY_STRING";s:0:"";s:11:"SCRIPT_NAME";s:11:"/xmlrpc.php";s:15:"HTTP_CONNECTION";s:5:"close";s:8:"PHP_SELF";s:11:"/xmlrpc.php";s:12:"REQUEST_TIME";s:10:"1373197069";s:4:"argv";s:0:"";s:4:"argc";s:1:"0";s:25:"comment_post_modified_gmt";s:19:"2011-08-16 18:45:29";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
		<title>Three Empirical Evaluations of UML</title>
		<link>http://www.neverworkintheory.org/?p=108</link>
		<pubDate>Wed, 17 Aug 2011 15:37:36 +0000</pubDate>
		<dc:creator>gvwilson</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=108</guid>
		<description></description>
		<content:encoded><![CDATA[Like a lot of people (particularly those with engineering backgrounds), I was very excited when UML first appeared in the mid-1990s. "At last," I thought, "Programmers will have something like blueprints and circuit diagrams to help them design software." I knew they'd be better than flowcharts: after all, they were <em>object-oriented</em>, which back then was pretty much a synonym for "good". But, like a lot of people, I read about UML more than I ever actually used it. It never seemed to help me analyze things the way circuit diagrams had when I was an undergrad, and it wasn't much use as a communication tool either: every diagram I drew had to be accompanied by several paragraphs of explanatory text, and my colleagues seemed to be able to understand the latter perfectly well when accompanied by a few freehand block-and-arrow sketches.

But anecdotes don't prove anything—to do that, you need to look at many people, in many contexts, over an extended period. User experience designers have been doing this for years; one of the most hopeful developments in empirical software engineering is the way that people are using those techniques to find out where and when UML is actually useful, and, where it's not, why not. Three fairly recent studies of this kind are cited below—we look forward to many more, and to a next generation of software design notations based on their findings.

Wojciech James Dzidek, Erik Arisholm, and Lionel C. Briand: "A realistic empirical evaluation of the costs and benefits of UML in software maintenance." <cite>IEEE Trans. Software Engineering</cite>, 34(3), May/June 2008.
<blockquote><em>The Unified Modeling Language (UML) is the de facto standard for object-oriented software analysis and design modeling. However, few empirical studies exist which investigate the costs and evaluate the benefits of using UML in realistic contexts. Such studies are needed so that the software industry can make informed decisions regarding the extent to which they should adopt UML in their development practices. This is the first controlled experiment that investigates the costs of maintaining and the benefits of using UML documentation during the maintenance and evolution of a real nontrivial system, using professional developers as subjects, working with a state-of-the-art UML tool during an extended period of time. The subjects in the control group had no UML documentation. In this experiment, the subjects in the UML group had, on average, a practically and statistically significant 54 percent increase in the functional correctness of changes (ρ = 0:03) and an insignificant 7 percent overall improvement in design quality (ρ = 0:22), though a much larger improvement was observed on the first change task (56 percent), at the expense of an insignificant 14 percent increase in development time caused by the overhead of updating the UML documentation (ρ = 0:35).</em></blockquote>
Andrea De Lucia, Carmine Gravino, Rocco Oliveto, and Genoveffa Tortora: "An experimental comparison of ER and UML class diagrams for data modelling." <cite>Empirical Software Engineering</cite>, 15:455–492, 2010.
<blockquote><em>We present the results of three sets of controlled experiments aimed at analysing whether UML class diagrams are more comprehensible than ER diagrams during data models maintenance. In particular, we considered the support given by the two notations in the comprehension and interpretation of data models, comprehension of the change to perform to meet a change request, and detection of defects contained in a data model. The experiments involved university students with different levels of ability and experience. The results demonstrate that using UML class diagrams subjects achieved better comprehension levels. With regard to the support given by the two notations during maintenance activities the results demonstrate that the two notations give the same support, while in general UML class diagrams provide a better support with respect to ER diagrams during verification activities.</em></blockquote>
José A. Cruz-Lemus, Marcela Genero, M. Esperanza Manso, Sandro Morasca, and Mario Piattini: "Assessing the understandability of UML statechart diagrams with composite states&amp;emdash;a family of empirical studies." <cite>Empirical Software Engineering</cite>, 14:685–719, 2009.
<blockquote><em>The main goal of this work is to present a family of empirical studies that we have carried out to investigate whether the use of composite states may improve the understandability of UML statechart diagrams derived from class diagrams. Our hypotheses derive from conventional wisdom, which says that hierarchical modeling mechanisms are helpful in mastering the complexity of a software system. In our research, we have carried out three empirical studies, consisting of five experiments in total. The studies differed somewhat as regards the size of the UML statechart models, though their size and the complexity of the models were chosen so that they could be analyzed by the subjects within a limited time period. The studies also differed with respect to the type of subjects (students vs. professionals), the familiarity of the subjects with the domains of the diagrams, and other factors. To integrate the results obtained from each of the five experiments, we performed a meta-analysis study which allowed us to take into account the differences between studies and to obtain the overall effect that the use of composite states has on the understandability of UML statechart diagrams throughout all the experiments. The results obtained are not completely conclusive. They cast doubts on the usefulness of composite states for a better understanding and memorizing of UML statechart diagrams. Composite states seem only to be helpful for acquiring knowledge from the diagrams. At any rate, it should be noted that these results are affected by the previous experience of the subjects on modeling, as well as by the size and complexity of the UML statechart diagrams we used, so care should be taken when generalizing our results.</em></blockquote>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>108</wp:post_id>
		<wp:post_date>2011-08-17 08:37:36</wp:post_date>
		<wp:post_date_gmt>2011-08-17 15:37:36</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>three-empirical-evaluations-of-uml</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="controlled-experiments"><![CDATA[Controlled Experiments]]></category>
		<category domain="category" nicename="quantitative-studies"><![CDATA[Quantitative Studies]]></category>
		<category domain="category" nicename="usability"><![CDATA[Usability]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Creating and Evolving Developer Documentation</title>
		<link>http://www.neverworkintheory.org/?p=115</link>
		<pubDate>Tue, 23 Aug 2011 18:07:45 +0000</pubDate>
		<dc:creator>jorge</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=115</guid>
		<description></description>
		<content:encoded><![CDATA[<em><a href="http://www.infobart.com/">Barthélémy Dagenais</a> and <a href="http://www.cs.mcgill.ca/~martin/">Martin P. Robillard</a>. <strong><a href="http://www.infobart.com/wp-content/uploads/2010/11/fse2010.pdf">"Creating and Evolving Developer Documentation: Understanding the Decisions of Open Source Contributors."</a></strong> FSE 2010.</em>
<blockquote><em>Developer documentation helps developers learn frameworks and libraries. To better understand how documentation in open source projects is created and maintained, we performed a qualitative study in which we interviewed core contributors who wrote developer documentation and developers who read documentation. In addition, we studied the evolution of 19 documents by analyzing more than 1500 document revisions. We identified the decisions that contributors make, the factors influencing these decisions and the consequences for the project. Among many findings, we observed how working on the documentation could improve the code quality and how constant interaction with the projects' community positively impacted the documentation.</em></blockquote>
Contributors to a new open source software that are beginning to work on its documentation have plenty of choices available to them. For instance, they could put their efforts in a public wiki, or set a separate documentation team, or just deal with documentation piecemeal, as questions for the use of their software arise in a forum. These decisions have significant consequences for the project later on. Dagenais and Robillard's paper is a good description of these important decisions and their consequences. I don't think many seasoned open source developers will find most results surprising (which is good for this kind of paper!), but they'll appreciate having them collected and validated empirically.

Table 3 is the best summary of the paper's findings, if you don't have time to read it whole, but it's a bit hard to parse if you haven't at least skimmed through the earlier pages.]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>115</wp:post_id>
		<wp:post_date>2011-08-23 11:07:45</wp:post_date>
		<wp:post_date_gmt>2011-08-23 18:07:45</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>creating-and-evolving-developer-documentation</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="open-source"><![CDATA[Open Source]]></category>
		<category domain="category" nicename="qualitative-studies"><![CDATA[Qualitative Studies]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Is Transactional Programming Actually Easier?</title>
		<link>http://www.neverworkintheory.org/?p=122</link>
		<pubDate>Wed, 24 Aug 2011 16:30:24 +0000</pubDate>
		<dc:creator>gvwilson</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=122</guid>
		<description></description>
		<content:encoded><![CDATA[Christopher J. Rossbach, Owen S. Hofmann, and Emmett Witchel: "<a href="http://www.cs.utexas.edu/users/rossbach/pubs/ppopp012-rossbach.pdf">Is Transactional Programming Actually Easier?</a>" <cite>Principles and Practice of Parallel Programming</cite>, 2010.
<blockquote><em>In this paper, we describe a user-study in which 147 undergraduate students in an operating systems course implemented the same programs using coarse and fine-grain locks, monitors, and transactions. We surveyed the students after the assignment, and examined their code to determine the types and frequency of programming errors for each synchronization technique. Inexperienced programmers found baroque syntax a barrier to entry for transactional programming. On average, subjective evaluation showed that students found transactions harder to use than coarse-grain locks, but slightly easier to use than fine-grained locks. Detailed examination of synchronization errors in the students' code tells a rather different story. Overwhelmingly, the number and types of programming errors the students made was much lower for transactions than for locks. On a similar programming problem, over 70% of students made errors with fine-grained locking, while less than 10% made errors with transactions.</em></blockquote>
<a href="http://en.wikipedia.org/wiki/Software_transactional_memory">Software Transactional Memory</a> (STM) has been receiving a lot of press lately as people try to find ways of making parallelism safe for human consumption. The results presented in this paper are a very hopeful sign: students who used it did better on simple problems than students using more traditional mechanisms. What's equally interested is that they <em>thought</em> they had done worse, possibly because of the "baroque syntax" the authors mention.  And once again, this paper highlights the fact that the usability of software engineering tools, including programming languages, can and should be studied empirically.]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>122</wp:post_id>
		<wp:post_date>2011-08-24 09:30:24</wp:post_date>
		<wp:post_date_gmt>2011-08-24 16:30:24</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>is-transactional-programming-actually-easier</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="controlled-experiments"><![CDATA[Controlled Experiments]]></category>
		<category domain="category" nicename="programming-languages"><![CDATA[Programming Languages]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>239</wp:comment_id>
			<wp:comment_author><![CDATA[An Empirical Comparison of the Accuracy Rates of Novices using the Quorum, Perl, and Randomo Programming Languages - It will never work in theory]]></wp:comment_author>
			<wp:comment_author_email></wp:comment_author_email>
			<wp:comment_author_url>http://www.neverworkintheory.org/?p=197</wp:comment_author_url>
			<wp:comment_author_IP>64.90.54.151</wp:comment_author_IP>
			<wp:comment_date>2011-10-24 11:45:44</wp:comment_date>
			<wp:comment_date_gmt>2011-10-24 18:45:44</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[[...] That&#8217;s why I enjoyed this paper so much. It isn&#8217;t just their finding that novices using Perl were no more likely to write a correct program than novices using a language whose syntax was generated randomly (although I did smile quite broadly when I read that). This paper&#8217;s real contribution is to show that such studies are possible—that we can and should put such claims to the test, just as Rossbach et al. did for transactional programming. [...]]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type>pingback</wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319481944.4985";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
		<title>What Michael Feathers Thinks You Should Read</title>
		<link>http://www.neverworkintheory.org/?p=126</link>
		<pubDate>Wed, 24 Aug 2011 16:50:24 +0000</pubDate>
		<dc:creator>gvwilson</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=126</guid>
		<description></description>
		<content:encoded><![CDATA[Michael Feathers is the author of <a href="http://www.amazon.com/Working-Effectively-Legacy-Michael-Feathers/dp/0131177052">one of our favorite books on programming</a>. In February 2009, he posted a list of <a href="http://blog.objectmentor.com/articles/2009/02/26/10-papers-every-programmer-should-read-at-least-twice">ten papers that every programmer should read at least twice</a>:
<ol>
	<li><a href="http://sunnyday.mit.edu/16.355/parnas-criteria.html">On the criteria to be used in decomposing systems into modules</a> – David Parnas</li>
	<li><a href="http://research.sun.com/techrep/1994/abstract-29.html">A Note On Distributed Computing</a> – Jim Waldo, Geoff Wyant, Ann Wollrath, Sam Kendall</li>
	<li><a href="http://portal.acm.org/citation.cfm?id=365257">The Next 700 Programming Languages</a> – P. J. Landin</li>
	<li><a href="http://portal.acm.org/citation.cfm?id=359579">Can Programming Be Liberated from the von Neumann Style?</a> – John Backus</li>
	<li><a href="http://cm.bell-labs.com/who/ken/trust.html">Reflections on Trusting Trust</a> – Ken Thompson</li>
	<li><a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.50.6083">Lisp: Good News, Bad News, How to Win Big</a> – Richard Gabriel</li>
	<li><a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.29.363">An experimental evaluation of the assumption of independence in multiversion programming</a> – John Knight and Nancy Leveson</li>
	<li><a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.50.7565">Arguments and Results</a> – James Noble</li>
	<li><a href="http://c2.com/doc/oopsla89/paper.html">A Laboratory For Teaching Object-Oriented Thinking</a> – Kent Beck, Ward Cunningham</li>
	<li><a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.31.562">Programming as an Experience: the inspiration for Self</a> – David Ungar, Randall B. Smith</li>
</ol>
His reasons for picking these papers over tens of thousands of others are well worth reading as well.  What would you add to the list?  What would you <em>replace</em> if the list had to stay 10 items long?]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>126</wp:post_id>
		<wp:post_date>2011-08-24 09:50:24</wp:post_date>
		<wp:post_date_gmt>2011-08-24 16:50:24</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>what-michael-feathers-thinks-you-should-read</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="noticed"><![CDATA[Noticed]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>104</wp:comment_id>
			<wp:comment_author><![CDATA[Rafael de F. Ferreira]]></wp:comment_author>
			<wp:comment_author_email>public@rafaelferreira.net</wp:comment_author_email>
			<wp:comment_author_url>http://www.rafaelferreira.net/</wp:comment_author_url>
			<wp:comment_author_IP>189.57.30.203</wp:comment_author_IP>
			<wp:comment_date>2011-08-26 10:35:15</wp:comment_date>
			<wp:comment_date_gmt>2011-08-26 17:35:15</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[This is an excellent list, but it's missing some Fred Brooks. I would the classic No Silver Bullet essay.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1314380116.0384";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>106</wp:comment_id>
			<wp:comment_author><![CDATA[links for 2011-08-26fboiton&#039;s blog | fboiton&#039;s blog]]></wp:comment_author>
			<wp:comment_author_email></wp:comment_author_email>
			<wp:comment_author_url>http://www.fboiton.com/links-for-2011-08-26</wp:comment_author_url>
			<wp:comment_author_IP>216.69.186.160</wp:comment_author_IP>
			<wp:comment_date>2011-08-26 12:02:54</wp:comment_date>
			<wp:comment_date_gmt>2011-08-26 19:02:54</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[[...] What Michael Feathers Thinks You Should Read &#8211; It will never work in theory ten papers that every programmer should read at least twice (tags: development papers) [...]]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type>pingback</wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1314385374.8128";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>114</wp:comment_id>
			<wp:comment_author><![CDATA[Rafael de F. Ferreira]]></wp:comment_author>
			<wp:comment_author_email>public@rafaelferreira.net</wp:comment_author_email>
			<wp:comment_author_url>http://www.rafaelferreira.net/</wp:comment_author_url>
			<wp:comment_author_IP>200.184.133.245</wp:comment_author_IP>
			<wp:comment_date>2011-08-29 09:43:27</wp:comment_date>
			<wp:comment_date_gmt>2011-08-29 16:43:27</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Ok, I'll bite. Ken Thompson's "Reflections on Trusting Trust" is a great read, a thought-provoking article, but its not as important as Brooks' essay.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>105</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1314636207.1874";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>105</wp:comment_id>
			<wp:comment_author><![CDATA[Greg Wilson]]></wp:comment_author>
			<wp:comment_author_email>gvwilson@third-bit.com</wp:comment_author_email>
			<wp:comment_author_url>http://www.third-bit.com</wp:comment_author_url>
			<wp:comment_author_IP>38.104.156.10</wp:comment_author_IP>
			<wp:comment_date>2011-08-26 10:37:22</wp:comment_date>
			<wp:comment_date_gmt>2011-08-26 17:37:22</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Ah, but that's cheating --- you can only recommend a paper if you also say which one on the list you'd take out to make room :-)]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>104</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1314380242.5501";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>115</wp:comment_id>
			<wp:comment_author><![CDATA[Jorge Aranda]]></wp:comment_author>
			<wp:comment_author_email>jorge@neverworkintheory.org</wp:comment_author_email>
			<wp:comment_author_url>http://www.neverworkintheory.org/</wp:comment_author_url>
			<wp:comment_author_IP>24.68.65.123</wp:comment_author_IP>
			<wp:comment_date>2011-08-29 18:50:16</wp:comment_date>
			<wp:comment_date_gmt>2011-08-30 01:50:16</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[I'm with Rafael here. "No Silver Bullet" is a clear, elemental argument in software development.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>114</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1314669016.2499";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:5:"jorge";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
		<title>What makes a good bug report?</title>
		<link>http://www.neverworkintheory.org/?p=131</link>
		<pubDate>Tue, 30 Aug 2011 19:26:45 +0000</pubDate>
		<dc:creator>jorge</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=131</guid>
		<description></description>
		<content:encoded><![CDATA[<em><em><a href="http://nicolas-bettenburg.com/">Nicolas Bettenburg</a>, Sascha Just, <em><a href="http://www.segal.uvic.ca/members/schadr">Adrian Schröter</a>, <a href="http://www.ifi.uzh.ch/ddis/people/weiss/">Cathrin Weiss</a>, </em></em><a href="http://www.cs.vu.nl/~rpremraj/">Rahul Premraj</a>, and <a href="http://thomas-zimmermann.com/">Thomas Zimmermann</a>. <strong><a href="http://nicolas-bettenburg.com/papers/bettenburg-fse2008.pdf">What Makes a Good Bug Report?</a></strong><em> FSE 2008.</em></em>
<blockquote><em>In software development, bug reports provide crucial information to developers. However, these reports widely differ in their quality. We conducted a survey among developers and users of APACHE, ECLIPSE, and MOZILLA to find out what makes a good bug report.</em>

<em>The analysis of the 466 responses revealed an information mismatch between what developers need and what users supply. Most developers consider steps to reproduce, stack traces, and test cases as helpful, which are at the same time most difficult to provide for users. Such insight is helpful for designing new bug tracking tools that guide users at collecting and providing more helpful information.</em>

<em> Our CUEZILLA prototype is such a tool and measures the quality of new bug reports; it also recommends which elements should be added to improve the quality. We trained CUEZILLA on a sample of 289 bug reports, rated by developers as part of the survey. In our experiments, CUEZILLA was able to predict the quality of 31%--48% of bug reports accurately.</em></blockquote>
The information that users supply when they file a bug report tends not to be that which the relevant developers need the most, and most importantly, it differs in fairly predictable ways and for understandable reasons. As Bettenburg <em>et al.</em> discuss in their paper, this means that efforts at steering users towards providing information that is most useful (by telling them how to get it, for instance, or by providing a score on the usefulness of the bug report as it stands) should yield significant benefits.]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>131</wp:post_id>
		<wp:post_date>2011-08-30 12:26:45</wp:post_date>
		<wp:post_date_gmt>2011-08-30 19:26:45</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>what-makes-a-good-bug-report</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="open-source"><![CDATA[Open Source]]></category>
		<category domain="category" nicename="quality"><![CDATA[Quality]]></category>
		<category domain="category" nicename="survey"><![CDATA[Survey]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>127</wp:comment_id>
			<wp:comment_author><![CDATA[Julius Davies]]></wp:comment_author>
			<wp:comment_author_email>juliusdavies@gmail.com</wp:comment_author_email>
			<wp:comment_author_url>http://juliusdavies.ca/</wp:comment_author_url>
			<wp:comment_author_IP>128.189.245.9</wp:comment_author_IP>
			<wp:comment_date>2011-09-01 10:30:40</wp:comment_date>
			<wp:comment_date_gmt>2011-09-01 17:30:40</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Clay Shirky, in his Vancouver LinuxCon keynote (2011), referred to Firefox bug #330884 as his favourite bug report:


https://bugzilla.mozilla.org/show_bug.cgi?id=330884


Bug 330884 - When different users on one system choose to save or not save passwords for sites, any other user can see sites they not only saved passwords for but can also see what other users have been saving/never saving passwords for.


naomi 2006-03-17 15:48:21 PST
"This privacy flaw has caused my fiancé and I to break-up after having dated for 5 years."


Majken "Lucy" Connor 2006-03-21 19:07:21 PST:
"[...] bugzilla isn't the place for this, but I can't help it.  Honey, I would think you would be the LAST person to be bothered by this. Not only did was he using your computer to be unfaithful, he wasn't smart enough to cover his tracks, "]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1314898240.4816";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>128</wp:comment_id>
			<wp:comment_author><![CDATA[Jorge Aranda]]></wp:comment_author>
			<wp:comment_author_email>jorge@neverworkintheory.org</wp:comment_author_email>
			<wp:comment_author_url>http://www.neverworkintheory.org/</wp:comment_author_url>
			<wp:comment_author_IP>142.104.21.214</wp:comment_author_IP>
			<wp:comment_date>2011-09-01 11:16:11</wp:comment_date>
			<wp:comment_date_gmt>2011-09-01 18:16:11</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[It reads like a McSweeney's piece!]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>127</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1314900972.0129";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:5:"jorge";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
		<title>Comparing the Defect Reduction Benefits of Code Inspection and Test-Driven Development</title>
		<link>http://www.neverworkintheory.org/?p=139</link>
		<pubDate>Wed, 31 Aug 2011 16:41:01 +0000</pubDate>
		<dc:creator>gvwilson</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=139</guid>
		<description></description>
		<content:encoded><![CDATA[Jerod W. Wilkerson, Jay F. Nunamaker, Jr., and Rick Mercer: "Comparing the Defect Reduction Benefits of Code Inspection and Test-Driven Development." Pre-print, <cite>IEEE Trans. Software Engineering</cite>, April 2011.
<blockquote><em>This study is a quasi-experiment comparing the software defect rates and implementation costs of two methods of software defect reduction: code inspection and test-driven development. We divided participants, consisting of junior and senior computer science students at a large Southwestern university, into four groups using a two-by-two, between-subjects, factorial design and asked them to complete the same programming assignment using either test-driven development, code inspection, both, or neither. We compared resulting defect counts and implementation costs across groups. We found that code inspection is more effective than test-driven development at reducing defects, but that code inspection is also more expensive. We also found that test-driven development was no more effective at reducing defects than traditional programming methods.</em></blockquote>
I'm still not sure what to think about test-driven development. On the one hand, I feel that it helps me program better—and feel that strongly enough that I teach TDD in courses. On the other hand, studies like this one, and the other summarized in Erdogmus et al's chapter in <a href="http://www.amazon.com/Making-Software-Really-Works-Believe/dp/0596808321"><cite>Making Software</cite></a>, seem to show that the benefits are illusory. That might mean that we're measuring the wrong thing, but I'm still waiting for one of TDD's advocates to say how we'd measure the right thing.

One thing I <em>am</em> sure of is the importance of studying students. It's easy to dismiss the results of such studies by saying that they don't necessarily apply to experienced full-time programmers in industry, but that's missing the point. They definitely <em>do</em> apply to students, and if a tool or practice isn't compelling to a 20-year-old who is exposed to it for three weeks, it's going to spread slowly (if at all).]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>139</wp:post_id>
		<wp:post_date>2011-08-31 09:41:01</wp:post_date>
		<wp:post_date_gmt>2011-08-31 16:41:01</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>comparing-the-defect-reduction-benefits-of-code-inspection-and-test-driven-development</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="controlled-experiments"><![CDATA[Controlled Experiments]]></category>
		<category domain="category" nicename="quantitative-studies"><![CDATA[Quantitative Studies]]></category>
		<category domain="category" nicename="testing"><![CDATA[Testing]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>123</wp:comment_id>
			<wp:comment_author><![CDATA[Jorge Aranda]]></wp:comment_author>
			<wp:comment_author_email>jorge@neverworkintheory.org</wp:comment_author_email>
			<wp:comment_author_url>http://www.neverworkintheory.org/</wp:comment_author_url>
			<wp:comment_author_IP>142.104.119.69</wp:comment_author_IP>
			<wp:comment_date>2011-08-31 14:43:08</wp:comment_date>
			<wp:comment_date_gmt>2011-08-31 21:43:08</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Kev, that's a good hypothetical benefit of TDD, but code reviews has similarly hypothetical benefits: when someone on the organization other than the original author comes to change the code later, they will be more familiar with it than if they hadn't seen it before.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>120</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1314826988.0874";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:5:"jorge";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>124</wp:comment_id>
			<wp:comment_author><![CDATA[Laurent Bossavit]]></wp:comment_author>
			<wp:comment_author_email>laurent.git@bossavit.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>81.64.220.205</wp:comment_author_IP>
			<wp:comment_date>2011-08-31 17:22:08</wp:comment_date>
			<wp:comment_date_gmt>2011-09-01 00:22:08</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[It gets more troubling on closer reading.

The main claim is that the Inspection guys turn in code that has fewer defects than the TDD guys. But this is only true, statistically speaking, for "adjusted" defect counts. When the authors look at "unadjusted" defect counts there is no statistically significant difference: "based on the unadjusted defect counts, we would reject hypotheses H1 and H2". (The usual problem in such studies that Bill Curtis pointed all these decades ago: noise swamps out signal.)

What does "adjusted" mean? It means basically that the Inspection students get credited not only for the bugs they fix during the one-week period after developing their code; they also get credited for all the bugs *they didn't fix*, that were found during inspection. (Remember too that the inspections are performed by students who are "not participants in the study"; that is, the design of the study is not measuring *their* effectiveness.)

This effectively stacks the deck in favor of Inspection over TDD, and it's easy to suppose that this entirely accounts for the supposedly statistically significant difference between the two groups.

The authors justify this procedure on the grounds that a well-run Inspection process would keep inspecting and fixing until all bugs found in the first Inspection round were in fact fixed. But that doesn't change the fact that the Inspection group effectively gets to do a lot more testing than the TDD group; it's not so surprising that this results in fewer defects.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>122</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:14:"1314836528.519";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>126</wp:comment_id>
			<wp:comment_author><![CDATA[Darrin Thompson]]></wp:comment_author>
			<wp:comment_author_email>darrinth@gmail.com</wp:comment_author_email>
			<wp:comment_author_url>http://willowbend.cx/</wp:comment_author_url>
			<wp:comment_author_IP>207.250.96.104</wp:comment_author_IP>
			<wp:comment_date>2011-09-01 08:41:26</wp:comment_date>
			<wp:comment_date_gmt>2011-09-01 15:41:26</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[I can see problems with the study's conclusion on inspection being significantly better than TDD.

On the other hand we can bank on 75 minutes of TDD training not being enough to significantly reduce bugs on a one week project. That's more training than many of us ever got.

I'm confident in my belief that I get some benefit from TDD, especially when working on "pure" computation, as in, functions with no side effects.

Reflecting on my career, I've been suspicious that TDD has been a waste of time for a lot of the code I have written. That's comparing it to some other techniques I've learned such as carefully controlling side effects, etc.

I do believe that automating testing has a big role to play in getting good software released. I buy the idea that testing before coding has merit. But the methods I've seen advocated by TDDers, i.e. mocking, a large number of IO free tests, I think are less effective than they claim to be.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>124</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1314891686.8995";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>141</wp:comment_id>
			<wp:comment_author><![CDATA[Darrin Thompson]]></wp:comment_author>
			<wp:comment_author_email>darrinth@gmail.com</wp:comment_author_email>
			<wp:comment_author_url>http://willowbend.cx/</wp:comment_author_url>
			<wp:comment_author_IP>207.250.96.104</wp:comment_author_IP>
			<wp:comment_date>2011-09-06 06:11:32</wp:comment_date>
			<wp:comment_date_gmt>2011-09-06 13:11:32</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[&gt; So you know exactly how a code change will impact your entire software? Are you able to go ahead and refactor (or even rewrite) a very important module and not introduce new bugs?

Yes, and yes.

&gt; If TDD doesn’t work for someone, then they need to get more experience in software development first.

12 years. 10ish of which includes actively practicing TDD. I am the author of qc.js which ports some newer unit testing ideas to JavaScript.

I've come into contact with some new ideas that also contribute to software quality and, I think, improve on the results I got with just TDD alone.

Heresy, I know.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>133</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1315314692.4425";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>122</wp:comment_id>
			<wp:comment_author><![CDATA[Laurent Bossavit]]></wp:comment_author>
			<wp:comment_author_email>laurent.git@bossavit.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>81.64.220.205</wp:comment_author_IP>
			<wp:comment_date>2011-08-31 14:04:30</wp:comment_date>
			<wp:comment_date_gmt>2011-08-31 21:04:30</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[It's really a shame that most readers will have to pay $19 to get the PDF with the full text of the study, because the abstract really isn't the whole story. (Everyone should read George Monbiot's recent piece on the economics of academic publishing.)

I've only given the full paper a quick skim rather than a thorough analysis, but what sticks out for me is that the amount of training given in the inspection process was greater than that given in TDD; I'm not completely clear on why "Inspectors were students but were not participants 
in the study", but at first blush it suggests that apples are being compared to oranges here.

I don't see, for instance, where you're getting "three weeks" of training. The paper says "Formal instruction consisted of one 75-minute classroom lecture on JUnit and TDD [and] completed a one-week programming assignment." That seems insufficient to ensure that the TDD subjects were applying TDD at all effectively.

I'm also amused to read that 2 students were excluded from the study for cheating, 2 for dropping the class, and so on - the paper notes that the "mortality" is high. Not sure if that means TDD isn't "compelling" to these students - it seems to suggest more that the class, or programming itself, isn't compelling.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1314824670.3042";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>120</wp:comment_id>
			<wp:comment_author><![CDATA[Kev]]></wp:comment_author>
			<wp:comment_author_email>kevin.p.dwyer+NeverWork@gmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>77.99.143.248</wp:comment_author_IP>
			<wp:comment_date>2011-08-31 11:05:57</wp:comment_date>
			<wp:comment_date_gmt>2011-08-31 18:05:57</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Hello,

Interesting piece - I'd always assumed that TDD would deliver fewer bugs out of the box compared to an ostensibly "softer" technique such as code inspection.  On re-thinking this assumption in the light of your post, I suppose inspection can take advantage of multiple individuals reviewing the code, whereas with TDD it could be just a single programmer writing the test cases, and this programmer is only going to test the conditions that s/he can come up with, and if the programmer is any good s/he will code for these cases regardless of the programming methodology in use (yes, it could a pair of programmers...).

But perhaps the benefit of TDD is not so much that you introduce fewer bugs first up, but rather when you come to change the code later you can have some degree of confidence that your code "works" as well as it did before, modulo the quality of your tests?

Cheers,

Kev]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1314813957.9283";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>119</wp:comment_id>
			<wp:comment_author><![CDATA[Rafael Chaves]]></wp:comment_author>
			<wp:comment_author_email>rafael@abstratt.com</wp:comment_author_email>
			<wp:comment_author_url>http://abstratt.com/blog</wp:comment_author_url>
			<wp:comment_author_IP>64.251.72.182</wp:comment_author_IP>
			<wp:comment_date>2011-08-31 10:27:16</wp:comment_date>
			<wp:comment_date_gmt>2011-08-31 17:27:16</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Hmm... showing correctness is only one of the benefits of TDD/automated testing. Others are:

1) ensuring the code is not broken by future changes (prevent regressions)
2) describing how an object protocol (API) is meant to be used

Code inspection can't help with either of those. Manual testing is a horrible way of attaining #1.

IOW, sure, there are many ways to show some code is correct today. But that is not the only benefit of TDD/automated testing.

That being said, I don't think code inspection and TDD are in any way overlapping, I believe both practices can be applied simultaneously.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[true]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1314811636.7864";s:7:"message";s:35:"Akismet caught this comment as spam";s:5:"event";s:10:"check-spam";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1314979124.5739";s:7:"message";s:39:"jorge reported this comment as not spam";s:5:"event";s:10:"report-ham";s:4:"user";s:5:"jorge";}]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_user_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_user</wp:meta_key>
				<wp:meta_value><![CDATA[jorge]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>129</wp:comment_id>
			<wp:comment_author><![CDATA[Nick Coghlan]]></wp:comment_author>
			<wp:comment_author_email>ncoghlan@gmail.com</wp:comment_author_email>
			<wp:comment_author_url>http://www.boredomandlaziness.org</wp:comment_author_url>
			<wp:comment_author_IP>66.187.239.254</wp:comment_author_IP>
			<wp:comment_date>2011-09-01 16:20:18</wp:comment_date>
			<wp:comment_date_gmt>2011-09-01 23:20:18</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Ah, thanks for explaining that - it does sound like the study was quite flawed in its conclusions, but its data does provide useful information. Most importantly, when a problem lies in the specification or in the way the developer understands that specification, TDD *won't help* because the tests will be wrong as well. Similar, if the developer completely fails to consider some aspect of the code, they won't write a test case that exercises that, either.

Code inspections (especially of the tests themselves) can pick up those kinds of errors.

One area where TDD really shines is in *capturing the results of code inspections*. Code inspection found a problem? *Fix the tests first*. Once the tests are fixed, then you know that problem won't recur, even if the underlying code changes in other ways. Code inspections on their own don't give you that - if you *only* do code inspections and don't back it up with TDD, the only way to confirm that the problems have been addressed is to manually inspect the code *again*, which is inefficient and wasteful.

Coming up with a good test is hard and creative, and hence a task that needs humans. Once those tests have been defined, ensuring that future versions of the software pass the tests is boring and repetitive, and hence a task best handled by computers. This isn't an either/or decision - use TDD, but use code inspection to make sure your test suite is up to par in the first place.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>124</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1314919218.5573";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>131</wp:comment_id>
			<wp:comment_author><![CDATA[Ben Finney]]></wp:comment_author>
			<wp:comment_author_email>bignose@example.org</wp:comment_author_email>
			<wp:comment_author_url>http://Yourwebsite</wp:comment_author_url>
			<wp:comment_author_IP>150.101.214.82</wp:comment_author_IP>
			<wp:comment_date>2011-09-02 03:26:05</wp:comment_date>
			<wp:comment_date_gmt>2011-09-02 10:26:05</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[&gt; We also found that test-driven development was no more effective at reducing defects than traditional programming methods.

As a strong advocate of test-driven development, that's not a surprising statement to me.

The alternative would presumably be that equivalent code bases, with equivalent unit tests written, would show different amounts of defects depending on *how* the tests were written. When phrased like that, clearly it's a foolish prediction.

What I say, rather, is that test-driven development will *actually get more tests written*.

It does so by making writing unit tests a necessary part of the very detailed programming iterations hour-by-hour. The “traditional programming methods” don't suddenly make tests worse; rather, it's much more likely to lead to programmers deferring the task of writing unit tests, and hence lead to statistically fewer unit tests written.

So the thing to measure is how many test cases actually get written (alternatively: how much code coverage you get from their unit tests), *without telling the programmers* that's what you're measuring. The difference that will show is what a deliberate focus on “every code change must have a unit test” will have; test-driven development has that, and traditional programming methods don't.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1314959165.4771";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>133</wp:comment_id>
			<wp:comment_author><![CDATA[Anna Filina]]></wp:comment_author>
			<wp:comment_author_email>afilina@gmail.com</wp:comment_author_email>
			<wp:comment_author_url>http://annafilina.com</wp:comment_author_url>
			<wp:comment_author_IP>216.246.232.52</wp:comment_author_IP>
			<wp:comment_date>2011-09-02 05:24:36</wp:comment_date>
			<wp:comment_date_gmt>2011-09-02 12:24:36</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[&gt; Carefully controlling side effects

So you know exactly how a code change will impact your entire software? Are you able to go ahead and refactor (or even rewrite) a very important module and not introduce new bugs?

Also, please don't confuse TDD and automated tests in general. It's hard to use a drill as a chainsaw.

In TDD, you write your tests before you code, thus validating requirements. And the point is not to write as many tests as you can, but just enough to code with peace of mind, knowing that your code will work and do what the client asked for. TDD is a methodology, not a tool.

If TDD doesn't work for someone, then they need to get more experience in software development first. It works for 1-week and multi-year projects alike.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1314966276.9292";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>203</wp:comment_id>
			<wp:comment_author><![CDATA[Antoine]]></wp:comment_author>
			<wp:comment_author_email>antoine.roux@net-vitesse.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>89.83.85.11</wp:comment_author_IP>
			<wp:comment_date>2011-10-04 01:33:32</wp:comment_date>
			<wp:comment_date_gmt>2011-10-04 08:33:32</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[In my case, our team was using code review before we introduced TDD. I was measuring the number of bugs and features. It showed that there was a clear decrease in the number of bugs when using TDD (on top of code review).
This is definitely not a scientific study, and it applies only to my team, but I can tell that, in our case, it helped reduce the number of bugs.

One of the big benefits is that bugs do not happen again, which occured all the time in the past. On a short project, that is never an issue, but as soon as it is a few months long, the issue will arise.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1317717212.2046";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>200</wp:comment_id>
			<wp:comment_author><![CDATA[Nat Pryce]]></wp:comment_author>
			<wp:comment_author_email>nat.pryce@gmail.com</wp:comment_author_email>
			<wp:comment_author_url>http://natpryce.com</wp:comment_author_url>
			<wp:comment_author_IP>81.129.123.230</wp:comment_author_IP>
			<wp:comment_date>2011-10-03 05:11:04</wp:comment_date>
			<wp:comment_date_gmt>2011-10-03 12:11:04</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[It also seems to be comparing apples to oranges.  TDD is a technique for domain modelling and exploring design. As a happy side-effect, it produces a suite of automated regression tests.  In practice TDD is combined with inspection techniques, whether informal and continual such as pair programming, or formal code reviews and QA.

So to me it is surprising that, if we don't apply the (dubious) adjustment, a design technique that focuses on domain modelling produces as low a defect count as an inspection technique that is focusing on finding and eliminating defects.

That seems quite an endorsement for the TDD process.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>124</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1317643864.8112";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>1521</wp:comment_id>
			<wp:comment_author><![CDATA[Tony Mishler]]></wp:comment_author>
			<wp:comment_author_email>tony.mishler@gmail.com</wp:comment_author_email>
			<wp:comment_author_url>http://www.tonymishler.com</wp:comment_author_url>
			<wp:comment_author_IP>69.76.230.54</wp:comment_author_IP>
			<wp:comment_date>2012-07-14 11:25:06</wp:comment_date>
			<wp:comment_date_gmt>2012-07-14 18:25:06</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[I take issue with your claims.

1.) TDD is not required to ensure code is not broken by future testing. Automated testing? Sure, but TDD doesn't really help in that regard.

2.) TDD doesn't seem to be the best way of describing how an API is meant to be used. For one, the audience for any such descriptions would certainly be removed from your codebase, thus unable to glean anything for your unit test. For two, documentation is better suited for that task.

That's not to say there isn't a case for TDD in general. Different strokes for different folks. For me it feels a bit like putting the cart before the horse, but that's just me.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>119</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1342290306.7248";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
		<title>Don&#039;t Touch My Code!</title>
		<link>http://www.neverworkintheory.org/?p=142</link>
		<pubDate>Mon, 05 Sep 2011 21:21:16 +0000</pubDate>
		<dc:creator>gvwilson</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=142</guid>
		<description></description>
		<content:encoded><![CDATA[Christian Bird, Nachiappan Nagappan, Brendan Murphy, Harald Gall, and Premkumar Devanbu: <a href="http://www.cabird.com/papers/bird2011dtm.pdf">"Don't Touch My Code! Examining the Effects of Ownership on Software Quality."</a> ESEC/FSE'11, 2011.
<blockquote><em>Ownership is a key aspect of large-scale software development. We examine the relationship between different ownership measures and software failures in two large software projects: Windows Vista and Windows 7. We find that in all cases, measures of ownership such as the number of low-expertise developers, and the proportion of ownership for the top owner have a relationship with both pre-release faults and post-release failures. We also empirically identify reasons that low-expertise developers make changes to components and show that the removal of low-expertise contributions dramatically decreases the performance of contribution based defect prediction. Finally we provide recommendations for source code change policies and utilization of resources such as code inspections based on our results.</em></blockquote>
I used to tell my students that a paper's abstract should be a summary, not a movie trailer. When I read, "We find that... measures of ownership... have a relationship with both pre-release faults and post-release failures," my reaction is, "What kind of relationship?" And when a paper's authors say, "We... identify reasons that low-expertise developers make changes to components," I want to grab my red pen and scribble, "Summarize them here!"

Fortunately, this paper's abstract is the only thing about it that I don't like. Over the course of its 11 pages, its authors explore three related questions:
<ol>
	<li>Are higher levels of ownership associated with less defects?</li>
	<li>Is there a negative effect when a software entity is developed by many people with low ownership?</li>
	<li>Are these effects related to the development process used?</li>
</ol>
They start by defining their units of measurement (a compiled binary such as a .dll or .exe), what they mean by major and minor contributors, and how they measure ownership. After grinding their data (they have <em>lots</em> of data), they come up with Table 1:
<table border="1">
<tbody>
<tr>
<td colspan="2"></td>
<td colspan="2" align="center">Windows Vista</td>
<td colspan="2" align="center">Windows 7</td>
</tr>
<tr>
<td align="center">Category</td>
<td align="center">Metric</td>
<td align="center">Pre-release
Failures</td>
<td align="center">Post-Release
Failures</td>
<td align="center">Pre-release
Failures</td>
<td align="center">Post-Release
Failures</td>
</tr>
<tr>
<td rowspan="4" align="center">Ownership
Metrics</td>
<td align="center">Total</td>
<td align="center">0.84</td>
<td align="center">0.70</td>
<td align="center">0.92</td>
<td align="center">0.24</td>
</tr>
<tr>
<td align="center">Minor</td>
<td align="center">0.86</td>
<td align="center">0.70</td>
<td align="center">0.93</td>
<td align="center">0.25</td>
</tr>
<tr>
<td align="center">Major</td>
<td align="center">0.26</td>
<td align="center">0.29</td>
<td align="center">-0.40</td>
<td align="center">-0.14</td>
</tr>
<tr>
<td align="center">Ownership</td>
<td align="center">-0.49</td>
<td align="center">-0.49</td>
<td align="center">-0.29</td>
<td align="center">-0.02</td>
</tr>
<tr>
<td rowspan="3" align="center">"Classic"
Metrics</td>
<td align="center">Size</td>
<td align="center">0.75</td>
<td align="center">0.69</td>
<td align="center">0.70</td>
<td align="center">0.26</td>
</tr>
<tr>
<td align="center">Churn</td>
<td align="center">0.72</td>
<td align="center">0.69</td>
<td align="center">0.71</td>
<td align="center">0.26</td>
</tr>
<tr>
<td align="center">Complexity</td>
<td align="center">0.70</td>
<td align="center">0.53</td>
<td align="center">0.56</td>
<td align="center">0.37</td>
</tr>
<tr>
<td colspan="6" align="center"><em>Bivariate Spearman correlation of ownership and code metrics with pre- and post-release failures in Windows Vista and Windows 7.
All correlations are statistically significant except for that of Ownership and post-release failures in Windows 7.</em></td>
</tr>
</tbody>
</table>
("Total" stands for the total number of contributors, "Major" and "Minor" for the number of major and minor contributors, respectively, and "Ownership" for the proportion of ownership of the contributor with the highest proportion of ownership---how much a single person owns that piece of code.)

There's a lot of information in that table, and I won't try to squeeze it all into this blog post, but as a taste, it allows them to conclude that:
<blockquote><em>The results indicated that pre- and post-release defects in had strong relationships with Minor, Total, and Ownership. In fact, Minor had a higher correlation with both pre- and post-release defects in Vista and pre-release defects in Windows 7 than any other metric that Microsoft collects!. Post-release failures for Windows 7 present a difficulty for analysis as at the time of this analysis many binaries had no post-release failures reported. Thus the correlation values between metrics and and post-release failures are noticeably lower than the other failure categories...</em></blockquote>
Later, after teasing apart the contributions of major and minor contributors, and the effects of dependencies between components, they conclude that:
<blockquote><em>...the minor contribution edges [in the contributions graph] provide the "signal" used by defect predictors that are based on the contribution network. Without them, the ability to predict failure prone components is greatly diminished, further supporting our hypothesis that they are strongly related to software quality.</em></blockquote>
and:
<blockquote><em>After controlling for known software quality factors, binaries with more minor contributors had more pre- and post-release failures in both versions of Windows.</em></blockquote>
They then recommend that:
<ol>
	<li>Changes made by minor contributors should be reviewed with more scrutiny.</li>
	<li>Potential minor contributors should communicate desired changes to developers experienced with the respective binary.</li>
	<li>Components with low ownership should be given priority by QA resources.</li>
</ol>
Even if you can't apply their results directly to your own projects, they show that it is possible to analyze the impact of different software manufacturing practices methodically and quantitatively. The next time someone suggests that your team start doing X, Y, or Z, ask them if they have this kind of data to back up their recommendation. If they don't, you might consider giving them a copy of this paper...]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>142</wp:post_id>
		<wp:post_date>2011-09-05 14:21:16</wp:post_date>
		<wp:post_date_gmt>2011-09-05 21:21:16</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>dont-touch-my-code</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="code-ownership"><![CDATA[Code Ownership]]></category>
		<category domain="category" nicename="mining"><![CDATA[Mining]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>157</wp:comment_id>
			<wp:comment_author><![CDATA[Jamie]]></wp:comment_author>
			<wp:comment_author_email>jimbobdobson@gmail.com</wp:comment_author_email>
			<wp:comment_author_url>http://www.financialagile.com</wp:comment_author_url>
			<wp:comment_author_IP>195.27.217.250</wp:comment_author_IP>
			<wp:comment_date>2011-09-13 03:27:12</wp:comment_date>
			<wp:comment_date_gmt>2011-09-13 10:27:12</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Could they have also recommended that a software project don’t use minor contributors?  Could they recommend that each component should have an owner?

It seems to be that the research discovered what we might know instinctively.  A small tinkering of a component is likely to cause a problem because one might take for granted the web of dependencies.  We may more careful with a big change.  There’s something funny about that, the smaller the effort the more careless we will be, like quickly making a sandwich without washing our hands but washing them if we were preparing a dinner for ten.  That’s a bad habit, in software, doing anything quickly.

Thanks, I really enjoyed this piece.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:14:"1315909632.829";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
		<title>Does adding manpower also affect quality?</title>
		<link>http://www.neverworkintheory.org/?p=146</link>
		<pubDate>Tue, 06 Sep 2011 23:33:23 +0000</pubDate>
		<dc:creator>jorge</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=146</guid>
		<description></description>
		<content:encoded><![CDATA[<em><a href="http://www.se.rit.edu/~andy/">Andrew Meneely</a>, Pete Rotella, and <a href="http://collaboration.csc.ncsu.edu/laurie/">Laurie Williams</a>. <strong><a href="http://www.se.rit.edu/~andy/papers/esec126-meneely.pdf">"Does Adding Manpower Also Affect Quality? An Empirical, Longitudinal Analysis."</a></strong> ESEC/FSE 2011.</em>
<blockquote><em>With each new developer to a software development team comes a greater challenge to manage the communication, coordination, and knowledge transfer amongst teammates. Fred Brooks discusses this challenge in The Mythical Man-Month by arguing that rapid team expansion can lead to a complex team organization structure. While Brooks focuses on productivity loss as the negative outcome, poor product quality is also a substantial concern. But if team expansion is unavoidable, can any quality impacts be mitigated? Our objective is to guide software engineering managers by empirically analyzing the effects of team size, expansion, and structure on product quality. We performed an empirical, longitudinal case study of a large Cisco networking product over a five year history. Over that time, the team underwent periods of no expansion, steady expansion, and accelerated expansion. Using team-level metrics, we quantified characteristics of team expansion, including team size, expansion rate, expansion acceleration, and modularity with respect to department designations. We examined statistical correlations between our monthly team-level metrics and monthly product-level metrics. Our results indicate that <strong>increased team size and linear growth are correlated with later periods of better product quality</strong>. However, <strong>periods of accelerated team expansion are correlated with later periods of reduced software quality</strong>. Furthermore, our linear regression prediction model based on team metrics was able to predict the product's post-release failure rate within a 95% prediction interval for 38 out of 40 months. Our analysis provides insight for project managers into how the expansion of development teams can impact product quality.</em></blockquote>
If there's one "law" of software development that practitioners across the board have heard of, it has to be Brooks' Law: "adding manpower to a late project makes it later." This paper by Meneely &amp; Co. provides a good complement to Brooks' discussions. It does not concern itself with meeting deadlines, as Brooks did, but it explores the correlation between adding people to a team and the posterior quality of the software the team works on.

The paper reports that adding people is correlated with a later increase in software quality, but adding them too quickly (that is, at a faster pace than in previous months) is correlated with a <em>decrease</em> in quality. A greater organizational modularity is also associated with decreased quality.

I confess that I have trouble wrapping my head around the first of these findings. Theoretically, adding people to a project increases its coordination costs, which in turn should impact all metrics of team success negatively, including quality. And yet we have not only Meneely &amp; Co's findings, but also <a title="Our discussion of Mockus' organizational volatility paper" href="http://www.neverworkintheory.org/?p=17">last year's Mockus' report on organizational volatility</a> making the case that more newcomers are not correlated with more defects, which provides support to this finding. One possibility, discussed by Mockus, is that newcomers are assigned easy tasks, and so they can't really break things too dramatically or in a way that won't get caught internally in time. Another possibility, particularly plausible in the Cisco data set, is that the product has matured over time---that software quality would go up no matter the team size simply because there's less new functionality added as time goes on.

In any case, while we get better answers for the underlying mechanisms in the correlation between increasing team sizes and software quality, the best advice seems to be: it's OK to bring new people to a team (with respect to quality), just don't do it too quickly.]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>146</wp:post_id>
		<wp:post_date>2011-09-06 16:33:23</wp:post_date>
		<wp:post_date_gmt>2011-09-06 23:33:23</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>does-adding-manpower-also-affect-quality</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="mining"><![CDATA[Mining]]></category>
		<category domain="category" nicename="organizational-studies"><![CDATA[Organizational Studies]]></category>
		<category domain="category" nicename="quality"><![CDATA[Quality]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>144</wp:comment_id>
			<wp:comment_author><![CDATA[Laurent Bossavit]]></wp:comment_author>
			<wp:comment_author_email>laurent.git@bossavit.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>81.64.220.205</wp:comment_author_IP>
			<wp:comment_date>2011-09-07 02:26:01</wp:comment_date>
			<wp:comment_date_gmt>2011-09-07 09:26:01</wp:comment_date_gmt>
			<wp:comment_content><![CDATA["the best advice seems to be..."

Well... Just because one kind of change (linear or accelerated team growth) correlates well with another (steady or reduced quality), *and* one happens before the other, doesn't mean that one *causes* the other. I'd not jump from empirical observation straight to advice.

We need to ask first if there are confounding variables: for instance is there something that's likely to be a common cause of (first) accelerated increase in team size, then (later) a decline in quality? And with some experience in development we could think of several hypotheses. For instance, a change in management - someone newly put in charge of the team wants to "see some results fast".

Similarly there is no guarantee that if you make a modest increase in team size as a direct intervention, this is going to *cause* an increase in quality. At best the study weakly supports an argument that a modest increase in team size does not unduly increase the risk to quality. If that's what you were saying, we agree. :)

Even if we could somehow be sure that the relationship is causal within this team at Cisco, we can't know that the same relationship will hold elsewhere. To the authors' credit, the paper cites a lot of "related work" (though not the Mockus study you mentioned), but ISTM we rarely see actual replications of this sort of research: deliberate attempts at taking a previous result and seeing if it applies unchanged to a different context.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1315387561.5184";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>147</wp:comment_id>
			<wp:comment_author><![CDATA[Jorge Aranda]]></wp:comment_author>
			<wp:comment_author_email>jorge@neverworkintheory.org</wp:comment_author_email>
			<wp:comment_author_url>http://www.neverworkintheory.org/</wp:comment_author_url>
			<wp:comment_author_IP>24.68.65.123</wp:comment_author_IP>
			<wp:comment_date>2011-09-07 08:36:52</wp:comment_date>
			<wp:comment_date_gmt>2011-09-07 15:36:52</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Of course: the best advice in this case, as in most in our field, is loaded with uncertainty.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>144</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1315409812.9695";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:5:"jorge";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>158</wp:comment_id>
			<wp:comment_author><![CDATA[Jamie]]></wp:comment_author>
			<wp:comment_author_email>jimbobdobson@gmail.com</wp:comment_author_email>
			<wp:comment_author_url>http://www.financialagile.com</wp:comment_author_url>
			<wp:comment_author_IP>195.27.217.250</wp:comment_author_IP>
			<wp:comment_date>2011-09-13 03:41:31</wp:comment_date>
			<wp:comment_date_gmt>2011-09-13 10:41:31</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Another good piece.  Thanks.

You said ‘adding people to a project increases its coordination costs, which in turn should impact all metrics of team success negatively, including quality’.  Do you really believe that?  (I am sat here ponder what I believe.)  The first thing that springs to mind is huge projects, like the road network, that I am guessing is bogged down with bureaucracy and politics and huge coordination problems.  Nevertheless, I think that despite the huge cost/waste, I think the roads would be higher quality with a lot of ‘eyes on’.  (In the old days men sat along the railways ‘keeping an eye on them’.  The lack of these men were stated as a cause for the decreasing quality of the rail network here in the UK.)

But Laurent is right, let’s not jump to any conclusions too early.  But can I jump to a heuristic?  I think its best to go slow when developing software – if you must add, add slowly.  That does seem common sense.  People need to stew, to bond, and to bubble and froth.  From that froth comes software.

Once again, thought provoking.  Obviously I will now tell all my clients they should slowly increase their team sizes if they want to increase quality…]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:14:"1315910491.841";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>159</wp:comment_id>
			<wp:comment_author><![CDATA[Jorge Aranda]]></wp:comment_author>
			<wp:comment_author_email>jorge@neverworkintheory.org</wp:comment_author_email>
			<wp:comment_author_url>http://www.neverworkintheory.org/</wp:comment_author_url>
			<wp:comment_author_IP>24.68.65.123</wp:comment_author_IP>
			<wp:comment_date>2011-09-13 09:29:09</wp:comment_date>
			<wp:comment_date_gmt>2011-09-13 16:29:09</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[<blockquote>You said ‘adding people to a project increases its coordination costs, which in turn should impact all metrics of team success negatively, including quality’. Do you really believe that?</blockquote>

I do---it's one of the arguments I make in my PhD thesis, and although I didn't look specifically at quality I hypothesized that it would also be affected. This is one of the reasons why papers such as these are quite interesting to me.

But the problems of growth (should) have more to do with coordination dynamics than with sheer organizational size. For instance, if in your organizational structure you have "lots of eyes on," as you say, and those eyes mostly stay out of the way unless they spot a problem, and furthermore they don't add a significant cost to the organization (so that you do not need to sacrifice something else in order to have them), then you could have millions of people contributing without impinging on quality. This is presumably the case in many open source projects.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>158</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1315931349.7606";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:5:"jorge";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>185</wp:comment_id>
			<wp:comment_author><![CDATA[Chad Austin]]></wp:comment_author>
			<wp:comment_author_email>chad@imvu.com</wp:comment_author_email>
			<wp:comment_author_url>http://chadaustin.me</wp:comment_author_url>
			<wp:comment_author_IP>98.210.161.143</wp:comment_author_IP>
			<wp:comment_date>2011-09-26 01:33:53</wp:comment_date>
			<wp:comment_date_gmt>2011-09-26 08:33:53</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[One thing I've witnessed at IMVU is that new people in the organization, when added slowly, provide fresh perspective and energy, fixing bugs and code quality issues that others are immune to.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1317026033.4887";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
		<title>Proactive detection of collaboration conflicts</title>
		<link>http://www.neverworkintheory.org/?p=152</link>
		<pubDate>Wed, 14 Sep 2011 02:03:53 +0000</pubDate>
		<dc:creator>jorge</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=152</guid>
		<description></description>
		<content:encoded><![CDATA[<em><a href="http://www.cs.washington.edu/homes/brun/">Yuriy Brun</a>, <a href="http://www.cs.uwaterloo.ca/~rtholmes/">Reid Holmes</a>, <a href="http://www.cs.washington.edu/homes/mernst/">Michael D. Ernst</a>, and <a href="http://www.cs.washington.edu/homes/notkin/">David Notkin</a>. <strong><a href="http://www.cs.uwaterloo.ca/~rtholmes/papers/fse_2011_brun.pdf">"Proactive Detection of Collaboration Conflicts"</a></strong>, ESEC/FSE 2011.</em>
<blockquote><em>Collaborative development can be hampered when conﬂicts arise because developers have inconsistent copies of a shared project. We present an approach to help developers identify and resolve conﬂicts early, before those conﬂicts become severe and before relevant changes fade away in the developers’ memories. This paper presents three results.</em>

<em>First, a study of open-source systems establishes that conﬂicts are frequent, persistent, and appear not only as overlapping textual edits but also as subsequent build and test failures. The study spans nine open-source systems totaling 3.4 million lines of code; our conﬂict data is derived from 550,000 development versions of the systems.</em>

<em>Second, using previously-unexploited information, we precisely diagnose important classes of conﬂicts using the novel technique of speculative analysis over version control operations.</em>

<em>Third, we describe the design of Crystal, a publicly-available tool that uses speculative analysis to make concrete advice unobtrusively available to developers, helping them identify, manage, and prevent conﬂicts.</em></blockquote>
This paper provides a good new look at conflicts in version control repositories. Collaboration conflicts appear not just at the textual level (which current version control systems can spot and often help correct), but also when developers attempt to build or test the system. One of the paper's greatest strengths is that it shows how pervasive these conflicts are, and that in many cases appropriate tooling can help spot them and resolve them more efficiently. The authors also <a href="http://code.google.com/p/crystalvc/">present a tool</a> to showcase their conflict detection strategies, which seems to be at a better state than most research prototypes, but I can't vouch for it as I have not used it.]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>152</wp:post_id>
		<wp:post_date>2011-09-13 19:03:53</wp:post_date>
		<wp:post_date_gmt>2011-09-14 02:03:53</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>proactive-detection-of-collaboration-conflicts</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="mining"><![CDATA[Mining]]></category>
		<category domain="category" nicename="tools"><![CDATA[Tools]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>166</wp:comment_id>
			<wp:comment_author><![CDATA[Yuriy]]></wp:comment_author>
			<wp:comment_author_email>brun@cs.washington.edu</wp:comment_author_email>
			<wp:comment_author_url>http://www.cs.washington.edu/homes/brun/</wp:comment_author_url>
			<wp:comment_author_IP>128.208.4.54</wp:comment_author_IP>
			<wp:comment_date>2011-09-14 10:58:17</wp:comment_date>
			<wp:comment_date_gmt>2011-09-14 17:58:17</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[The main difference between Crystal and continuous integration (e.g., TeamCity CI server) is that Crystal attempts merging two developers' changes in the background long before they are ready to integrate the changes to the master.  Thus, Crystal will tell two developers about a conflict as soon as they create one.  Continuous integration servers only tell developers if their code conflicts with the master, which is often much later than when the conflict was first created.  (In the worst case in the empirical study study, the integration took place over a year after the conflict was created.)]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1316023097.5208";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>165</wp:comment_id>
			<wp:comment_author><![CDATA[Jorge Aranda]]></wp:comment_author>
			<wp:comment_author_email>jorge@neverworkintheory.org</wp:comment_author_email>
			<wp:comment_author_url>http://www.neverworkintheory.org/</wp:comment_author_url>
			<wp:comment_author_IP>24.68.65.123</wp:comment_author_IP>
			<wp:comment_date>2011-09-14 08:47:36</wp:comment_date>
			<wp:comment_date_gmt>2011-09-14 15:47:36</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Not quite, as I understand it. TeamCity seems to be testing against the main branch before committing, while the researchers here propose a speculative analysis: test against all the local working copies that interest you, on the fly.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>164</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1316015256.4064";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:5:"jorge";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>163</wp:comment_id>
			<wp:comment_author><![CDATA[David Notkin]]></wp:comment_author>
			<wp:comment_author_email>notkin@cs.washington.edu</wp:comment_author_email>
			<wp:comment_author_url>http://www.cs.washington.edu/homes/notkin</wp:comment_author_url>
			<wp:comment_author_IP>24.19.50.107</wp:comment_author_IP>
			<wp:comment_date>2011-09-13 19:08:41</wp:comment_date>
			<wp:comment_date_gmt>2011-09-14 02:08:41</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Downloads and more information available at crystalvc.googlecode.com]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1315966121.5511";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>164</wp:comment_id>
			<wp:comment_author><![CDATA[Laurent Bossavit]]></wp:comment_author>
			<wp:comment_author_email>laurent.git@bossavit.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>81.64.220.205</wp:comment_author_IP>
			<wp:comment_date>2011-09-14 06:25:49</wp:comment_date>
			<wp:comment_date_gmt>2011-09-14 13:25:49</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Isn't that very close to what the TeamCity CI server has been doing for a while now? ("Pre-tested commit".)

(Not to say that the empirical part of this isn't interesting - it looks very much worth checking out.)]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1316006749.7989";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>232</wp:comment_id>
			<wp:comment_author><![CDATA[Three Results, Many Definitions - It will never work in theory]]></wp:comment_author>
			<wp:comment_author_email></wp:comment_author_email>
			<wp:comment_author_url>http://www.neverworkintheory.org/?p=185</wp:comment_author_url>
			<wp:comment_author_IP>64.90.54.151</wp:comment_author_IP>
			<wp:comment_date>2011-10-22 07:48:42</wp:comment_date>
			<wp:comment_date_gmt>2011-10-22 14:48:42</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[[...] Software Engineering took place September 5-9 in Hungary. A lot of interesting work was presented, some of which we have already discussed. In today&#8217;s post we&#8217;d like to step back and look at something [...]]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type>pingback</wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319294922.4119";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
		<title>Variability and Reproducibility in Software Engineering: A Study of Four Companies that Developed the Same System</title>
		<link>http://www.neverworkintheory.org/?p=159</link>
		<pubDate>Thu, 22 Sep 2011 21:32:21 +0000</pubDate>
		<dc:creator>gvwilson</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=159</guid>
		<description></description>
		<content:encoded><![CDATA[<p>Bente C.D. Anda, Dag I.K. Sj&oslash;berg, and Audris Mockus: "Variability and Reproducibility in Software Engineering: A Study of Four Companies that Developed the Same System."  IEEE Transactions on Software Engineering, 35(3), May/June 2009.</p>

<blockquote><em>The scientific study of a phenomenon requires it to be reproducible. Mature engineering industries are recognized by projects and products that are, to some extent, reproducible. Yet, reproducibility in software engineering (SE) has not been investigated thoroughly, despite the fact that lack of reproducibility has both practical and scientific consequences. We report a longitudinal multiple-case study of variations and reproducibility in software development, from bidding to deployment, on the basis of the same requirement specification. In a call for tender to 81 companies, 35 responded. Four of them developed the system independently. The <u>firm price</u>, <u>planned schedule</u>, and <u>planned development process</u>, had, respectively, "low", "low", and "medium" reproducibilities. The contractor's <u>costs</u>, <u>actual lead time</u>, and <u>schedule overrun</u> of the projects had, respectively, "medium", "high", and "low" reproducibilities. The quality dimensions of the delivered products, <u>reliability</u>, <u>usability</u>, and <u>maintainability</u> had, respectively, "low", "high", and "low" reproducibilities. Moreover, variability for predictable reasons is also included in the notion of reproducibility. We found that the observed outcome of the four development projects matched our expectations, which were formulated partially on the basis of SE folklore. Nevertheless, achieving more reproducibility in SE remains a great challenge for SE research, education, and industry.</em></blockquote>

<p>Albert Einstein once defined insanity as, "Doing the same thing over and over again and expecting different results."  That's also a good definition of science: we repeat our experiments so that we can gather statistics about their outcomes, which in turn give us deeper insight into what the universe is doing.  This can be an expensive process&mdash;just look at the LHC, or at the cost of putting a probe into space, or the salaries of professional programmers.  As much as they'd like to, most researchers simply can't afford to have several teams develop the same software independently, just so that the differences in what they do can be studied.</p>

<p>That's what makes this paper so valuable.  As their abstract says, Anda, Sj&oslash;berg, and Mockus had four teams build the same software independently and in parallel so that they could look at how much variation there was in what happened.  Their results are worth re-summarizing:</p>

<ul>
  <li>High reproducibility: actual lead time, usability</li>
  <li>Medium reproducibility: planned development process, cost</li>
  <li>Low reproducibility: firm price, planned schedule, schedule overrun, reliability, maintainability</li>

</ul>

<p>Note that putting something in the "low" category doesn't mean that it was uniformly poor.  Instead, it means that there was wide variation, i.e., that results were unpredictable.  As they say, their results match software engineering folklore, and are a solid guide to what research should focus on improving.</p>

]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>159</wp:post_id>
		<wp:post_date>2011-09-22 14:32:21</wp:post_date>
		<wp:post_date_gmt>2011-09-22 21:32:21</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>variability-and-reproducibility-in-software-engineering-a-study-of-four-companies-that-developed-the-same-system</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="controlled-experiments"><![CDATA[Controlled Experiments]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>174</wp:comment_id>
			<wp:comment_author><![CDATA[Pattern-chaser]]></wp:comment_author>
			<wp:comment_author_email>noemail@mailinator.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>194.98.143.198</wp:comment_author_IP>
			<wp:comment_date>2011-09-23 02:19:28</wp:comment_date>
			<wp:comment_date_gmt>2011-09-23 09:19:28</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[The most depressing thing is that "reliability" and "maintainability" are at low, meaning the variation between the four teams is maximal. No project ever stands still. If you can't add new features, or find and fix bugs, easily, then you've failed. (IMO)]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1316769568.9729";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>180</wp:comment_id>
			<wp:comment_author><![CDATA[Retzev]]></wp:comment_author>
			<wp:comment_author_email>freshhawk@gmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>24.81.20.245</wp:comment_author_IP>
			<wp:comment_date>2011-09-24 16:35:32</wp:comment_date>
			<wp:comment_date_gmt>2011-09-24 23:35:32</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[My understanding of the decline effect is that it can be explained by a general increase in the quality of studies as different problem area specific causes of error are identified and more carefully controlled for. It's also expected that as you add more studies you'll get a regression to the mean effect as well, that's just simple statistics.

I'm not aware of anyone who has another hypothesis about the mechanism.

Most of the popularity of the term is due to proponents of pseudoscience to explain why high quality studies don't show any effects for acupuncture, homeopathy or the like.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>173</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1316907332.5305";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>173</wp:comment_id>
			<wp:comment_author><![CDATA[Satish]]></wp:comment_author>
			<wp:comment_author_email>satish@objectmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>180.151.57.242</wp:comment_author_IP>
			<wp:comment_date>2011-09-22 22:45:38</wp:comment_date>
			<wp:comment_date_gmt>2011-09-23 05:45:38</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[I think the fundamental point of the paper is still valid, but science is not immune to low reproducibility. There is increasing evidence of something called the "Decline Effect", where the effects of phenomena decline the more they are studied. And this is something that happens across a variety of different sciences. The NPR program "Radiolab" did a nice little podcast on this topic.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1316756738.6677";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>219</wp:comment_id>
			<wp:comment_author><![CDATA[Russell Johnston]]></wp:comment_author>
			<wp:comment_author_email>was173@gmail.com</wp:comment_author_email>
			<wp:comment_author_url>http://bestpaperairplanes.com</wp:comment_author_url>
			<wp:comment_author_IP>24.69.153.12</wp:comment_author_IP>
			<wp:comment_date>2011-10-15 21:18:35</wp:comment_date>
			<wp:comment_date_gmt>2011-10-16 04:18:35</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Following pattern-chasers thought, this does seem to be the key line:

"The quality dimensions of the delivered products, reliability, usability, and maintainability had, respectively, “low”, “high”, and “low” reproducibilities." 

What's so frightening is that usability is HIGHly predictable at the same time that reliability and usability (and price and schedule) are LOW for predictability. Which is to say that the usability of a system doesn't tell you anything about how well built it is. It's as if the fit and finish of a new car had nothing to do with whether the transmission would fall out when you tried to drive it off the lot.

Sure sounds to me as though those in charge (and those coding) might be chasing after the wrong things, in the wrong way. I think I might know what they ought to have their eye on, but that's another, longer post. Meanwhile, it's hard to imagine a more damning result.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1318738715.4469";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>207</wp:comment_id>
			<wp:comment_author><![CDATA[gvwilson]]></wp:comment_author>
			<wp:comment_author_email>gvwilson@third-bit.com</wp:comment_author_email>
			<wp:comment_author_url>http://third-bit.com/</wp:comment_author_url>
			<wp:comment_author_IP>173.33.251.2</wp:comment_author_IP>
			<wp:comment_date>2011-10-06 03:19:06</wp:comment_date>
			<wp:comment_date_gmt>2011-10-06 10:19:06</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Could you please post some of the links you found?]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>204</wp:comment_parent>
			<wp:comment_user_id>2</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1317896346.6834";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:8:"gvwilson";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>204</wp:comment_id>
			<wp:comment_author><![CDATA[F. Carr]]></wp:comment_author>
			<wp:comment_author_email>coldtortuga@gmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>74.125.59.113</wp:comment_author_IP>
			<wp:comment_date>2011-10-05 14:01:01</wp:comment_date>
			<wp:comment_date_gmt>2011-10-05 21:01:01</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[<em>I’m not aware of anyone who has another hypothesis about the mechanism.</em>
Wow, that is amazing.  I just did a bit of searching online and immediately found a dozen people who suggest other hypotheses.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>180</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1317848461.5409";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>221</wp:comment_id>
			<wp:comment_author><![CDATA[The impact of irrelevant and misleading information&#8230; - It will never work in theory]]></wp:comment_author>
			<wp:comment_author_email></wp:comment_author_email>
			<wp:comment_author_url>http://www.neverworkintheory.org/?p=177</wp:comment_author_url>
			<wp:comment_author_IP>64.90.54.151</wp:comment_author_IP>
			<wp:comment_date>2011-10-18 08:03:08</wp:comment_date>
			<wp:comment_date_gmt>2011-10-18 15:03:08</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[[...] result you avoid running toy experiments with half a dozen students and get instead, for instance, that paper on variability in software projects that Greg blogged about recently, where several companies were paid to develop the exact same software. Or this other paper. In it, [...]]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type>pingback</wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1318950188.7878";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
		<title>Experiences of Using Pair Programming in an Agile Project</title>
		<link>http://www.neverworkintheory.org/?p=168</link>
		<pubDate>Tue, 11 Oct 2011 16:00:28 +0000</pubDate>
		<dc:creator>jorge</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=168</guid>
		<description></description>
		<content:encoded><![CDATA[<em><a href="http://www.soberit.hut.fi/~jvanhane/">Jari Vanhanen</a> and Harri Korpi. <strong><a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.101.824&amp;rep=rep1&amp;type=pdf">"Experiences of Using Pair Programming in an Agile Project"</a></strong>, HICSS 2007.</em>
<blockquote><em>The interest in pair programming (PP) has increased recently, e.g. by the popularization of agile software development. However, many practicalities of PP are poorly understood. We present experiences of using PP extensively in an industrial project. The fact that the team had a limited number of high-end workstations forced it in a positive way to quick deployment and rigorous use of PP. The developers liked PP and learned it easily. Initially, the pairs were not rotated frequently but adopting daily, random rotation improved the situation. Frequent rotation seemed to improve knowledge transfer. The driver/navigator roles were switched seldom, but still the partners communicated actively. The navigator rarely spotted defects during coding, but the released code contained almost no defects. Test-driven development and design in pairs possibly decreased defects. The developers considered that PP improved quality and knowledge transfer, and was better suited for complex tasks than for easy tasks.</em></blockquote>
As with many other practices, one of the great challenges of studying pair programming is that running experiments under controlled conditions in the lab eliminates many of the factors that are supposed to make it work. Pair programming works best, the argument goes, if the programmers are familiar with the dynamic and with each other, and some of its benefits (such as better knowledge transfer and team morale) only become apparent after continued use.

It's no surprise, then, that <a title="See for instance my earlier post on a pair programming experiment" href="http://catenary.wordpress.com/2007/03/12/pair-programming-evaluated/">some of the best controlled experiments on pair programming that we have show poor productivity numbers</a> in comparison to solo programming. But researchers have also studied pair programming as it actually happens in real projects, and although the emerging picture is still not entirely clear, it is more favorable to pair programming than lab experiments would have it. An example is this paper by Vanhanen and Korpi, who report on the consequences of extensive use of the practice. With respect to productivity, they found that pair programming was better for complex tasks, though no match for solo programming on easy tasks. Other factors (quality, morale, knowledge sharing) were largely positive.

&nbsp;]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>168</wp:post_id>
		<wp:post_date>2011-10-11 09:00:28</wp:post_date>
		<wp:post_date_gmt>2011-10-11 16:00:28</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>experiences-of-using-pair-programming-in-an-agile-project</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="pair-programming"><![CDATA[Pair Programming]]></category>
		<category domain="category" nicename="qualitative-studies"><![CDATA[Qualitative Studies]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>The IROP paper</title>
		<link>http://www.neverworkintheory.org/?p=173</link>
		<pubDate>Tue, 11 Oct 2011 17:27:55 +0000</pubDate>
		<dc:creator>jorge</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=173</guid>
		<description></description>
		<content:encoded><![CDATA[<em>(Re-posted from my blog, <a href="http://catenary.wordpress.com/">Catenary</a> --Jorge Aranda)</em>

If you keep track of recent developments in empirical software engineering, you may have already heard of <a title="IROP page" href="http://www.st.cs.uni-saarland.de/softevo/irop/">the fantastic IROP study</a>. I was too busy writing a paper to blog about it when <a title="Andreas Zeller's page" href="http://www.st.cs.uni-saarland.de/zeller/">Andreas Zeller</a> presented it at PROMISE 2011, but here I go, in case you haven't read it.

Basically, Zeller, <a href="http://thomas-zimmermann.com/">Thomas Zimmermann</a>, and <a href="http://www.cabird.com/">Christian Bird</a> did what I'm afraid some researchers in our field do on a regular basis: take some mining tools and some data, and then go nuts with them---abuse of them in the most absurd ways imaginable. Luckily, Zeller, Zimmermann, and Bird did it <em>on purpose</em> and as <em>a parody</em>.

Here's what they did: take Eclipse data on code and errors, and correlate the two to find good predictors of bugs. Sounds sensible. But they did the correlation at the ASCII character level. So it turns out, for Eclipse 3.0, the characters that are most highly correlated with errors are the letters 'i', 'r', 'o', and 'p'. What is a sensible researcher to do facing these findings? Well take those letters out of the keyboard, of course! Problem solved:

<a href="http://catenary.files.wordpress.com/2011/10/irop-keyboard-4801.jpg"><img class="size-full wp-image-703 alignnone" title="The IROP keyboard" src="http://catenary.files.wordpress.com/2011/10/irop-keyboard-4801.jpg" alt="The IROP keyboard" width="480" height="360" /></a>

They then go over a supposed half-baked validation study with three interns, who reported great success in adapting to a life without 'i', 'r', 'o', and 'p' in their keyboards. Trial feedback:
<blockquote>We can shun these set majuscules, and the text stays just as swell as antecedently. Let us just ban them!</blockquote>
Near the end, the authors go over everything that's wrong with their approach (lack of theoretical grounding, dishonest use of statistics, and a long <em>et cetera</em>). It's a fun read, and instructive. Research, in general, needs more parodies. If you like this one, some of my other favourites are:
<ul>
	<li><em><a href="http://catenary.files.wordpress.com/2011/10/haley1969.pdf">The Art of Being a Failure as a Therapist</a> </em>(thanks to <a href="http://skoolr.blogspot.com/">Jon Pipitone</a> for finding it after we thought it was a futile endeavour!)</li>
	<li><em><a href="http://catenary.files.wordpress.com/2011/10/upper-1974-the-unsuccessful-self-treatment-of-a-case-of-writers-block.pdf">The Unsuccessful Self-Treatment of a Case of "Writer's Block"</a></em> (also via Jon)</li>
	<li>And our own paper of ill-conceived, impractical pie-in-the-sky research proposals, <em><a title="An older post about it" href="http://catenary.wordpress.com/2010/04/30/do-not-aim-for-the-eagle/">Aim for the Eagle</a></em>, which unfortunately was not always taken as a parody.</li>
</ul>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>173</wp:post_id>
		<wp:post_date>2011-10-11 10:27:55</wp:post_date>
		<wp:post_date_gmt>2011-10-11 17:27:55</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>the-irop-paper</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="meta"><![CDATA[Meta]]></category>
		<category domain="category" nicename="mining"><![CDATA[Mining]]></category>
		<category domain="category" nicename="noticed"><![CDATA[Noticed]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>211</wp:comment_id>
			<wp:comment_author><![CDATA[Laurent Bossavit]]></wp:comment_author>
			<wp:comment_author_email>laurent.git@bossavit.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>81.64.220.205</wp:comment_author_IP>
			<wp:comment_date>2011-10-11 22:13:13</wp:comment_date>
			<wp:comment_date_gmt>2011-10-12 05:13:13</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[My favorite parody paper: "Parachute use to prevent death and major trauma related to gravitational challenge: systematic review of randomised controlled trials"

See http://www.bmj.com/content/327/7429/1459.long]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1318396393.3337";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>212</wp:comment_id>
			<wp:comment_author><![CDATA[Jorge Aranda]]></wp:comment_author>
			<wp:comment_author_email>jorge@neverworkintheory.org</wp:comment_author_email>
			<wp:comment_author_url>http://www.neverworkintheory.org/</wp:comment_author_url>
			<wp:comment_author_IP>24.68.65.123</wp:comment_author_IP>
			<wp:comment_date>2011-10-12 07:17:24</wp:comment_date>
			<wp:comment_date_gmt>2011-10-12 14:17:24</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[I loved it---thanks for sharing!]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>211</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1318429044.3704";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:5:"jorge";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
		<title>The impact of irrelevant and misleading information...</title>
		<link>http://www.neverworkintheory.org/?p=177</link>
		<pubDate>Tue, 18 Oct 2011 15:00:26 +0000</pubDate>
		<dc:creator>jorge</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=177</guid>
		<description></description>
		<content:encoded><![CDATA[<em><a href="http://simula.no/people/magnej">Magne Jørgensen</a> and <a href="http://simula.no/people/steingr">Stein Grimstad</a>. <strong><a href="http://www.computer.org/portal/web/csdl/doi/10.1109/TSE.2010.78">The Impact of Irrelevant and Misleading Information on Software Development Effort Estimates: A Randomized Controlled Field Experiment</a>.</strong> TSE Sep/Oct 2011.</em>
<blockquote><em>Studies in laboratory settings report that software development effort estimates can be strongly affected by effort-irrelevant and misleading information. To increase our knowledge about the importance of these effects in field settings, we paid 46 outsourcing companies from various countries to estimate the required effort of the same five software development projects. The companies were allocated randomly to either the original requirement specification or a manipulated version of the original requirement specification. The manipulations were as follows: 1) reduced length of requirement specification with no change of content, 2) information about the low effort spent on the development of the old system to be replaced, 3) information about the client's unrealistic expectations about low cost, and 4) a restriction of a short development period with start up a few months ahead. We found that the effect sizes in the field settings were much smaller than those found for similar manipulations in laboratory settings. Our findings suggest that we should be careful about generalizing to field settings the effect sizes found in laboratory settings. While laboratory settings can be useful to demonstrate the existence of an effect and better understand it, field studies may be needed to study the size and importance of these effects.</em></blockquote>
The researchers from the SIMULA Lab in Norway do something pretty unique in our domain: use their research funds to pay lots of software professionals to do their thing in a setting as natural as possible, under conditions as controlled as possible. As a result you avoid running toy experiments with half a dozen students and get instead, for instance, <a href="http://www.neverworkintheory.org/?p=159">that paper on variability in software projects that Greg blogged about recently</a>, where several companies were paid to develop the exact same software. Or this other paper. In it, the researchers contact people in 46 companies and ask them to estimate the likely effort required to develop some software projects. However, they send slightly different descriptions of the projects to these companies, modifying them in "irrelevant and misleading" ways to see if that biases their estimates.

Several previous studies have tweaked project descriptions to see if the resulting estimates varied, and the overwhelming response is that yes, they do vary---estimators are subject to cognitive biases, like everyone else. What's interesting is that the authors here found that most of the effects were considerably <em>weaker</em> in their setting than those effects observed in previous studies "in the lab" (including, by the way, my own). In most cases the effects appear to be there, but they're often not strong enough to achieve statistical significance. They conclude:
<blockquote><em>While a meaningful role of laboratory experiments is to demonstrate the existence of an effect and understand its nature, we should be careful to base statements about the size, i.e., the importance of an effect on laboratory studies alone. For the purpose of establishing knowledge about the importance of an effect, we need field studies.</em></blockquote>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>177</wp:post_id>
		<wp:post_date>2011-10-18 08:00:26</wp:post_date>
		<wp:post_date_gmt>2011-10-18 15:00:26</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>the-impact-of-irrelevant-and-misleading-information</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="controlled-experiments"><![CDATA[Controlled Experiments]]></category>
		<category domain="category" nicename="estimation"><![CDATA[Estimation]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Announcement: Empirical Software Engineering at American Scientist</title>
		<link>http://www.neverworkintheory.org/?p=181</link>
		<pubDate>Wed, 19 Oct 2011 16:02:26 +0000</pubDate>
		<dc:creator>jorge</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=181</guid>
		<description></description>
		<content:encoded><![CDATA[A feature article on recent developments on empirical software engineering, by Greg Wilson and myself, has just been published in the November-December issue of <a href="http://www.americanscientist.org/">American Scientist</a>. Electronic version <a href="http://www.americanscientist.org/issues/id.13845,y.2011,no.6,content.true,page.1,css.print/issue.aspx">available here</a>. Thanks to Morgan Ryan, our editor at American Scientist, for all his help in preparing this piece!]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>181</wp:post_id>
		<wp:post_date>2011-10-19 09:02:26</wp:post_date>
		<wp:post_date_gmt>2011-10-19 16:02:26</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>announcement-empirical-software-engineering-at-american-scientist</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="announcements"><![CDATA[Announcements]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>226</wp:comment_id>
			<wp:comment_author><![CDATA[Empirical Software Engineering at American Scientist | Catenary]]></wp:comment_author>
			<wp:comment_author_email></wp:comment_author_email>
			<wp:comment_author_url>http://catenary.wordpress.com/2011/10/19/empirical-software-engineering-at-american-scientist/</wp:comment_author_url>
			<wp:comment_author_IP>74.200.247.247</wp:comment_author_IP>
			<wp:comment_date>2011-10-19 21:14:33</wp:comment_date>
			<wp:comment_date_gmt>2011-10-20 04:14:33</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[[...] (Crossposted from Never Work in Theory.) [...]]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type>pingback</wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319084073.2874";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>224</wp:comment_id>
			<wp:comment_author><![CDATA[Jorge Aranda]]></wp:comment_author>
			<wp:comment_author_email>jorge@neverworkintheory.org</wp:comment_author_email>
			<wp:comment_author_url>http://www.neverworkintheory.org/</wp:comment_author_url>
			<wp:comment_author_IP>198.134.88.79</wp:comment_author_IP>
			<wp:comment_date>2011-10-19 20:52:10</wp:comment_date>
			<wp:comment_date_gmt>2011-10-20 03:52:10</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Glad you liked it, Chris!]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>223</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319082730.9117";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:5:"jorge";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>223</wp:comment_id>
			<wp:comment_author><![CDATA[Chris Parnin]]></wp:comment_author>
			<wp:comment_author_email>gameweld@gmail.com</wp:comment_author_email>
			<wp:comment_author_url>http://blog.ninlabs.com</wp:comment_author_url>
			<wp:comment_author_IP>130.207.218.196</wp:comment_author_IP>
			<wp:comment_date>2011-10-19 10:52:09</wp:comment_date>
			<wp:comment_date_gmt>2011-10-19 17:52:09</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Honestly, this is one of the most refreshing pieces on software engineering in a long time :)]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319046729.6162";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>228</wp:comment_id>
			<wp:comment_author><![CDATA[David Notkin]]></wp:comment_author>
			<wp:comment_author_email>notkin@cs.washington.edu</wp:comment_author_email>
			<wp:comment_author_url>http://www.cs.washington.edu/homes/notkin</wp:comment_author_url>
			<wp:comment_author_IP>98.237.138.227</wp:comment_author_IP>
			<wp:comment_date>2011-10-20 08:14:20</wp:comment_date>
			<wp:comment_date_gmt>2011-10-20 15:14:20</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[With respect to SWEBOK, here is a report to the ACM Council from a committee I chaired.

http://www.cs.washington.edu/homes/notkin/bok_assessment.pdf]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319123661.0442";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>229</wp:comment_id>
			<wp:comment_author><![CDATA[Jorge Aranda]]></wp:comment_author>
			<wp:comment_author_email>jorge@neverworkintheory.org</wp:comment_author_email>
			<wp:comment_author_url>http://www.neverworkintheory.org/</wp:comment_author_url>
			<wp:comment_author_IP>142.104.21.214</wp:comment_author_IP>
			<wp:comment_date>2011-10-20 13:11:49</wp:comment_date>
			<wp:comment_date_gmt>2011-10-20 20:11:49</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Thanks. I enjoyed reading it, David, and I'm reassured that the opinion of Greg and myself seems to match the recommendations from your committee.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>228</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319141509.8044";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:5:"jorge";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>233</wp:comment_id>
			<wp:comment_author><![CDATA[Three Results, Many Definitions - It will never work in theory]]></wp:comment_author>
			<wp:comment_author_email></wp:comment_author_email>
			<wp:comment_author_url>http://www.neverworkintheory.org/?p=185</wp:comment_author_url>
			<wp:comment_author_IP>64.90.54.151</wp:comment_author_IP>
			<wp:comment_date>2011-10-22 11:22:19</wp:comment_date>
			<wp:comment_date_gmt>2011-10-22 18:22:19</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[[...] to base our measures, and more experience to tell which measures are most useful. As we said in our American Scientst article, this is all part of how a new scientific field goes about defining itself. It&#8217;s also [...]]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type>pingback</wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319307740.8931";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
		<title>Three Results, Many Definitions</title>
		<link>http://www.neverworkintheory.org/?p=185</link>
		<pubDate>Sat, 22 Oct 2011 14:48:36 +0000</pubDate>
		<dc:creator>gvwilson</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=185</guid>
		<description></description>
		<content:encoded><![CDATA[The <a href="http://2011.esec-fse.org/">joint meeting</a> of the European Software Engineering Conference and the ACM SIGSOFT Symposium on the Foundations of Software Engineering took place September 5-9 in Hungary. A lot of interesting work was presented, <a href="http://www.neverworkintheory.org/?p=152">some of which</a> we have already discussed. In today's post we'd like to step back and look at something that many papers had in common. The three we will use as examples are:
<ol>
	<li><a href="http://www.uni-trier.de/index.php?id=26135">Fabian Beck</a> and <a href="http://www.st.uni-trier.de/~diehl/">Stephan Diehl</a>: <a href="http://www.st.uni-trier.de/~diehl/pubs/esecfse11.pdf">"On the Congruence of Modularity and Code Coupling"</a>.
<blockquote><em>Software systems are modularized to make their inherent complexity manageable. While there exists a set of well-known principles that may guide software engineers to design the modules of a software system, we do not know which principles are followed in practice. In a study based on 16 open source projects, we look at different kinds of coupling concepts between source code entities, including structural dependencies, fan-out similarity, evolutionary coupling, code ownership, code clones, and semantic similarity. The congruence between these coupling concepts and the modularization of the system hints at the modularity principles used in practice. Furthermore, the results provide insights on how to support developers to modularize software systems.</em></blockquote>
More simply, the authors compared measures of <em>coupling</em> (the degree of connectivity between classes) and <em>modularity</em> (how those classes are packaged together). One conclusion is that different ways of measuring coupling really do measure different things: only a few correlate with each other. Another is that the relationship between coupling and modularity is roughly the same across a spectrum of package types (data, event handling, graphics, I/O, etc.).</li>
	<li><a href="http://seal.ifi.uzh.ch/giger/">Emanuel Giger</a>, <a href="http://seal.ifi.uzh.ch/pinzger">Martin Pinzger</a>, and <a href="http://seal.ifi.uzh.ch/gall">Harald Gall</a>: <a href="http://swerl.tudelft.nl/twiki/pub/Main/TechnicalReports/TUD-SERG-2011-018.pdf">"Using the Gini Coefficient for Bug Prediction in Eclipse"</a>.
<blockquote><em>The Gini coefficient is a prominent measure to quantify the inequality of a distribution. It is often used in the field of economy to describe how goods, e.g., wealth or farmland, are distributed among people. We use the Gini coefficient to measure code ownership by investigating how changes made to source code are distributed among the developer population. The results of our study with data from the Eclipse platform show that less bugs can be expected if a large share of all changes are accumulated, i.e., carried out, by relatively few developers.</em></blockquote>
The <a href="http://en.wikipedia.org/wiki/Gini_coefficient">Gini coefficient</a> is a simple, intuitively-appealing measure of (in)equality that can be applied in many different contexts. (I once required students in a software engineering class to explain why we should or shouldn't use it to divide marks between team members based on lines of code committed.) This paper uses it to measure code ownership, then compares it to bug rates, and finds that modules with clear "owners" have fewer bugs.</li>
	<li><a href="http://bigfoot.cs.upt.ro/~cristina/">Cristina Marinescu</a>: "Are the Classes that Use Exceptions Defect Prone?"
<blockquote><em>Exception handling is a mechanism that highlights exceptional functionality of software systems. Currently many empirical studies point out that sometimes developers neglect exceptional functionality, minimizing its importance. In this paper we investigate if the design entities (classes) that use exceptions are more defect prone than the other classes. The results, based on analyzing three releases of Eclipse, show that indeed the classes that use exceptions are more defect prone than the other classes. Based on our results, developers are advertised to pay more attention to the way they handle exceptions.</em></blockquote>
Are some language features more fragile than others? In this paper, Marinescu looks at the correlation between use of exceptions and bug rates on a class-by-class basis, and answers the question with a qualified "yes".</li>
</ol>
These papers are all interesting in their own right, but what they and others have in common is equally interesting. In each, the authors have had to invent ways of measuring things, or borrow (and explain) one of several alternative ways. It's as if every physicist had to decide that momentum was an interesting concept, define exactly what <em>they</em> meant by it (since other scientists might be using slightly different definitions), and then explain to readers how they went about measuring it just to ensure there was no ambiguity. It takes a lot of time, effort, and mental energy, but it will continue to be necessary until we have stronger theories of software engineering on which to base our measures, and more experience to tell which measures are most useful. As we said in our <a href="http://www.neverworkintheory.org/?p=181"><em>American Scientst</em></a> article, this is all part of how a new scientific field goes about defining itself. It's also a lot of fun...]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>185</wp:post_id>
		<wp:post_date>2011-10-22 07:48:36</wp:post_date>
		<wp:post_date_gmt>2011-10-22 14:48:36</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>three-results-many-definitions</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="code-ownership"><![CDATA[Code Ownership]]></category>
		<category domain="category" nicename="metrics"><![CDATA[Metrics]]></category>
		<category domain="category" nicename="quantitative-studies"><![CDATA[Quantitative Studies]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>234</wp:comment_id>
			<wp:comment_author><![CDATA[Three Empirical Studies From ESEC/FSE&#8217;11 - It will never work in theory]]></wp:comment_author>
			<wp:comment_author_email></wp:comment_author_email>
			<wp:comment_author_url>http://www.neverworkintheory.org/?p=188</wp:comment_author_url>
			<wp:comment_author_IP>64.90.54.151</wp:comment_author_IP>
			<wp:comment_date>2011-10-22 11:32:20</wp:comment_date>
			<wp:comment_date_gmt>2011-10-22 18:32:20</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[[...] our previous post said, a lot of interesting work was presented at the joint ECSE/FSE conference in September. Three [...]]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type>pingback</wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319308340.0675";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>238</wp:comment_id>
			<wp:comment_author><![CDATA[Fabian Beck]]></wp:comment_author>
			<wp:comment_author_email>beckf@uni-trier.de</wp:comment_author_email>
			<wp:comment_author_url>http://www.st.uni-trier.de/~beck/</wp:comment_author_url>
			<wp:comment_author_IP>84.166.32.58</wp:comment_author_IP>
			<wp:comment_date>2011-10-23 22:54:58</wp:comment_date>
			<wp:comment_date_gmt>2011-10-24 05:54:58</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[I totally agree that we are spending, and will have to spend much effort in discussing our measures. But I would compare the situation rather to psychology and the social sciences than to physics. While I feel the measures in physics are often quite obvious (force, power, velocity, etc.), they are much more ambiguous in, for instance, psychology: How to measure happiness, motivation, fear etc.?

Perhaps we can learn from these research areas that study the human being much more than from natural sciences. Unlike computer science, the social sciences have a much stronger background in empirical research of the kind that was recently also conducted in software engineering. In particular, we may come across ideas how to deal with our measures more efficiently.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319435698.9132";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
		<title>Software Requirements Change Taxonomy: Evaluation by Case Study</title>
		<link>http://www.neverworkintheory.org/?p=165</link>
		<pubDate>Fri, 28 Oct 2011 21:32:20 +0000</pubDate>
		<dc:creator>neil</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=165</guid>
		<description></description>
		<content:encoded><![CDATA[Sharon McGee and <a href="http://www.cs.qub.ac.uk/~Des.Greer/">Des Greer</a>, "<a href="http://www.cs.qub.ac.uk/~Des.Greer/McGeeGreer4.2.pdf">Software Requirements Change Taxonomy: Evaluation by Case Study</a>", International Conference on Requirements Engineering, Trento, Italy, September 2011.
<div>
<div>
<div>
<blockquote>Although a number of requirements change classifications have been proposed in the literature, there is no empirical assessment of their practical value in terms of their capacity to inform change monitoring and management. This paper describes an investigation of the informative efficacy of a taxonomy of requirements change sources which distinguishes between changes arising from ‘market’, ‘organisation’, ‘project vision’, ‘specification’ and ‘solution’. This investigation was effected through a case study where change data was recorded over a 16 month period covering the development lifecycle of a government sector software application. While insufficiency of data precluded an investigation of changes arising due to the change source of ‘market’, for the remainder of the change sources, results indicate a significant difference in cost, value to the customer and management considerations. Findings show that higher cost and value changes arose more often from ‘organisation’ and ‘vision’ sources; these changes also generally involved the co-operation of more stakeholder groups and were considered to be less controllable than changes arising from the ‘specification’ or ‘solution‘ sources. Overall, the results suggest that monitoring and measuring change using this classification is a practical means to support change management, understanding and risk visibility.</blockquote>
Many people have considered how best to classify requirements changes: for example, <a href="http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=324847">Harker</a> (pdf) or <a href="http://epress.lib.uts.edu.au/research/bitstream/handle/10453/2701/2004001825.pdf?sequence=1">Zowghi</a> (pdf). In this paper, the authors conducted a single case study to understand whether their taxonomy could not only capture the various changes which occurred during an industrial software development project, but also whether such a classification could help with project management concerns.

It is a well-worn truth that changes in requirements can be very expensive to fix later in the project. However, one of the things that is typically not considered is the opportunity that a change affords. We tend to focus on the negative, but as McGee demonstrates during her case study, these changes are a key part of business strategy.

In particular, the highest-value/highest-cost changes came from the strategic, organization level, and the lowest-value/lowest-cost changes to the system from the detail-oriented, solution implementation level. The classification of change origins provides evidence that the context of the change is important in understanding how to manage that change.

During her research presentation, Sharon McGee also commented on the challenges of this type of research. While valuable, the organization she embedded with found the research process time-consuming. She doubted they would be willing to undergo a follow-up study. This is a major barrier to obtaining case study opportunities that go beyond the anecdotal.

</div>
</div>
</div>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>165</wp:post_id>
		<wp:post_date>2011-10-28 14:32:20</wp:post_date>
		<wp:post_date_gmt>2011-10-28 21:32:20</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>software-requirements-change-taxonomy-evaluation-by-case-study</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="organizational-studies"><![CDATA[Organizational Studies]]></category>
		<category domain="category" nicename="qualitative-studies"><![CDATA[Qualitative Studies]]></category>
		<category domain="post_tag" nicename="requirements"><![CDATA[requirements]]></category>
		<category domain="category" nicename="uncategorized"><![CDATA[Uncategorized]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[3]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Three Empirical Studies From ESEC/FSE&#039;11</title>
		<link>http://www.neverworkintheory.org/?p=188</link>
		<pubDate>Sat, 22 Oct 2011 16:36:00 +0000</pubDate>
		<dc:creator>gvwilson</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=188</guid>
		<description></description>
		<content:encoded><![CDATA[As our <a href="http://www.neverworkintheory.org/?p=185">previous post</a> said, a lot of interesting work was presented at the <a href="http://2011.esec-fse.org/">joint ECSE/FSE conference</a> in September. Three of my favorites reporting empirical studies are:
<ol>
	<li>Sven Appel, <a href="http://www.infosun.fim.uni-passau.de/cl/staff/liebig/">Jörg Liebeg</a>, and <a href="http://www.uni-marburg.de/fb12/ps/team/kaestner?language_sync=1">Christian Kästner</a>: <a href="http://www.infosun.fim.uni-passau.de/cl/publications/docs/FSE2011.pdf">"Semistructured Merge: Rethinking Merge in Revision Control Systems"</a>.
<blockquote><em>An ongoing problem in revision control systems is how to resolve conflicts in a merge of independently developed revisions. Unstructured revision control systems are purely text-based and solve conflicts based on textual similarity. Structured revision control systems are tailored to specific languages and use language-specific knowledge for conflict resolution. We propose semistructured revision control systems that inherit the strengths of both: the generality of unstructured systems and the expressiveness of structured systems. The idea is to provide structural information of the underlying software artifacts — declaratively, in the form of annotated grammars. This way, a wide variety of languages can be supported and the information provided can assist in the automatic resolution of two classes of conflicts: ordering conflicts and semantic conflicts. The former can be resolved independently of the language and the latter using specific conflict handlers. We have been developing a tool that supports semistructured merge and conducted an empirical study on 24 software projects developed in Java, C#, and Python comprising 180 merge scenarios. We found that semistructured merge reduces the number of conflicts in 60% of the sample merge scenarios by, on average, 34%, compared to unstructured merge. We found also that renaming is challenging in that it can increase the number of conflicts during semistructured merge, and that a combination of unstructured and semistructured merge is a pragmatic way to go.</em></blockquote>
Almost all version control systems treat files as lines of text, ignoring whatever program structure they contain. The few that diff and merge at the logical level only work that way, and are usually only available as part of all-or-nothing programming environments. In this paper, the authors look at a hybrid approach that tries to combine the good features of both pure alternatives. The tool itself is interesting, but I was equally interested in the empirical study they did to see how much of a difference they were making. That study told them that when their tool underperformed, it was most often because it couldn't handle renamings well, which in turn tells them what they need to work on next.</li>
	<li><a href="http://www4.ncsu.edu/~apmeneel/index.html">Andrew Meneely</a>, Pete Rotella, and <a href="http://collaboration.csc.ncsu.edu/laurie/">Laurie Williams</a>: <a href="http://www.se.rit.edu/~andy/papers/esec126-meneely.pdf">"Does Adding Manpower Also Affect Quality? An Empirical Longitudinal Analysis"</a>.
<blockquote><em>With each new developer to a software development team comes a greater challenge to manage the communication, coordination, and knowledge transfer amongst teammates. Fred Brooks discusses this challenge in <em>The Mythical Man-Month</em> by arguing that rapid team expansion can lead to a complex team organization structure. While Brooks focuses on productivity loss as the negative outcome, poor product quality is also a substantial concern. But if team expansion is unavoidable, can any quality impacts be mitigated? Our objective is to guide software engineering managers by empirically analyzing the effects of team size, expansion, and structure on product quality. We performed an empirical, longitudinal case study of a large Cisco networking product over a five year history. Over that time, the team underwent periods of no expansion, steady expansion, and accelerated expansion. Using team-level metrics, we quantified characteristics of team expansion, including team size, expansion rate, expansion acceleration, and modularity with respect to department designations. We examined statistical correlations between our monthly team-level metrics and monthly productlevel metrics. Our results indicate that increased team size and linear growth are correlated with later periods of better product quality. However, periods of accelerated team expansion are correlated with later periods of reduced software quality. Furthermore, our linear regression prediction model based on team metrics was able to predict the productâ€™s post-release failure rate within a 95% prediction interval for 38 out of 40 months. Our analysis provides insight for project managers into how the expansion of development teams can impact product quality.</em></blockquote>
<em>The Mythical Man-Month</em> is the most-quoted book in software engineering. Here, the authors test its central claim by looking at what effect expanding a development team has on downstream fault rates; in particular, they look at how the <em>rate</em> of team expansion correlates with defects later on. Their finding is that growth on its own doesn't hurt quality: it's rapid growth that causes problems.</li>
	<li><a href="http://opera.ucsd.edu/~zyin2/">Zuoning Yin</a>, <a href="http://www.cs.uiuc.edu/homes/dyuan3/Home.html">Ding Yuan</a>, <a href="http://cseweb.ucsd.edu/~yyzhou/">Yuanyuan Zhou</a>, Shankar Pasupathy, and <a href="http://pages.cs.wisc.edu/~laksh/">Lakshmi Bairavasundaram</a>: <a href="http://opera.ucsd.edu/~zyin2/fse11.pdf">"How Do Fixes Become Bugs?"</a>
<blockquote><em>This paper presents a comprehensive characteristic study on incorrect bug-fixes from large operating system code bases including Linux, OpenSolaris, FreeBSD and also a mature commercial OS developed and evolved over the last 12 years, investigating not only the mistake patterns during bug-fixing but also the possible human reasons in the development process when these incorrect bug-fixes were introduced. Our major findings include: (1) at least 14.8%âˆ¼24.4% of sampled fixes for post-release bugs 1 in these large OSes are incorrect and have made impacts to end users. (2) Among several common bug types, concurrency bugs are the most difficult to fix correctly: 39% of concurrency bug fixes are incorrect. (3) Developers and reviewers for incorrect fixes usually do not have enough knowledge about the involved code. For example, 27% of the incorrect fixes are made by developers who have never touched the source code files associated with the fix. Our results provide useful guidelines to design new tools and also to improve the development process. Based on our findings, the commercial software vendor whose OS code we evaluated is building a tool to improve the bug fixing and code reviewing process.</em></blockquote>
This paper's starting point is something every seasoned developer knows: bug fixes are often buggy themselves. But how buggy? And are fixes for some kinds of bugs more error-prone than others? This papers examines 12 years of data from four operating systems to produce the statistics and recommendations summarized in the abstract. (Not surprisingly, concurrency and memory-management bugs are the hardest ones to fix correctly.) Given that testing and code review resources are always in short supply, this kind of information can help teams focus their efforts where they'll do the most good.</li>
</ol>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>188</wp:post_id>
		<wp:post_date>2011-10-22 09:36:00</wp:post_date>
		<wp:post_date_gmt>2011-10-22 16:36:00</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>three-empirical-studies-from-esecfse11</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="quality"><![CDATA[Quality]]></category>
		<category domain="category" nicename="quantitative-studies"><![CDATA[Quantitative Studies]]></category>
		<category domain="category" nicename="tools"><![CDATA[Tools]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>277</wp:comment_id>
			<wp:comment_author><![CDATA[Andy Meneely]]></wp:comment_author>
			<wp:comment_author_email>andy@se.rit.edu</wp:comment_author_email>
			<wp:comment_author_url>http://www.se.rit.edu/~andy</wp:comment_author_url>
			<wp:comment_author_IP>129.21.218.76</wp:comment_author_IP>
			<wp:comment_date>2011-10-25 08:29:12</wp:comment_date>
			<wp:comment_date_gmt>2011-10-25 15:29:12</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Well I have to say that I'm honored to be mentioned here! I just discovered this blog and I see you've mentioned my work in other posts as well. It's always encouraging to see people discuss my studies. 

I thought we had a particularly good year for empirical studies at FSE. I especially thought that third paper on regressions was a good one.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319556552.4855";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>759</wp:comment_id>
			<wp:comment_author><![CDATA[Greg Wilson]]></wp:comment_author>
			<wp:comment_author_email>gvwilson@third-bit.com</wp:comment_author_email>
			<wp:comment_author_url>http://third-bit.com</wp:comment_author_url>
			<wp:comment_author_IP>173.33.251.2</wp:comment_author_IP>
			<wp:comment_date>2012-01-01 06:32:20</wp:comment_date>
			<wp:comment_date_gmt>2012-01-01 14:32:20</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[@zedware That's an interesting hypothesis --- do you have any data on how often it's the case?]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>758</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1325428340.7201";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>758</wp:comment_id>
			<wp:comment_author><![CDATA[zedware]]></wp:comment_author>
			<wp:comment_author_email>zedware@gmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>114.250.181.83</wp:comment_author_IP>
			<wp:comment_date>2012-01-01 00:19:29</wp:comment_date>
			<wp:comment_date_gmt>2012-01-01 08:19:29</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[How Do Fixes Become Bugs? 
In practice, developers unfamiliar with the source code are often asked to do the fixes. This can save the company costs, and this may due to the lack of experienced programmers, and this may due to the fact that many programmers are reluctant to do bug fixes.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:14:"1325405970.177";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
		<title>An Empirical Comparison of the Accuracy Rates of Novices using the Quorum, Perl, and Randomo Programming Languages</title>
		<link>http://www.neverworkintheory.org/?p=197</link>
		<pubDate>Mon, 24 Oct 2011 18:45:35 +0000</pubDate>
		<dc:creator>gvwilson</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=197</guid>
		<description></description>
		<content:encoded><![CDATA[<a href="http://www.cs.siue.edu/~astefik/index.php">Andreas Stefik</a>, Susanna Siebert, Melissa Stefik, and Kim Slattery: <a href="http://ecs.victoria.ac.nz/twiki/pub/Events/PLATEAU/Program/plateau2011-stefik.pdf">An Empirical Comparison of the Accuracy Rates of Novices using the Quorum, Perl, and Randomo Programming Languages</a>. <em><a href="http://ecs.victoria.ac.nz/Events/PLATEAU/WebHome#Evaluation_and_Usability_of_Prog">PLATEAU 2011</a></em>.



<blockquote>
  <em>We present here an empirical study comparing the accuracy rates of novices writing software in three programming languages: Quorum, Perl, and Randomo. The first language, Quorum, we call an evidence-based programming language, where the syntax, semantics, and API designs change in correspondence to the latest academic research and literature on programming language usability. Second, while Perl is well known, we call Randomo a Placebo-language, where some of the syntax was chosen with a random number generator and the ASCII table. We compared novices that were programming for the first time using each of these languages, testing how accurately they could write simple programs using common program constructs (e.g., loops, conditionals, functions, variables, parameters). Results showed that while Quorum users were afforded significantly greater accuracy compared to those using Perl and Randomo, Perl users were unable to write programs more accurately than those using a language designed by chance.</em>


</blockquote>

In the early 1990s, when I was teaching parallel programming to scientists, I discovered very quickly that they found some programming systems much easier to learn than others. Data parallelism and Linda's tuple spaces? They could get something working in half an hour. Message passing? It took hours to get as far. When Brent Gorda and I started teaching software engineering to scientists a few years later at <a href="http://lanl.gov">Los Alamos National Laboratory</a>, we initially used Perl; after switching to Python, we found that it only took two days to cover material that had previously taken three, and that students seemed to remember it better weeks or months later.



But everyone has stories like that about their favorite programming language. Haskell's fans swear that strong typing makes all the difference, while fans of Scheme are wont to claim that strong typing is for people with weak memories. If anything deserves empirical study (if only to put such claims to rest), it's this. That's why I enjoyed this paper so much. It isn't just their finding that novices using Perl were no more likely to write a correct program than novices using a language whose syntax was generated randomly (although I did smile quite broadly when I read that). This paper's real contribution is to show that such studies are possible—that we can and should put such claims to the test, just as Rossbach et al. did for <a href="http://www.neverworkintheory.org/?p=122">transactional programming</a>.


]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>197</wp:post_id>
		<wp:post_date>2011-10-24 11:45:35</wp:post_date>
		<wp:post_date_gmt>2011-10-24 18:45:35</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>an-empirical-comparison-of-the-accuracy-rates-of-novices-using-the-quorum-perl-and-randomo-programming-languages</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="controlled-experiments"><![CDATA[Controlled Experiments]]></category>
		<category domain="category" nicename="programming-languages"><![CDATA[Programming Languages]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>256</wp:comment_id>
			<wp:comment_author><![CDATA[Christian Walde]]></wp:comment_author>
			<wp:comment_author_email>walde.christian@googlemail.com</wp:comment_author_email>
			<wp:comment_author_url>http://cat.eatsmou.se</wp:comment_author_url>
			<wp:comment_author_IP>188.108.143.251</wp:comment_author_IP>
			<wp:comment_date>2011-10-25 00:55:08</wp:comment_date>
			<wp:comment_date_gmt>2011-10-25 07:55:08</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[This study is entirely useless because they invalidated themselves from the start by providing the worst possible Perl examples they could. I quote the salient parts:

&gt; participants were given a code sample worksheet for the particular language group they were in. The general idea of the experiment is to give novice users code samples similarly to if a participant was learning to program from home on the Internet.
&gt; 
&gt; This code shows one of the code samples provided to participants.

    $x = &amp;z(1, 100, 3);

    sub z{
        $a = $ [0];
        $b = $ [1];
        $c = $ [2];
        $d = 0.0;
        $e = 0.0;
        for ($i = $a; $i  $e) {
            $d;
        }
        else {
            $e;
        }
    }

If all their perl samples looked like that it should not be a surprise to *anyone* that their test subjects were entirely confounded. What is missing in that paper is a description of how they actually sourced their code samples, as well as a list of *all* code samples provided.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319529308.2425";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>254</wp:comment_id>
			<wp:comment_author><![CDATA[anonymous]]></wp:comment_author>
			<wp:comment_author_email>anon@anon.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>108.46.227.21</wp:comment_author_IP>
			<wp:comment_date>2011-10-24 23:09:06</wp:comment_date>
			<wp:comment_date_gmt>2011-10-25 06:09:06</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[This is exactly where you start to question the authority of the people coming up with this. No referred journal of any repute... <em>[snip... no anonymous personal attacks on this site, please. --Greg]</em>]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>253</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319522946.3076";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>253</wp:comment_id>
			<wp:comment_author><![CDATA[Marco Lopes]]></wp:comment_author>
			<wp:comment_author_email>mlopes.nospam@gmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>81.97.216.140</wp:comment_author_IP>
			<wp:comment_date>2011-10-24 23:01:58</wp:comment_date>
			<wp:comment_date_gmt>2011-10-25 06:01:58</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[I don't really get the point here. Perl is not aimed to use in teaching programming and it has a fairly steep learning curve. Even for developer with a few years experience on other languages, learning Perl can take a couple of weeks, and mastering it takes year, it is not expected for someone to just get there and starts writing good code.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319522518.3907";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>263</wp:comment_id>
			<wp:comment_author><![CDATA[gvwilson]]></wp:comment_author>
			<wp:comment_author_email>gvwilson@third-bit.com</wp:comment_author_email>
			<wp:comment_author_url>http://third-bit.com/</wp:comment_author_url>
			<wp:comment_author_IP>70.67.35.51</wp:comment_author_IP>
			<wp:comment_date>2011-10-25 04:34:22</wp:comment_date>
			<wp:comment_date_gmt>2011-10-25 11:34:22</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[1. What's your basis for saying it's <em>too small</em> a sample?  I agree it's a <em>small</em> sample, but that's not the same thing.
2. My "subjective feelings about Perl" are the same as my subjective feelings about English spelling, common law, and every other human endeavor; none of them have any bearing on the accuracy (or otherwise) of this paper's conclusions.
3. As I replied elsewhere, <a href="http://www.mi.fu-berlin.de/w/Main/LutzPrechelt" rel="nofollow">Lutz Prechelt</a> has been doing some interesting working that compares programming languages in the hands of experts. I'm still puzzled why this entire line of research died out in the 1980s after what seemed to be a promising start...
4. We're using WordPress as a blogging platform; I'll look into why it's not marking required fields in comments --- thanks for reporting the problem.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>255</wp:comment_parent>
			<wp:comment_user_id>2</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319542462.8314";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:8:"gvwilson";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>255</wp:comment_id>
			<wp:comment_author><![CDATA[Aaron Trevena]]></wp:comment_author>
			<wp:comment_author_email>aaron.trevena@gmail.com</wp:comment_author_email>
			<wp:comment_author_url>http://www.aarontrevena.co.uk</wp:comment_author_url>
			<wp:comment_author_IP>212.159.78.14</wp:comment_author_IP>
			<wp:comment_date>2011-10-24 23:29:20</wp:comment_date>
			<wp:comment_date_gmt>2011-10-25 06:29:20</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[So it was a too small sample, with a poor implementation (2 made up languages, against 1 real one), and you only noticed a couple of lines that suited your own subjective feelings about perl.. that's a pretty lame blog post about some sub-mediocre research - you're sounding like yet another Python zealot with a chip on their shoulder.

I'd love to see some research into programming language design and it's actual impact on human error when writing it, but both the blog post and the research are pretty poor indeed.

ps, usually you mark required fields in a form, and show the errors alongside the submitted content - can't you find a better blog tool?]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319524160.9016";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>252</wp:comment_id>
			<wp:comment_author><![CDATA[anonymous]]></wp:comment_author>
			<wp:comment_author_email>anon@anon.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>108.46.227.21</wp:comment_author_IP>
			<wp:comment_date>2011-10-24 22:41:00</wp:comment_date>
			<wp:comment_date_gmt>2011-10-25 05:41:00</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[The whole thing is statistically insignificant and uses bad methodology not to mention there is no point to the exercise - comparing 3 languages (2 of which are made up) for one time novice use. Programming is a skill that has to be cultivated over time. A wise man once said make things as simple as possible but not simpler. This is akin to taking 18 art history majors and trying to explain general relativity to them and basing that as the effectiveness of a graduate physics seminar.

Ignoring all of that the small sample space is insignificant. Using just 1 actual language is a bad idea. That is likely true even if you put something like Ruby in the mix. Perl is a particularly bad idea because it was designed to for easy of use at the expense of a steep learning curve. Not to mention they are not using idiomatic perl and obsolete syntax.

Also, that random noise is not turning complete so the whole argument goes out of the window because you it's not the same thing.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>248</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319521260.5347";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>266</wp:comment_id>
			<wp:comment_author><![CDATA[Christian Walde]]></wp:comment_author>
			<wp:comment_author_email>walde.christian@googlemail.com</wp:comment_author_email>
			<wp:comment_author_url>http://cat.eatsmou.se</wp:comment_author_url>
			<wp:comment_author_IP>85.158.179.66</wp:comment_author_IP>
			<wp:comment_date>2011-10-25 04:40:51</wp:comment_date>
			<wp:comment_date_gmt>2011-10-25 11:40:51</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[There have been plenty just in this post's responses and i've already contacted the author.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>265</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319542851.0429";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>267</wp:comment_id>
			<wp:comment_author><![CDATA[Christian Walde]]></wp:comment_author>
			<wp:comment_author_email>walde.christian@googlemail.com</wp:comment_author_email>
			<wp:comment_author_url>http://cat.eatsmou.se</wp:comment_author_url>
			<wp:comment_author_IP>85.158.179.66</wp:comment_author_IP>
			<wp:comment_date>2011-10-25 04:46:03</wp:comment_date>
			<wp:comment_date_gmt>2011-10-25 11:46:03</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Novices might write like that, yes, but that is beside the issue. The pasted bit is supposedly representative of what a person learning Perl from the internet would find in way of examples and was meant to teach the test subjects perl.

However, as mentioned, it's the worst imaginable Perl, and furthermore, if i google for "learn perl", i find this first: http://learn.perl.org/

And it doesn't look anything like that example.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>264</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319543163.4901";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>249</wp:comment_id>
			<wp:comment_author><![CDATA[t. roll]]></wp:comment_author>
			<wp:comment_author_email>_____@bugoffanddie.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>207.102.131.80</wp:comment_author_IP>
			<wp:comment_date>2011-10-24 21:15:47</wp:comment_date>
			<wp:comment_date_gmt>2011-10-25 04:15:47</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[perl?  doesn't ring a bell.  oh wait, it's a dead language, like latin, right?  does anybody still use it?
*ducks*]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319516147.9185";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>241</wp:comment_id>
			<wp:comment_author><![CDATA[Anonymous]]></wp:comment_author>
			<wp:comment_author_email>Anonymous@spam.la</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>213.41.130.35</wp:comment_author_IP>
			<wp:comment_date>2011-10-24 13:35:57</wp:comment_date>
			<wp:comment_date_gmt>2011-10-24 20:35:57</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[You can't really draw any conclusions from their idea of teaching perl.

If you look at their perl code snippets they seemed to used Perl4 or worse. It reads like someone like who has never ever used perl before and maybe hits up tom's script archive.

First off they call a subroutine z with an ampersand (&amp;) . No you don't do this anymore since Perl4.

Second $a to $c initializations are non-idiomatic and borked. my ($a,$b,$c) = @_; is enough.

Third, use strict. Or lack there of. It's like static typing, but really just a dictionary.

Perl has a lot of ways of doing things, but these are serious perl violations that remove important information from the students.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319488557.6706";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>242</wp:comment_id>
			<wp:comment_author><![CDATA[gvwilson]]></wp:comment_author>
			<wp:comment_author_email>gvwilson@third-bit.com</wp:comment_author_email>
			<wp:comment_author_url>http://third-bit.com/</wp:comment_author_url>
			<wp:comment_author_IP>70.67.35.51</wp:comment_author_IP>
			<wp:comment_date>2011-10-24 13:51:41</wp:comment_date>
			<wp:comment_date_gmt>2011-10-24 20:51:41</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Thank you for the feedback, but I'm curious: why post anonymously?  Nothing you have said seems likely to endanger your personal safety or livelihood...]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>241</wp:comment_parent>
			<wp:comment_user_id>2</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319489501.6697";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:8:"gvwilson";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>243</wp:comment_id>
			<wp:comment_author><![CDATA[Another Anonymous]]></wp:comment_author>
			<wp:comment_author_email>another@anonymous.com</wp:comment_author_email>
			<wp:comment_author_url>http://www.asd.com</wp:comment_author_url>
			<wp:comment_author_IP>115.70.220.178</wp:comment_author_IP>
			<wp:comment_date>2011-10-24 16:39:57</wp:comment_date>
			<wp:comment_date_gmt>2011-10-24 23:39:57</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Because many people don't want everything they say to be stored in perpetuity, searchable and attributable to them - no matter how innocuous.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>242</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319499597.3104";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>244</wp:comment_id>
			<wp:comment_author><![CDATA[Peter J. Hart]]></wp:comment_author>
			<wp:comment_author_email>peter@peterjhart.com</wp:comment_author_email>
			<wp:comment_author_url>http://peterjhart.com</wp:comment_author_url>
			<wp:comment_author_IP>72.215.204.133</wp:comment_author_IP>
			<wp:comment_date>2011-10-24 16:59:17</wp:comment_date>
			<wp:comment_date_gmt>2011-10-24 23:59:17</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Since I looked it up: the study was done with 18 participants.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319500757.6048";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>245</wp:comment_id>
			<wp:comment_author><![CDATA[Jason Baker]]></wp:comment_author>
			<wp:comment_author_email>amnorvend@gmail.com</wp:comment_author_email>
			<wp:comment_author_url>http://jasonmbaker.com</wp:comment_author_url>
			<wp:comment_author_IP>173.228.44.48</wp:comment_author_IP>
			<wp:comment_date>2011-10-24 17:13:50</wp:comment_date>
			<wp:comment_date_gmt>2011-10-25 00:13:50</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[I am absolutely pro-empiricism when it comes to these kinds of subjects.  But there are limits to what can be learned via studies.  At a certain point, we just have to admit that some decisions boil down to preference and gut instinct, and there isn't necessarily anything wrong with that.

I think that this falls in that area, or at least is close to it.  Just as with any other psychological study, there are plenty of questions left unanswered:  What happens if you get experienced programmers to do this study?  What are those programmers experienced in?  What happens if you give the people involved in this study a different problem to solve (such as text processing, which Perl was designed for)?  Which will lead to better error rates in a large programming project (which you're not going to be able to convince anyone to use a randomly-generated language for)?]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319501630.6608";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>246</wp:comment_id>
			<wp:comment_author><![CDATA[Freddy Junior]]></wp:comment_author>
			<wp:comment_author_email>freddy@mailinator.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>203.122.244.217</wp:comment_author_IP>
			<wp:comment_date>2011-10-24 18:08:47</wp:comment_date>
			<wp:comment_date_gmt>2011-10-25 01:08:47</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[The conclusion in this paper is a bit misleading: "Perl users were unable to write 
programs more accurately than those using a language designed with syntax chosen randomly from the ASCII table."  If you look at the actual results graph in Figure 3 - the results for Perl users is halfway between Quorum and Randomo.  Perl users do do better than Randomo users, but not statistically significantly better.  What this means is that for the small sample size you have taken, the error margin is such, that you have not proven that Perl is easier to use than Randomo.  But this does not prove that it is no better.  Judging on the results from the small sample, the the sample size were expanded, it probably would be proven that Perl is better than a random language (although not as good as Quorum.)  Incidentally, by the same graphs in figure 3, while Quorum is statistically significantly better than Randomo, it is not statistically significantly better than Perl.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319504928.2027";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>247</wp:comment_id>
			<wp:comment_author><![CDATA[Scott]]></wp:comment_author>
			<wp:comment_author_email>whiskey@rum.net</wp:comment_author_email>
			<wp:comment_author_url>http://www.rum.net</wp:comment_author_url>
			<wp:comment_author_IP>131.107.0.84</wp:comment_author_IP>
			<wp:comment_date>2011-10-24 19:01:03</wp:comment_date>
			<wp:comment_date_gmt>2011-10-25 02:01:03</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[I think there is a real future in Randomo. The potential for expressive, bug-free programs is great.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319508064.0004";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>248</wp:comment_id>
			<wp:comment_author><![CDATA[anonymous]]></wp:comment_author>
			<wp:comment_author_email>anon@anon.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>108.46.227.21</wp:comment_author_IP>
			<wp:comment_date>2011-10-24 19:45:31</wp:comment_date>
			<wp:comment_date_gmt>2011-10-25 02:45:31</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[What shoddy science... <em>[snip... no personal attacks on this site, please. And if you want to heap scorn on researchers, the least you could do is sign your invective. --Jorge]</em>]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319510731.6349";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>268</wp:comment_id>
			<wp:comment_author><![CDATA[gvwilson]]></wp:comment_author>
			<wp:comment_author_email>gvwilson@third-bit.com</wp:comment_author_email>
			<wp:comment_author_url>http://third-bit.com/</wp:comment_author_url>
			<wp:comment_author_IP>70.67.35.51</wp:comment_author_IP>
			<wp:comment_date>2011-10-25 04:50:53</wp:comment_date>
			<wp:comment_date_gmt>2011-10-25 11:50:53</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Thanks --- so far, only <a href="http://www.neverworkintheory.org/?p=197#comment-246" rel="nofollow">one comment</a> that I've read has offered specifics, and in the end, specifics is what science relies on.  For example, saying "the sample size is too small" is meaningless on its own ("too small" compared to what?).  On the other hand, it is fair to say that the code samples are not representative of what novices would find on the web to learn from (as you've done in another comment), because you've backed that up by comparing their Perl to what shows up at the top of a Google query.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>266</wp:comment_parent>
			<wp:comment_user_id>2</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:14:"1319543453.416";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:8:"gvwilson";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>258</wp:comment_id>
			<wp:comment_author><![CDATA[Glyph]]></wp:comment_author>
			<wp:comment_author_email>glyph@twistedmatrix.com</wp:comment_author_email>
			<wp:comment_author_url>http://glyph.twistedmatrix.com</wp:comment_author_url>
			<wp:comment_author_IP>67.186.132.109</wp:comment_author_IP>
			<wp:comment_date>2011-10-25 02:32:13</wp:comment_date>
			<wp:comment_date_gmt>2011-10-25 09:32:13</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Do you have an empirical study that indicates when we should trust our gut instinct over empirical studies?]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>245</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319535134.1255";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>259</wp:comment_id>
			<wp:comment_author><![CDATA[Chris Parnin]]></wp:comment_author>
			<wp:comment_author_email>gameweld@gmail.com</wp:comment_author_email>
			<wp:comment_author_url>http://blog.ninlabs.com</wp:comment_author_url>
			<wp:comment_author_IP>99.172.18.21</wp:comment_author_IP>
			<wp:comment_date>2011-10-25 03:42:04</wp:comment_date>
			<wp:comment_date_gmt>2011-10-25 10:42:04</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Remember all, this paper was published at a workshop on programming language design and evaluation, not Science or Nature!  This is something that would launch a series of more rigorous and mixed methods of study.  No single paper is ever the final word.  Each one is only a point in a tapestry of research.

Get with it folks!]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319539324.6827";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>260</wp:comment_id>
			<wp:comment_author><![CDATA[Christian Walde]]></wp:comment_author>
			<wp:comment_author_email>walde.christian@googlemail.com</wp:comment_author_email>
			<wp:comment_author_url>http://cat.eatsmou.se</wp:comment_author_url>
			<wp:comment_author_IP>85.158.179.66</wp:comment_author_IP>
			<wp:comment_date>2011-10-25 03:52:26</wp:comment_date>
			<wp:comment_date_gmt>2011-10-25 10:52:26</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[They already said in the paper that they plan to do more studies "using the same procedures". Which would mean they're going to make a lot more useless studies because the produres are fundamentally flawed.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>259</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319539946.2148";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>261</wp:comment_id>
			<wp:comment_author><![CDATA[gvwilson]]></wp:comment_author>
			<wp:comment_author_email>gvwilson@third-bit.com</wp:comment_author_email>
			<wp:comment_author_url>http://third-bit.com/</wp:comment_author_url>
			<wp:comment_author_IP>70.67.35.51</wp:comment_author_IP>
			<wp:comment_date>2011-10-25 04:23:27</wp:comment_date>
			<wp:comment_date_gmt>2011-10-25 11:23:27</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[1. They have taken the time to describe their statistics and methodology; please take a few moments to describe the specific flaws.
2. Yes, programming is a skill that has to be cultivated over time, but they are (explicitly) studying what happens before it has been: the word "novices" is in the paper's title.
3. It's "Turing" complete, not "turning" complete.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>252</wp:comment_parent>
			<wp:comment_user_id>2</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319541807.1929";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:8:"gvwilson";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>262</wp:comment_id>
			<wp:comment_author><![CDATA[gvwilson]]></wp:comment_author>
			<wp:comment_author_email>gvwilson@third-bit.com</wp:comment_author_email>
			<wp:comment_author_url>http://third-bit.com/</wp:comment_author_url>
			<wp:comment_author_IP>70.67.35.51</wp:comment_author_IP>
			<wp:comment_date>2011-10-25 04:25:28</wp:comment_date>
			<wp:comment_date_gmt>2011-10-25 11:25:28</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Usability in the hands of experts is an interesting question, but it's not the one they set out to answer: they are explicitly looking at usability in the hands of novices. As other work has shown (see for example Guzdial's research at Georgia Tech), this is important for retention: if something "just doesn't work", learners become discouraged and stop learning.  Lutz Prechelt has done some interesting studies of the relative usability of languages in expert hands; see <a href="http://www.mi.fu-berlin.de/w/Main/LutzPrechelt" rel="nofollow">his site</a> for links.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>253</wp:comment_parent>
			<wp:comment_user_id>2</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319541929.4821";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:8:"gvwilson";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>264</wp:comment_id>
			<wp:comment_author><![CDATA[gvwilson]]></wp:comment_author>
			<wp:comment_author_email>gvwilson@third-bit.com</wp:comment_author_email>
			<wp:comment_author_url>http://third-bit.com/</wp:comment_author_url>
			<wp:comment_author_IP>70.67.35.51</wp:comment_author_IP>
			<wp:comment_date>2011-10-25 04:37:05</wp:comment_date>
			<wp:comment_date_gmt>2011-10-25 11:37:05</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Having taught programming for 20-odd years, I can confirm (with a heavy sigh) that their samples actually are representative of what novices write. In any language.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>256</wp:comment_parent>
			<wp:comment_user_id>2</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319542625.0229";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:8:"gvwilson";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>265</wp:comment_id>
			<wp:comment_author><![CDATA[gvwilson]]></wp:comment_author>
			<wp:comment_author_email>gvwilson@third-bit.com</wp:comment_author_email>
			<wp:comment_author_url>http://third-bit.com/</wp:comment_author_url>
			<wp:comment_author_IP>70.67.35.51</wp:comment_author_IP>
			<wp:comment_date>2011-10-25 04:38:38</wp:comment_date>
			<wp:comment_date_gmt>2011-10-25 11:38:38</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Can you point out those "fundamental flaws" so that the authors can improve their methods the next time around? That's how science works, and crowd-sourcing discussion of those kinds of improvements is part of what we hope this site will accomplish.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>260</wp:comment_parent>
			<wp:comment_user_id>2</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319542718.5229";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:8:"gvwilson";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>269</wp:comment_id>
			<wp:comment_author><![CDATA[Charles Keepax]]></wp:comment_author>
			<wp:comment_author_email>ckeepax@gmail.com</wp:comment_author_email>
			<wp:comment_author_url>http://www.charles-keepax.co.uk/</wp:comment_author_url>
			<wp:comment_author_IP>217.36.223.180</wp:comment_author_IP>
			<wp:comment_date>2011-10-25 05:59:06</wp:comment_date>
			<wp:comment_date_gmt>2011-10-25 12:59:06</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[It's an interesting study but the result is hardly surprising, it seems to me that the paper is looking at the learn curve associated with with various languages. I mean it feels rather intuitive that some languages will be easier to pick up than others. And on that note Perl is hardly known as an easy to learn language; don't get me wrong I actually quite like Perl, but the syntax can be a little full of crazy symbols at the best of times. I guess it is always good to back up intuition with actual research.

I would have thought a more interesting question would be to look at if you can reduce the learning curve of a language and maintain the expressibility. And I would actually love to see comparison error rates for languages being used by long term users of said languages, could it be shown that some languages are actually more likely to produce correct code? I would wager that it can, was this not one of the primary design goals of Haskell? And there in lies the issue that I think has caused some friction here, a lot of the wording of the paper alludes to showing that one language is generally more likely to produce correct code than another. Whilst they are careful to not say so directly it is easy to interpret it this way.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319547546.0709";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>270</wp:comment_id>
			<wp:comment_author><![CDATA[Darrin Thompson]]></wp:comment_author>
			<wp:comment_author_email>darrinth@gmail.com</wp:comment_author_email>
			<wp:comment_author_url>http://willowbend.cx/</wp:comment_author_url>
			<wp:comment_author_IP>207.250.96.104</wp:comment_author_IP>
			<wp:comment_date>2011-10-25 06:46:26</wp:comment_date>
			<wp:comment_date_gmt>2011-10-25 13:46:26</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[When making decisions I refer to a number of hand picked unwritten small sample observational studies.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>258</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319550386.2699";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>271</wp:comment_id>
			<wp:comment_author><![CDATA[gvwilson]]></wp:comment_author>
			<wp:comment_author_email>gvwilson@third-bit.com</wp:comment_author_email>
			<wp:comment_author_url>http://third-bit.com/</wp:comment_author_url>
			<wp:comment_author_IP>70.67.35.51</wp:comment_author_IP>
			<wp:comment_date>2011-10-25 06:57:50</wp:comment_date>
			<wp:comment_date_gmt>2011-10-25 13:57:50</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Substantive criticism of the study's methodology and claims would be more helpful than sarcasm, but if you are willing to put your name to the latter, we will let it stand.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>270</wp:comment_parent>
			<wp:comment_user_id>2</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319551070.9724";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:8:"gvwilson";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>272</wp:comment_id>
			<wp:comment_author><![CDATA[Peter Makholm]]></wp:comment_author>
			<wp:comment_author_email>peter@makholm.net</wp:comment_author_email>
			<wp:comment_author_url>http://peter.makholm.net/</wp:comment_author_url>
			<wp:comment_author_IP>46.30.211.1</wp:comment_author_IP>
			<wp:comment_date>2011-10-25 07:08:41</wp:comment_date>
			<wp:comment_date_gmt>2011-10-25 14:08:41</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Let me paraphrase Brian Kernighans "Why Pascal is not my Favorite Programming Language":

"Comparing Perl and Quorum is rather like comparing a Learjet to a Piper Cub - one is meant for getting something done while the other is meant for learning - so such comparisons tend to be somewhat farfetched."]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319551722.0642";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>273</wp:comment_id>
			<wp:comment_author><![CDATA[Darrin Thompson]]></wp:comment_author>
			<wp:comment_author_email>darrinth@gmail.com</wp:comment_author_email>
			<wp:comment_author_url>http://willowbend.cx/</wp:comment_author_url>
			<wp:comment_author_IP>207.250.96.104</wp:comment_author_IP>
			<wp:comment_date>2011-10-25 07:10:55</wp:comment_date>
			<wp:comment_date_gmt>2011-10-25 14:10:55</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[If I was a researcher I'd study usability by looking for a way to count programmer "attempts" and the development time invested in individual attempts at solving the problem at hand.

I remain a Haskell fan because I think I have observed in myself that in Haskell I need fewer attempts to solve problems and the feedback cycle is very fast.

I'd like to see those two measurements isolated against 3 language features:

1. Haskell-y type inference
2. Controlled mutation
3. Purity

My hypothesis would be that the sophisticated type inference is helpful in speeding up the feedback mechanism (compiler finds more errors) but the overall development time benefit if it exists is driven by controlled mutation and to a lesser extent purity.

I came up with this model from observing that the Haskell community is unusually "happy" compared to other language communities. I thought that was just due to better than usual management until I noticed the same thing in the Clojure community also. That made me wonder if some aspect of the language was causing the happieness. Since controlled mutation is something that they have in common and is mostly unique to just these two languages, it makes me think that controlled mutation is a driver of programmer happiness.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319551855.9864";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>274</wp:comment_id>
			<wp:comment_author><![CDATA[Aaron Trevena]]></wp:comment_author>
			<wp:comment_author_email>aaron.trevena@gmail.com</wp:comment_author_email>
			<wp:comment_author_url>http://www.aarontrevena.co.uk</wp:comment_author_url>
			<wp:comment_author_IP>212.159.78.14</wp:comment_author_IP>
			<wp:comment_date>2011-10-25 08:18:26</wp:comment_date>
			<wp:comment_date_gmt>2011-10-25 15:18:26</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[It's too small a sample because both fake languages are within or close to the margin of error either side of the perl results.

The bigger, glaring faults in the paper are that it's comparing an industrial "general purpose" language to a fake language designed for novices, and specifically the kind of lightweight "hello world" exersizes used; it's also made the "random" language c-like by using C syntax like braces, etc and adding some random noise and unhelpful function names.

I'm not even sure what conclusion you can draw from it after all that - "C based languages are difficult for non-programmers" perhaps, but then that's startlingly novel in much the same way as the Pope being Catholic or bears relieving themselves in the woods.

I'm guessing if it was any of C derived language, such as C++, Ruby or PHP it would fare worse, but you wouldn't have included the snarky asides - Python could possibly have even done worse - I haven't seen any evidence that indenting would make more sense to non-programmers than braces, and would probably lead to more mistakes than the BEGIN/END stuff]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>263</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319555906.6281";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>275</wp:comment_id>
			<wp:comment_author><![CDATA[Timur Shtatland]]></wp:comment_author>
			<wp:comment_author_email>t.shtatland+neverwork@gmail.com</wp:comment_author_email>
			<wp:comment_author_url>http://ksvetu.blogspot.com/</wp:comment_author_url>
			<wp:comment_author_IP>96.45.129.2</wp:comment_author_IP>
			<wp:comment_date>2011-10-25 08:18:52</wp:comment_date>
			<wp:comment_date_gmt>2011-10-25 15:18:52</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Thanks! That’s an interesting study. Perl definitely needs to become more novice-friendly.
But novice programmers constitute only a part of all programmers. For the rest of the programmers, studies showed that Perl is not so bad.
http://page.mi.fu-berlin.de/prechelt/Biblio//jccpprtTR.pdf
I can speculate that Perl’s strengths are due to tools like regexes, map, grep, eval, etc, and thousands of CPAN modules, which make it easier to accomplish many tasks with fewer elementary statements than other languages. I bet novice programmers did not have a chance to take advantage of these tools, and this explains the results. Plus the study used short tasks, which biases it towards easier tools available in any language (such as 'for', 'if', '=', '+'). Perl’s design of these is not that much better than any other language.
For more on the effect of elementary statements on productivity, see:
http://ksvetu.blogspot.com/2011/05/frederick-p-brooks-mythical-man-month.html]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319555932.9951";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319556265.0318";s:7:"message";s:47:"gvwilson changed the comment status to approved";s:5:"event";s:15:"status-approved";s:4:"user";s:8:"gvwilson";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>276</wp:comment_id>
			<wp:comment_author><![CDATA[Avi Greenbury]]></wp:comment_author>
			<wp:comment_author_email>ialoneambest@gmail.com</wp:comment_author_email>
			<wp:comment_author_url>http://avi.co</wp:comment_author_url>
			<wp:comment_author_IP>80.87.128.54</wp:comment_author_IP>
			<wp:comment_date>2011-10-25 08:21:18</wp:comment_date>
			<wp:comment_date_gmt>2011-10-25 15:21:18</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[It's not so useless if the point was to emulate "learning to program from home on the Internet" - the general standard of Perl tutorials on the net is pretty poor, and perhaps part of the reason I *still* occasionally party^W code like it's 1999.

That does look like a particularly contrived poorly-writen and overcomplicated bit of code, though.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>256</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319556078.5112";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>278</wp:comment_id>
			<wp:comment_author><![CDATA[Aaron Trevena]]></wp:comment_author>
			<wp:comment_author_email>aaron.trevena@gmail.com</wp:comment_author_email>
			<wp:comment_author_url>http://www.aarontrevena.co.uk</wp:comment_author_url>
			<wp:comment_author_IP>212.159.78.14</wp:comment_author_IP>
			<wp:comment_date>2011-10-25 09:40:17</wp:comment_date>
			<wp:comment_date_gmt>2011-10-25 16:40:17</wp:comment_date_gmt>
			<wp:comment_content><![CDATA["could fare worse" not "would fare worse"

It's a shame because it could have provided some evidence of what novice programmers actually struggle with (rather than what they say, which can be both unreliable and vague to be of use) - that could then help improve mentoring of junior developers or perl (or any similar c-derived language) courses for beginners.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>274</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319560817.6593";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>279</wp:comment_id>
			<wp:comment_author><![CDATA[Aaron Trevena]]></wp:comment_author>
			<wp:comment_author_email>aaron.trevena@gmail.com</wp:comment_author_email>
			<wp:comment_author_url>http://www.aarontrevena.co.uk</wp:comment_author_url>
			<wp:comment_author_IP>212.159.78.14</wp:comment_author_IP>
			<wp:comment_date>2011-10-25 09:45:03</wp:comment_date>
			<wp:comment_date_gmt>2011-10-25 16:45:03</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[1) See other comments I made, but mainly the big issue was the "random" language was 2 c-like, and there were no other industrial/commercial languages to compare against, this means we couldn't see which idioms, semantics or syntax were obstacles to newbies :(
2) The papers conclusion smells a bit dodgy, overplaying the closeness of perl to one language and downplaying it to the other, your comments added a dose of snark that was distracting when trying to RTFA ;p
3) Sounds interesting - will look at the other stuff
4) np, if you don't like Perl you must really dislike php so using WP must stick in the throat a bit ;p]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>263</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:14:"1319561103.394";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>280</wp:comment_id>
			<wp:comment_author><![CDATA[Aaron Trevena]]></wp:comment_author>
			<wp:comment_author_email>aaron.trevena@gmail.com</wp:comment_author_email>
			<wp:comment_author_url>http://www.aarontrevena.co.uk</wp:comment_author_url>
			<wp:comment_author_IP>212.159.78.14</wp:comment_author_IP>
			<wp:comment_date>2011-10-25 10:06:39</wp:comment_date>
			<wp:comment_date_gmt>2011-10-25 17:06:39</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Just downloaded about 6 papers by Lutz on stuff like pair programming and maintainence of software.. hopefully better than this one, would be good to make sure we're getting the full benefits of pair programming when we do it in my teams.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>263</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319562399.4375";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>282</wp:comment_id>
			<wp:comment_author><![CDATA[Perl No Better Than Pseudorandom Syntax | Magic Blue Smoke]]></wp:comment_author>
			<wp:comment_author_email></wp:comment_author_email>
			<wp:comment_author_url>http://www.aaronmbrown.net/blog/2011/10/perl-no-better-than-pseudorandom-syntax/</wp:comment_author_url>
			<wp:comment_author_IP>173.236.177.54</wp:comment_author_IP>
			<wp:comment_date>2011-10-25 14:35:06</wp:comment_date>
			<wp:comment_date_gmt>2011-10-25 21:35:06</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[[...] now, I have some empirical evidence for my syntactical complaints. We present here an empirical study comparing the accuracy rates of [...]]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type>pingback</wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>283</wp:comment_id>
			<wp:comment_author><![CDATA[Linkblogging For 25/10/11 &laquo; Sci-Ence! Justice Leak!]]></wp:comment_author>
			<wp:comment_author_email></wp:comment_author_email>
			<wp:comment_author_url>http://andrewhickey.info/2011/10/25/linkblogging-for-251011/</wp:comment_author_url>
			<wp:comment_author_IP>74.200.243.216</wp:comment_author_IP>
			<wp:comment_date>2011-10-25 15:21:31</wp:comment_date>
			<wp:comment_date_gmt>2011-10-25 22:21:31</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[[...] A randomly-generated programming language is as easy as Perl for new programmers. I&#8217;d have guessed that, if anything, Perl would be slightly harder&#8230; [...]]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type>pingback</wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319581292.0344";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>286</wp:comment_id>
			<wp:comment_author><![CDATA[Joel]]></wp:comment_author>
			<wp:comment_author_email>joel.a.berger@gmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>131.193.192.88</wp:comment_author_IP>
			<wp:comment_date>2011-10-26 09:12:51</wp:comment_date>
			<wp:comment_date_gmt>2011-10-26 16:12:51</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[If this was the point, how can one compare learning Perl from the internet (with its many years of tutorials, ranging from good to bad) with made up languages? Can I learn Quorum from the internet, what about Randomo?]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>276</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319645571.6203";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>287</wp:comment_id>
			<wp:comment_author><![CDATA[gvwilson]]></wp:comment_author>
			<wp:comment_author_email>gvwilson@third-bit.com</wp:comment_author_email>
			<wp:comment_author_url>http://third-bit.com/</wp:comment_author_url>
			<wp:comment_author_IP>38.104.156.10</wp:comment_author_IP>
			<wp:comment_date>2011-10-26 09:29:26</wp:comment_date>
			<wp:comment_date_gmt>2011-10-26 16:29:26</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[I believe this critique violates rule #2 in <a href="http://www.neverworkintheory.org/?page_id=203" rel="nofollow">our guidelines</a>. I've added a sentence to the rule to clarify.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>286</wp:comment_parent>
			<wp:comment_user_id>2</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319646574.0016";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:8:"gvwilson";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>288</wp:comment_id>
			<wp:comment_author><![CDATA[gvwilson]]></wp:comment_author>
			<wp:comment_author_email>gvwilson@third-bit.com</wp:comment_author_email>
			<wp:comment_author_url>http://third-bit.com/</wp:comment_author_url>
			<wp:comment_author_IP>38.104.156.10</wp:comment_author_IP>
			<wp:comment_date>2011-10-26 10:40:00</wp:comment_date>
			<wp:comment_date_gmt>2011-10-26 17:40:00</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[http://blogs.perl.org/users/mithaldu/2011/10/perl-tutorials-suck-and-cause-serious-damage.html is an interesting post by (I believe) Christian Walde, who has commented here. He points out that yes, a novice searching for Perl programming examples actually _would_ probably find the kind of code used in this study.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>2</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_rechecking</wp:meta_key>
				<wp:meta_value><![CDATA[1]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319652084.6812";s:7:"message";s:55:"Akismet cleared this comment during an automatic retry.";s:5:"event";s:10:"cron-retry";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319650800.9638";s:7:"message";s:92:"Akismet was unable to check this comment (response: ), will automatically retry again later.";s:5:"event";s:11:"check-error";s:4:"user";s:8:"gvwilson";}]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319650837.6642";s:7:"message";s:47:"gvwilson changed the comment status to approved";s:5:"event";s:15:"status-approved";s:4:"user";s:8:"gvwilson";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>299</wp:comment_id>
			<wp:comment_author><![CDATA[Alex]]></wp:comment_author>
			<wp:comment_author_email>wrd666@gmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>46.207.255.132</wp:comment_author_IP>
			<wp:comment_date>2011-10-27 14:41:57</wp:comment_date>
			<wp:comment_date_gmt>2011-10-27 21:41:57</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Is it just me or does Quorum look a lot like pascal? I think the research is quite interesting from some points of view:
first of all curly braces are great for people who are used to programming because they need to type a lot less than the pascal style begin and end clauses, but to a beginner one signs symbols are terrible to read. (especially if you include  the ternary expression (expression)? true : false ).

However most programmers (including me) don't want to program in languages which are easy to understand but in those which make you most productive. And one thing is very much not taken into account here: (which penalizes C++ alot). It's not only problem solving - people have to create code that is well readable by others and I think the language should support code uniformity. Just take C++ template compile time polymorphism to avoid unnecessary  vtable traversal, a large amount of the C++ community doesn't know how to read the template design patterns. or take bad perl example code from the internet.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319751717.2098";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>300</wp:comment_id>
			<wp:comment_author><![CDATA[John Gotts]]></wp:comment_author>
			<wp:comment_author_email>jgotts@gmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>99.94.188.18</wp:comment_author_IP>
			<wp:comment_date>2011-10-27 14:49:21</wp:comment_date>
			<wp:comment_date_gmt>2011-10-27 21:49:21</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[In this comment, I am presenting some of my own original research, and if you agree with me feel free to award me a PhD.

Nearly all popular programming languages leverage our ability to read and write English and the closely-related languages that most programmers worldwide use to read and write (for simplicity, I'll write English but I'm referring more or less equally to French, German, Russian, and many other languages). By the same token, languages less like English (even languages that excel in certain domains) achieve less acceptance by the general programming population.

To be more specific, programming languages read left to right, top to bottom. Lines read like sentences. Functional units read like paragraphs. A page of code is like a page in a book; physical locality indicates things are closely related.

Going further, variable name assignments read like simple declarative statements, subject-verb-object, just like the language of math (which also has a heavy English bias). Some languages that are more difficult to use read object verb subject. The keywords of the language are English words. Constructs like if-then-else that occur in all of the popular language all read like English.

In this way, we as readers and writers of our language leverage those abilities to fulfill a task that is already hard enough (programming) and as a result the languages we find ourselves preferring are most similar to the language we use to read and write.

I haven't looked at Randomo, but doing things like modifying the way variables are declared, changing window dressing what punctuation marks are used and how, and maybe changing formatting slightly is like changing the font in a novel or moving to a more cursive font. They are very unlikely to change the programmer's efficiency in a positive or negative manner. Another statement I would make is that people's difficulties with Perl stem not only from how different it is from the most popular programming languages, but how different it is from English (and again I lump in the hundreds of languages expressed like English).]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319752161.7854";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>301</wp:comment_id>
			<wp:comment_author><![CDATA[Todd]]></wp:comment_author>
			<wp:comment_author_email>toddecus@yahoo.com</wp:comment_author_email>
			<wp:comment_author_url>http://www.betterwebapp.com</wp:comment_author_url>
			<wp:comment_author_IP>216.3.99.146</wp:comment_author_IP>
			<wp:comment_date>2011-10-27 14:51:24</wp:comment_date>
			<wp:comment_date_gmt>2011-10-27 21:51:24</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Not exactly an empirical study but we tried to build the same web application in 9 different languages/frameworks.  Bottom line  Perl SUX for web application development.
@Glyph
http://www.betterwebapp.com   Non-comercial site, just where I published my research.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319752284.2361";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>303</wp:comment_id>
			<wp:comment_author><![CDATA[John Gotts]]></wp:comment_author>
			<wp:comment_author_email>jgotts@gmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>99.94.188.18</wp:comment_author_IP>
			<wp:comment_date>2011-10-27 15:05:09</wp:comment_date>
			<wp:comment_date_gmt>2011-10-27 22:05:09</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[If you look at figure 1 comparing all three languages, you'll find them to be all very English like. Randomo uses symbols instead of keywords, but it reads left to right, top down, is organized by sentence and paragraph, uses SOV declarations, among other features. To me there should be very little difference in efficiency between any of the three languages. They're not varying what would make a programming language difficult to use, varying it from English (and related language) syntax.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>300</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319753109.6251";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>304</wp:comment_id>
			<wp:comment_author><![CDATA[Mark]]></wp:comment_author>
			<wp:comment_author_email>markdall@live.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>50.46.176.241</wp:comment_author_IP>
			<wp:comment_date>2011-10-27 15:06:13</wp:comment_date>
			<wp:comment_date_gmt>2011-10-27 22:06:13</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[So? No really, so what? I like Perl. I will continue using it. 

I don't care how accurate novices are. Yes, new things are constantly made so that brand new users pick them up faster. (See: Every change to Microsoft Windows UI between major versions up to an including Windows 8 and Metro apps.)

It's like banks and their first time buyer programs. Not exactly helpful to the rest of us.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:14:"1319753173.463";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>305</wp:comment_id>
			<wp:comment_author><![CDATA[gvwilson]]></wp:comment_author>
			<wp:comment_author_email>gvwilson@third-bit.com</wp:comment_author_email>
			<wp:comment_author_url>http://third-bit.com/</wp:comment_author_url>
			<wp:comment_author_IP>173.33.251.2</wp:comment_author_IP>
			<wp:comment_date>2011-10-27 15:09:15</wp:comment_date>
			<wp:comment_date_gmt>2011-10-27 22:09:15</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Can you please post a link to your research?]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>300</wp:comment_parent>
			<wp:comment_user_id>2</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319753355.2664";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:8:"gvwilson";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>306</wp:comment_id>
			<wp:comment_author><![CDATA[gvwilson]]></wp:comment_author>
			<wp:comment_author_email>gvwilson@third-bit.com</wp:comment_author_email>
			<wp:comment_author_url>http://third-bit.com/</wp:comment_author_url>
			<wp:comment_author_IP>173.33.251.2</wp:comment_author_IP>
			<wp:comment_date>2011-10-27 15:10:23</wp:comment_date>
			<wp:comment_date_gmt>2011-10-27 22:10:23</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[I'm curious --- if you don't care, then why comment?]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>304</wp:comment_parent>
			<wp:comment_user_id>2</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319753423.2037";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:8:"gvwilson";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>317</wp:comment_id>
			<wp:comment_author><![CDATA[Ben]]></wp:comment_author>
			<wp:comment_author_email>k7jg7bz7k2@snkmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>68.48.54.73</wp:comment_author_IP>
			<wp:comment_date>2011-10-27 17:18:08</wp:comment_date>
			<wp:comment_date_gmt>2011-10-28 00:18:08</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[I entirely agree, only I'd add 4. a solid data model, and I've been working on the idea. I've got  the data model part up, https://github.com/scooby/gybe_ls , but I'm also working on the other aspects of the language as well. (I don't have that work public at the moment, though.)]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>273</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319761088.4192";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>319</wp:comment_id>
			<wp:comment_author><![CDATA[Ben]]></wp:comment_author>
			<wp:comment_author_email>k7jg7bz7k2@snkmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>68.48.54.73</wp:comment_author_IP>
			<wp:comment_date>2011-10-27 17:21:45</wp:comment_date>
			<wp:comment_date_gmt>2011-10-28 00:21:45</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Oh, they're absolutely right. The number of blogs out there that put out awful tutorials on any technical subject are astounding. Try learning LaTeX from Internet tutorials. You'll invariably find that 99% of the stuff is years old, and you're using buggy packages that are totally obsolete.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>288</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319761305.0463";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>320</wp:comment_id>
			<wp:comment_author><![CDATA[Mike G]]></wp:comment_author>
			<wp:comment_author_email>mike.gervais@hotmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>74.75.72.218</wp:comment_author_IP>
			<wp:comment_date>2011-10-27 18:43:21</wp:comment_date>
			<wp:comment_date_gmt>2011-10-28 01:43:21</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[I write in Perl every single day.  when coupled with html, jquery, js, and some sql it is one of the most powerful languages on the planet besides php.  You don't need C# to write webpages and quite frankly the overhead on using more modern languages is a bit too much for rapid application development.

I create web applications every day for huge companies.  Sony, Autodesk, Comcast, Verizon, Toshiba and the list goes on.  And they are all done in cgi scripting.

Now I learned perl in college briefly but never saw myself as doing it as a career as I nearly failed it.  Our perl class focused on things that did not matter.  Our final was to write a craps game and boy did mine suck.  But somehow I pursued a job doing it, and ending up reading perl for dummies going across country from Maine to California.  And guess what folks...a 12 year old can learn perl.  

5 years later I am at the top of my pay scale however, but very happy there.  making 90k + a year writing in a language many consider outdated may not be everyones dream career but I personally vouch for the learnability of it.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319766201.3656";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>322</wp:comment_id>
			<wp:comment_author><![CDATA[gvwilson]]></wp:comment_author>
			<wp:comment_author_email>gvwilson@third-bit.com</wp:comment_author_email>
			<wp:comment_author_url>http://third-bit.com/</wp:comment_author_url>
			<wp:comment_author_IP>173.33.251.2</wp:comment_author_IP>
			<wp:comment_date>2011-10-27 18:47:13</wp:comment_date>
			<wp:comment_date_gmt>2011-10-28 01:47:13</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Congratulations on your success, but I don't see how it relates to the claims made in this paper?]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>320</wp:comment_parent>
			<wp:comment_user_id>2</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319766433.5917";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:8:"gvwilson";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>323</wp:comment_id>
			<wp:comment_author><![CDATA[Ersun Warncke]]></wp:comment_author>
			<wp:comment_author_email>ersun.warncke@gmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>98.202.165.157</wp:comment_author_IP>
			<wp:comment_date>2011-10-27 18:58:39</wp:comment_date>
			<wp:comment_date_gmt>2011-10-28 01:58:39</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[It is an interesting study, however, I don't see it as doing anything but confirming what should be common sense.

You are comparing a language that uses entirely natural (english) language constructs and grammar rules (indentation) and comparing it to languages that use arbitrary symbols.  A "novice" (who knows english) will of course do better with a "computer" language that is really just structured english.

Try your study on people who's native language is not based on the Roman alphabet (Chinese, Japanese, Arabic, Hebrew, etc) and have never studied english.  If you are still showing significant gains over other programming languages, then you might be on to something.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319767119.9023";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>349</wp:comment_id>
			<wp:comment_author><![CDATA[dr2chase]]></wp:comment_author>
			<wp:comment_author_email>dr2chase@mac.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>173.48.203.29</wp:comment_author_IP>
			<wp:comment_date>2011-10-28 07:47:00</wp:comment_date>
			<wp:comment_date_gmt>2011-10-28 14:47:00</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[For a future study, to help address the real-vs-fake complaints, I think tossing Python into the mix would be very interesting.  Based only on my own anecdotal experience using both Python and Perl "in anger" and not knowing either one very well at the start, I found Python very much easier to use, understand, and debug.  It's not perfect, and I did get confused, but was tackling much more tricky problems before I got confused.

If the authors are interested in "innovating more" in their creation of programming languages, the Rats! parser provides wonderful flexibility.

I also have a general question, inspired by something I did not know that I read in their paper.  If "repeat" is more intuitive than "for" for sequential iteration, is that still true for running the bodies of the loop in parallel?  I'm thinking in particular of a form of execution where the index expression ("set.elements" in "for x in set.elements") is passed the body of the loop as a thunk, and controls the parallelism and potentially even the location of the computation.  The exact details are meant to be hidden, but broadly, "in parallel".  Is "repeat" still the best choice here, or does it mislead by suggesting that things are done one at a time?]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319813220.9259";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>332</wp:comment_id>
			<wp:comment_author><![CDATA[Clay Morrison]]></wp:comment_author>
			<wp:comment_author_email>clayton.t.morrison@gmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>68.32.214.112</wp:comment_author_IP>
			<wp:comment_date>2011-10-27 22:14:27</wp:comment_date>
			<wp:comment_date_gmt>2011-10-28 05:14:27</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[perl is one of the most widely used scripting languages in biological and other life sciences, often written by people who are not career programmers.  I think it is an unfortunate choice, ill-fit to the user base and likely maintainers (new, incoming graduate students again with some but not likely a lot of programming).]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>253</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319778867.8596";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>333</wp:comment_id>
			<wp:comment_author><![CDATA[John Thompson]]></wp:comment_author>
			<wp:comment_author_email>jnthomp@cableone.net</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>184.155.114.104</wp:comment_author_IP>
			<wp:comment_date>2011-10-27 22:32:35</wp:comment_date>
			<wp:comment_date_gmt>2011-10-28 05:32:35</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[I read the point.  I read the guideline.  The point seems more appropriate than the guideline.  The assumptions need to be questionable, not just the claims.

Choosing poorly written examples in one language and well written examples in others introduces a bias, and that bias should be questionable and questioned.  In this case, it is reasonable to assume that the biased code samples could affect the outcome of the experiments.  

Perhaps if Quorum and Randomo had a history with many examples on the Internet, there would be a range of good examples and bad, fresh examples and dated ones.  Then, by drawing older, more poorly written ones, they could match poor samples they chose for Perl.

Thus, the claims of the paper end up with a bias.  It would be more accurate to say that novices learn better from good code samples in Quorum than they can from poor code samples from Perl.  I don't doubt that Quorum is a better teaching language than Perl, but I don't think this paper shows it objectively enough.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>287</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319779955.7121";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>335</wp:comment_id>
			<wp:comment_author><![CDATA[Kevin Lowe]]></wp:comment_author>
			<wp:comment_author_email>kevin.lowe@uqconnect.edu.au</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>115.187.238.77</wp:comment_author_IP>
			<wp:comment_date>2011-10-27 23:26:28</wp:comment_date>
			<wp:comment_date_gmt>2011-10-28 06:26:28</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Competent researchers do a pilot study to establish the strength of the effect they wish to study, and then design a full-scale study to demonstrate statistical significance. This study should be taken more as a pilot study than a serious study, since the sample size was too small in a very specific, meaningful and strictly mathematical sense: if your p value is &gt;0.05, your sample was too small or the effect you are studying probably doesn't exist. Since it seems highly likely that a deliberately perverse programming language would in fact be harder to learn I think we can be very confident that the problem was sample size, not a nonexistent effect.

The criticism that the Perl teaching material was of poor quality seems like a definite hole in the experimental methodology that should be addressed. Ideally the teaching material for each language would be as close to identical as possible, and of the highest quality possible. Whether poor teaching material leads to poor outcomes is not a very interesting question to investigate, whereas whether or not Perl leads to good outcomes given best-practice teaching is a very interesting question.

Overall this study seems to be open to accusations that it was "cooked" to generate a result unfavourable to Perl, if the Perl teaching material was markedly poor, especially since its presentation of its statistical results is not even-handed but emphasises the interpretations unfavourable to Perl and de-emphasises the favourable interpretations.

Please note for the record that I couldn't tell one programming language from another to save my life unless the languages were BASIC or Pascal, and I have absolutely no ideological commitment for or against Perl or any of its modern rivals. This is a study on an interesting topic that is badly flawed in terms of methodology and sample size. I would be very interested in seeing it replicated with better teaching materials and a sample size sufficient to demonstrate statistical significance.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319783189.0051";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>336</wp:comment_id>
			<wp:comment_author><![CDATA[Pedro Fortuny]]></wp:comment_author>
			<wp:comment_author_email>pfortuny@gmail.com</wp:comment_author_email>
			<wp:comment_author_url>http://pfortuny.net</wp:comment_author_url>
			<wp:comment_author_IP>156.35.192.4</wp:comment_author_IP>
			<wp:comment_date>2011-10-28 00:01:25</wp:comment_date>
			<wp:comment_date_gmt>2011-10-28 07:01:25</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Ehm... and your work proves?

Because it seems to me that the Japanese are HAPPY with their language and it enables them to communicate.

Maybe a random generated syntax is suited to human thought. Just compare some real languages out there...]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319785286.1209";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>338</wp:comment_id>
			<wp:comment_author><![CDATA[Hammerite]]></wp:comment_author>
			<wp:comment_author_email>throwaway@orderofthehammer.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>143.167.6.69</wp:comment_author_IP>
			<wp:comment_date>2011-10-28 02:01:14</wp:comment_date>
			<wp:comment_date_gmt>2011-10-28 09:01:14</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Eh? I don't think ducks have ever used Perl. Frankly, I don't think ducks are suited to programming a computer at all; they would probably just get it wet.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>249</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:14:"1319792475.094";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>341</wp:comment_id>
			<wp:comment_author><![CDATA[Friday miscellany &#8212; The Endeavour]]></wp:comment_author>
			<wp:comment_author_email></wp:comment_author_email>
			<wp:comment_author_url>http://www.johndcook.com/blog/2011/10/28/friday-miscellany-10/</wp:comment_author_url>
			<wp:comment_author_IP>74.208.16.51</wp:comment_author_IP>
			<wp:comment_date>2011-10-28 03:51:53</wp:comment_date>
			<wp:comment_date_gmt>2011-10-28 10:51:53</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[[...] (McCarthyism) Accuracy rates of novices in three languages [...]]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type>pingback</wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319799113.5542";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>342</wp:comment_id>
			<wp:comment_author><![CDATA[Josh Scholar]]></wp:comment_author>
			<wp:comment_author_email>joshscholar@nightstudies.net</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>46.253.180.4</wp:comment_author_IP>
			<wp:comment_date>2011-10-28 04:42:42</wp:comment_date>
			<wp:comment_date_gmt>2011-10-28 11:42:42</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[I certainly found quorum more readable than perl, and I've been programming for decades.

However I question how useful it is to design computer languages to be easy for beginners to read, surely it's more important for it to make experienced programmers more productive.

Also I suppose Quorum uses strongly typed variables because explaining numerical conversion rules would take a lesson...  Yet once again, is saving a small amount of teaching time worthwhile?]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319802162.4449";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>343</wp:comment_id>
			<wp:comment_author><![CDATA[Josh Scholar]]></wp:comment_author>
			<wp:comment_author_email>joshscholar@nightstudies.net</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>46.253.180.4</wp:comment_author_IP>
			<wp:comment_date>2011-10-28 04:55:14</wp:comment_date>
			<wp:comment_date_gmt>2011-10-28 11:55:14</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[I know what type inference is, but could you explain what you mean by "controlled mutation"? Also what do you mean by "purity"?

If "purity" means that you try to fit all programs into using a very limited set of features, then I am tempted to disagree.  For instance it is unnecessary and annoying that Java does not allow functions unconnected to classes.  It is unnecessary and annoying that Lua has only one aggregate type.  It is unnecessary and annoying that Prolog allows you to drop matching for a functional notation (IS expressions) ONLY for numerical expressions, not for a general functions.  It is unnecessary and annoying that LISP has a good notation for code-generation and automated code processing (S-expressions) but no human readable syntax. etc. etc.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>273</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319802914.5639";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>346</wp:comment_id>
			<wp:comment_author><![CDATA[toby]]></wp:comment_author>
			<wp:comment_author_email>tcornish@gmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>162.129.251.22</wp:comment_author_IP>
			<wp:comment_date>2011-10-28 06:24:41</wp:comment_date>
			<wp:comment_date_gmt>2011-10-28 13:24:41</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Although I agree with the conclusions (I am in the process of abandoning Perl for python), p = 0.458 is pretty weak, bordering on insignificance. That stated, personally, if I knew nothing about programming, it would be much easier to learn using their language than using perl or randomo.  I think that is the essence of the study. However, a beginner taught a language with a real user base, real libraries and a passionate community would have a better chance of transitioning from novice to intermediate. Failure to recognize that is a failure to recognize anything that has happened in the last 20 years vis-a-vis the modern internet.

"Perl users were not able to program signiﬁcantly more accurately than Randomo, p = .458"]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319808281.2884";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>330</wp:comment_id>
			<wp:comment_author><![CDATA[Christopher Penrose]]></wp:comment_author>
			<wp:comment_author_email>Wafletower@yahoo.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>24.21.195.193</wp:comment_author_IP>
			<wp:comment_date>2011-10-27 21:27:15</wp:comment_date>
			<wp:comment_date_gmt>2011-10-28 04:27:15</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[The comments seem to be over-moderated; despite being a breath of fresh air on Internet forums such moderation seems to blunt some honest criticism of the study.  While I am a Perl fan and have used the language for nearly 20 years, I don't think such predilection nullifies my feeling that the relevance of this study is quite near zero.  The assertion "Perl is as difficult to learn as a randomly generated language" lacks relevance without comparisons to other commonplace real world languages.  I am trying to understand the motivation behind the study:  are the authors trying recover from an unfortunate experience of perl poetry?  Are they trying overthrow the use of Perl in some enterprise?  Is it honest unpremeditated pedagogical research to discover effective languages for novices?]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319776035.7214";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>331</wp:comment_id>
			<wp:comment_author><![CDATA[ysth]]></wp:comment_author>
			<wp:comment_author_email>sthoenna@gmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>174.21.187.251</wp:comment_author_IP>
			<wp:comment_date>2011-10-27 22:04:16</wp:comment_date>
			<wp:comment_date_gmt>2011-10-28 05:04:16</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Yes, perl (largely because it's been around so long, I believe) suffers from a lot of really bad learning resources out there.  One of the first lessons the successful novice should learn is to stick to the official resources or other places linked from them, never to search the web, whether for tutorials or to answer a question about the language.

It sounds like this study has essentially proven this point, not any other.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>319</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319778256.2641";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>353</wp:comment_id>
			<wp:comment_author><![CDATA[Pablo]]></wp:comment_author>
			<wp:comment_author_email>topagonza@gmail.com</wp:comment_author_email>
			<wp:comment_author_url>http://google.com</wp:comment_author_url>
			<wp:comment_author_IP>170.51.242.156</wp:comment_author_IP>
			<wp:comment_date>2011-10-28 08:24:43</wp:comment_date>
			<wp:comment_date_gmt>2011-10-28 15:24:43</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Perhaps only improve as a teacher and so the subsequent languages ​​were better understood.
In that sense do not see how a language is better than another. It just depends on the method of study.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319815483.3442";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>356</wp:comment_id>
			<wp:comment_author><![CDATA[Dragon Dave]]></wp:comment_author>
			<wp:comment_author_email>dave.mckee@gmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>86.161.69.53</wp:comment_author_IP>
			<wp:comment_date>2011-10-28 10:15:20</wp:comment_date>
			<wp:comment_date_gmt>2011-10-28 17:15:20</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Did they actually have access to a Perl / Quorum / Randomo interpreter? I can't quite work that out from the article.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:13:"1319822120.95";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>357</wp:comment_id>
			<wp:comment_author><![CDATA[Mike G]]></wp:comment_author>
			<wp:comment_author_email>mike.gervais@hotmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>216.31.243.131</wp:comment_author_IP>
			<wp:comment_date>2011-10-28 10:26:32</wp:comment_date>
			<wp:comment_date_gmt>2011-10-28 17:26:32</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[so did you read what i wrote?  perl sucked in school but is easy to learn on your own if you take the time and is an extremely beneficial language.  I can't say that for the other two nor do I find a place in the the real world for a novice programmer to be using them.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>322</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319822792.6989";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>360</wp:comment_id>
			<wp:comment_author><![CDATA[Greg Wilson]]></wp:comment_author>
			<wp:comment_author_email>gvwilson@third-bit.com</wp:comment_author_email>
			<wp:comment_author_url>http://www.third-bit.com</wp:comment_author_url>
			<wp:comment_author_IP>38.104.156.10</wp:comment_author_IP>
			<wp:comment_date>2011-10-28 10:32:20</wp:comment_date>
			<wp:comment_date_gmt>2011-10-28 17:32:20</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Yes, I read it, and my question stands.  The paper doesn't say that Perl is easy or hard to learn --- those adjectives are only meaningful as comparisons to something else.  Nor are they saying that Perl isn't useful in real-world applications, or that Randomo or Quorum are.  What they said is that novice Perl users were unable to write programs more accurately than those using a language designed by chance.  (Please also see guideline #2 on this site.)]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>357</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319823140.9592";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>362</wp:comment_id>
			<wp:comment_author><![CDATA[Matt]]></wp:comment_author>
			<wp:comment_author_email>callaguy@gmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>67.60.25.1</wp:comment_author_IP>
			<wp:comment_date>2011-10-28 14:05:33</wp:comment_date>
			<wp:comment_date_gmt>2011-10-28 21:05:33</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[My clients have me use it daily.  So, YES, it is used.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>249</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319835933.1983";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>363</wp:comment_id>
			<wp:comment_author><![CDATA[Vic]]></wp:comment_author>
			<wp:comment_author_email>Vchica@pdx.edu</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>131.252.242.119</wp:comment_author_IP>
			<wp:comment_date>2011-10-28 16:43:52</wp:comment_date>
			<wp:comment_date_gmt>2011-10-28 23:43:52</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[That's plenty substantive. That it was delivered concisely and with ironic panache doesn't imply it lacks substance.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>271</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319845432.8677";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>373</wp:comment_id>
			<wp:comment_author><![CDATA[english related to language - LANGUAGE LEARNİNG &#8211; LANGUAGE LEARNİNG]]></wp:comment_author>
			<wp:comment_author_email></wp:comment_author_email>
			<wp:comment_author_url>http://www.world-language.tk/learn/language-learning-english/english-related-to-language</wp:comment_author_url>
			<wp:comment_author_IP>184.172.150.8</wp:comment_author_IP>
			<wp:comment_date>2011-10-30 10:05:15</wp:comment_date>
			<wp:comment_date_gmt>2011-10-30 17:05:15</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[[...] worldwide use to read and write (for simplicity, I&#039;ll write English but I&#039;m &#8230;http://www.neverworkintheory.o .. Share and [...]]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type>pingback</wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>378</wp:comment_id>
			<wp:comment_author><![CDATA[Juan Antonio Navarro Pérez]]></wp:comment_author>
			<wp:comment_author_email>juannavarroperez@gmail.com</wp:comment_author_email>
			<wp:comment_author_url>http://navarroj.com/research</wp:comment_author_url>
			<wp:comment_author_IP>131.159.22.9</wp:comment_author_IP>
			<wp:comment_date>2011-10-31 06:05:42</wp:comment_date>
			<wp:comment_date_gmt>2011-10-31 13:05:42</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[I am a perl fan but I *do* actually like a lot the study. Yes, there are some obvious shortcomings on the methodology (as others have pointed out) and not much can be concluded from this single study. Also the results don't surprise me because, basically, the task given to the students was to "reverse engineer" the semantics of the language from some code examples and their english descriptions. In this respect, I agree that perl's syntax is not intuitive at all, and any language with descriptive keywords should do much better. It would be much more interesting if the authors repeated the study and compare Quorum with Java or even perhaps Applescript, which also claims to be very "human readable".

Anyway, I love the fact that this kind of studies are being done, I'm definitely pro evidence-based design of programming languages. It would also be great if other researchers who disagree with the methods or conclusions of this study would do so by performing *better* experiments, and not just by pointing out the flaws in this one and stating blanket statements as "this is completely useless".]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1320066344.0684";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>417</wp:comment_id>
			<wp:comment_author><![CDATA[Jenda]]></wp:comment_author>
			<wp:comment_author_email>jenda@krynicky.cz</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>94.230.147.206</wp:comment_author_IP>
			<wp:comment_date>2011-11-09 13:43:12</wp:comment_date>
			<wp:comment_date_gmt>2011-11-09 21:43:12</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[The example in the three languages makes one thing crystal clear. None of those "scientists" is a programmer. Or developer if you prefer that term. It's almost indecipherable in any of the languages and I'm surprised the "subjects" were able to learn anything.
Next time, please, do ask someone who's actually ever wrote something other than proofs to help you with the examples.
And if the Quorum was as you said based on "the latest academic research and literature on programming language usability" then the academics had really lost contact with the real world. Back to BASIC with a single letter variable name restriction!]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1320874992.2552";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>672</wp:comment_id>
			<wp:comment_author><![CDATA[Thoughts on the Quorum paper | Tavish Armstrong&#039;s blog]]></wp:comment_author>
			<wp:comment_author_email></wp:comment_author_email>
			<wp:comment_author_url>http://tavisharmstrong.com/2011/12/04/thoughts-on-the-quorum-paper/</wp:comment_author_url>
			<wp:comment_author_IP>97.107.129.244</wp:comment_author_IP>
			<wp:comment_date>2011-12-04 12:06:19</wp:comment_date>
			<wp:comment_date_gmt>2011-12-04 20:06:19</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[[...] on the &#8220;It Will Never Work In Theory&#8221; blog Greg Wilson blogged about a paper by Andreas Stefik, Susanna Siebert, Melissa Stefik, and Kim [...]]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type>pingback</wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1323029179.6461";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>383</wp:comment_id>
			<wp:comment_author><![CDATA[Barry]]></wp:comment_author>
			<wp:comment_author_email>draegtun@googlemail.com</wp:comment_author_email>
			<wp:comment_author_url>http://transfixedbutnotdead.com</wp:comment_author_url>
			<wp:comment_author_IP>81.86.55.24</wp:comment_author_IP>
			<wp:comment_date>2011-11-01 06:11:27</wp:comment_date>
			<wp:comment_date_gmt>2011-11-01 13:11:27</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Just looked at the final results presentation provided on http://www.betterwebapp.com.  Is it correct that you're comparing Perl CGI to web frameworks like Django &amp; Rails? 

If so then it is indeed NOT an empirical study!   A more correct comparison would be to use a Perl web framework like Catalyst or Mojolicious.

/I3az/]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>301</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1320153087.4297";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>461</wp:comment_id>
			<wp:comment_author><![CDATA[Keith]]></wp:comment_author>
			<wp:comment_author_email>keithwoelfel60@hotmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>97.92.204.83</wp:comment_author_IP>
			<wp:comment_date>2011-11-18 09:09:16</wp:comment_date>
			<wp:comment_date_gmt>2011-11-18 17:09:16</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[You make the assumption that utility of a programming language is only relevant (or mostly relevant) in its use with experienced programmers. That is an illustration of what so many people who are bashing this study (and others like it) are unwilling or unable to understand. 

There is great benefit to a programming language that may have limited utility at "higher" experience levels, targeting novice programmers. Baby steps, remember. It's also why some programming languages exist and are implemented much longer than their actual "usefulness" with more experienced programmers. BASIC, for example, in its plethora of flavors lived long past its usefulness to expert programmers, because it was easier for a novice to pick up and grasp (at least to some extent). Novice languages have merit that is not simply defined by use by so called experts.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>342</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1321636156.9053";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>447</wp:comment_id>
			<wp:comment_author><![CDATA[Herding Code 126: Jeff Atwood on the overlap of Video Games and Learning]]></wp:comment_author>
			<wp:comment_author_email></wp:comment_author_email>
			<wp:comment_author_url>http://herdingcode.com/?p=363</wp:comment_author_url>
			<wp:comment_author_IP>74.54.71.143</wp:comment_author_IP>
			<wp:comment_date>2011-11-14 16:39:06</wp:comment_date>
			<wp:comment_date_gmt>2011-11-15 00:39:06</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[[...] An Empirical Comparison of the Accuracy Rates of Novices using the Quorum, Perl, and Randomo Program... [...]]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type>pingback</wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1321317546.5313";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>794</wp:comment_id>
			<wp:comment_author><![CDATA[Software Carpentry &raquo; Why Is This Hard?]]></wp:comment_author>
			<wp:comment_author_email></wp:comment_author_email>
			<wp:comment_author_url>http://software-carpentry.org/2012/01/why-is-this-hard/</wp:comment_author_url>
			<wp:comment_author_IP>69.163.247.75</wp:comment_author_IP>
			<wp:comment_date>2012-01-29 04:18:48</wp:comment_date>
			<wp:comment_date_gmt>2012-01-29 12:18:48</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[[...] from the 1970s and 1980s into the usability of programming languages, but as we found out the hard way, it will be a long time before computer &#8220;scientists&#8221; start accepting scientific [...]]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type>pingback</wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1327839528.3933";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>784</wp:comment_id>
			<wp:comment_author><![CDATA[An Empirical Comparison of the Accuracy Rates of Novices using the Quorum, Perl, and Randomo Programming Languages | Software Visualization]]></wp:comment_author>
			<wp:comment_author_email></wp:comment_author_email>
			<wp:comment_author_url>http://softvis.wordpress.com/2012/01/18/accuracy-rates-of-novices/</wp:comment_author_url>
			<wp:comment_author_IP>216.151.210.49</wp:comment_author_IP>
			<wp:comment_date>2012-01-17 16:24:29</wp:comment_date>
			<wp:comment_date_gmt>2012-01-18 00:24:29</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[[...] http://www.neverworkintheory.org/?p=197 [...]]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type>pingback</wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1326846269.4321";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>740</wp:comment_id>
			<wp:comment_author><![CDATA[Links for December 13th through December 19th | michael-mccracken.net]]></wp:comment_author>
			<wp:comment_author_email></wp:comment_author_email>
			<wp:comment_author_url>http://michael-mccracken.net/2011/12/links-for-december-13th-through-december-19th/</wp:comment_author_url>
			<wp:comment_author_IP>207.7.108.201</wp:comment_author_IP>
			<wp:comment_date>2011-12-27 09:13:40</wp:comment_date>
			<wp:comment_date_gmt>2011-12-27 17:13:40</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[[...] An Empirical Comparison of the Accuracy Rates of Novices using the Quorum, Perl, and Randomo Program... &#8211; We present here an empirical study comparing the accuracy rates of novices writing software in three programming languages: Quorum, Perl, and Randomo. The first language, Quorum, we call an evidence-based programming language, where the syntax, semantics, and API designs change in correspondence to the latest academic research and literature on programming language usability. Second, while Perl is well known, we call Randomo a Placebo-language, where some of the syntax was chosen with a random number generator and the ASCII table. We compared novices that were programming for the first time using each of these languages, testing how accurately they could write simple programs using common program constructs (e.g., loops, conditionals, functions, variables, parameters). Results showed that while Quorum users were afforded significantly greater accuracy compared to those using Perl and Randomo, Perl users were unable to write programs more accurately than those using a language designed by chance   Tagged: (Source: &raquo; architecture &raquo; community &raquo; documentary &raquo; empirical-software-engineering &raquo; http://twitter.com/insideHPC/status/146761306207301633) &raquo; medicine &raquo; movies &raquo; opensource &raquo; pinboard-links &raquo; productivity &raquo; programming &raquo; software [...]]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type>pingback</wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
		</wp:comment>
	</item>
	<item>
		<title>Author Response: Quorum vs Perl vs Randomo Novice Accuracy Rates</title>
		<link>http://www.neverworkintheory.org/?p=211</link>
		<pubDate>Thu, 27 Oct 2011 19:42:20 +0000</pubDate>
		<dc:creator>AndreasStefik</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=211</guid>
		<description></description>
		<content:encoded><![CDATA[Hi Greg and Jorge,

Thanks for mentioning our work on your site. My team and I have been astonished at how far and wide our results have spread in just a day or two. It’s amazing how emotional people have become about our experiment. Anyway, I’m a working scientist, so I don’t have a ton of time, but I’ll try to respond to a few user comments:

<strong>1. Claim: We tested with novices. This would never apply in the field.</strong>

Response: As scientists and practitioners, it would behoove us to objectively test such claims instead of just declaring their truth-value. I think that we should be testing languages with novices, professionals, and everyone in between.

<strong>2. Claim: $a to $c initializations are non-idiomatic and borked (or old). The syntax ($a,$b,$c) = @_; would be better. Or similarly, people might have chosen different examples.</strong>

Response: Testing with other examples or other versions of Perl, could reveal different accuracy rates. With that said, I find it pretty unlikely that ($a,$b,$c) = @_; would have much meaning to a novice. There is no way to know without more formal experiments, but it wouldn’t surprise me if someone discovered novices did even worse with such syntax.

<strong>3. Claim: We should trust our gut instincts over empirical studies.</strong>

Response: Gut instincts can be valuable, but in programming language design, people's guts rarely seem to agree. By using the scientific method, we can obtain more reproducible, and frankly more accurate, answers.

<strong>4. Claim: A larger sample size might show Perl did better than a language designed by chance.</strong>

Response: This is <em><strong>true</strong></em>, as we clearly discuss in the paper. Keep in mind, if this is the case, it would only mean that novices were afforded 26% greater accuracy than those using Randomo. That's very poor.

<strong>5. Claim: Quorum users were not more accurate than Perl or Randomo users.</strong>

Response: This is <em><strong>false</strong></em>. Results show there is a 95.3% chance that novice Quorum users were more accurate than Perl users and a 99.6% chance that they were more accurate than Randomo. To say otherwise is misrepresentative of our results.

<strong>6. Claim: Two of the languages are made up.</strong>

Response: Three: so is Perl. Quorum is implemented though. We’ll release 1.0 in a few months on sourceforge. Randomo is clearly a thought experiment, but would be easy to implement.

<strong>In Summary:</strong>

If anything, from reading the responses, what I think our community really needs to do is to move away from a largely pseudo-scientific view of programming language design toward one based on evidence. The scientific method has a much better chance of ending the programming language wars someday than does continuing to argue about it.

Finally, as one last point, for those readers that absolutely must send hate mail, please send it only to me, not my students.

Andreas Stefik, Ph.D.
Assistant Professor
Department of Computer Science
Southern Illinois University Edwardsville]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>211</wp:post_id>
		<wp:post_date>2011-10-27 12:42:20</wp:post_date>
		<wp:post_date_gmt>2011-10-27 19:42:20</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>author-response-quorum-vs-perl-vs-randomo-novice-accuracy-rates</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="uncategorized"><![CDATA[Uncategorized]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[6]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>312</wp:comment_id>
			<wp:comment_author><![CDATA[AndreasStefik]]></wp:comment_author>
			<wp:comment_author_email>stefika@gmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>76.77.226.41</wp:comment_author_IP>
			<wp:comment_date>2011-10-27 16:32:54</wp:comment_date>
			<wp:comment_date_gmt>2011-10-27 23:32:54</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Bruce, 

Thanks for saying this so clearly!]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>311</wp:comment_parent>
			<wp:comment_user_id>6</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319758374.4332";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:13:"AndreasStefik";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>313</wp:comment_id>
			<wp:comment_author><![CDATA[John Kim]]></wp:comment_author>
			<wp:comment_author_email>hythlodayr@gmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>74.72.233.35</wp:comment_author_IP>
			<wp:comment_date>2011-10-27 16:57:19</wp:comment_date>
			<wp:comment_date_gmt>2011-10-27 23:57:19</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[I enjoyed this study.

However...Perl is getting the bad rap for this (if it matters, I don't like Perl because of the way it was designed); but is the difficulty with the Perl syntax?  Or is it really from the C syntax which Perl inherits?

For various reasons C is beginner-unfriendly and I suspect its relatives also suffer the same problem.

For example:  Most non-novices in a C or C-inspired language take for granted that "==" is for equality comparison whereas "=" is for assignments.  But not only does this trip up novices--especially in C and C++, where the compiler won't  catch this issue clause--but it hits highly-seasoned programmers as well.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319759839.7864";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>311</wp:comment_id>
			<wp:comment_author><![CDATA[Bruce Irvin]]></wp:comment_author>
			<wp:comment_author_email>rbirvin@mindspring.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>144.47.26.104</wp:comment_author_IP>
			<wp:comment_date>2011-10-27 16:20:53</wp:comment_date>
			<wp:comment_date_gmt>2011-10-27 23:20:53</wp:comment_date_gmt>
			<wp:comment_content><![CDATA["1. Claim: We tested with novices. This would never apply in the field."

It seems to me that this claim is not only false, but explains the value of the study. Every programmer in any language starts out as a novice, and out "in the field" a percentage of any successful company's programmers need to be replaced. The study appears to show that there can be a measurable  difference in "learning curves" among languages. There may indeed be a "tipping point" at which the initial loss in manhours is recouped in debugging, maintenance, or in delivering ad hoc scripts or complex projects - but it would help to know from the start just how disappointing initial results in a new language can be (for the novice as well as the supervisor).


Given that the "Pathologically Eclectic Rubbish Lister" is notoriously difficult to follow from code examples, in the interest of usability you'd probably do well to further examine tasks 3 and 5, in which Quorum did not provide a much lower barrier to the low-scoring novices than perl. Likewise, tasks 1 and 2 may have been the sort of construct that beginners in any language would benefit from a more natural syntax. 


Now, then. Let's see you do the same study with TECO, lisp, or prolog!]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319757653.9399";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>310</wp:comment_id>
			<wp:comment_author><![CDATA[AndreasStefik]]></wp:comment_author>
			<wp:comment_author_email>stefika@gmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>76.77.226.41</wp:comment_author_IP>
			<wp:comment_date>2011-10-27 16:07:58</wp:comment_date>
			<wp:comment_date_gmt>2011-10-27 23:07:58</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[John,

I did not say anywhere that "accuracy is a linearly measurable, countable thing," a comment that is vague flaming at best. What I say in the paper is that we measured accuracy using a technique called artifact encoding. As I've already written on how it works extensively in academic work, I am going to decline to do so again here.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>302</wp:comment_parent>
			<wp:comment_user_id>6</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319756878.8262";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:13:"AndreasStefik";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>293</wp:comment_id>
			<wp:comment_author><![CDATA[Chris Parnin]]></wp:comment_author>
			<wp:comment_author_email>gameweld@gmail.com</wp:comment_author_email>
			<wp:comment_author_url>http://blog.ninlabs.com</wp:comment_author_url>
			<wp:comment_author_IP>24.98.197.10</wp:comment_author_IP>
			<wp:comment_date>2011-10-27 13:02:04</wp:comment_date>
			<wp:comment_date_gmt>2011-10-27 20:02:04</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Thanks!]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[true]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319745724.4245";s:7:"message";s:35:"Akismet caught this comment as spam";s:5:"event";s:10:"check-spam";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319756029.3118";s:7:"message";s:44:"jorge changed the comment status to approved";s:5:"event";s:15:"status-approved";s:4:"user";s:5:"jorge";}]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:14:"1319754638.958";s:7:"message";s:39:"jorge reported this comment as not spam";s:5:"event";s:10:"report-ham";s:4:"user";s:5:"jorge";}]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_user_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_user</wp:meta_key>
				<wp:meta_value><![CDATA[jorge]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>308</wp:comment_id>
			<wp:comment_author><![CDATA[AndreasStefik]]></wp:comment_author>
			<wp:comment_author_email>stefika@gmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>76.77.226.41</wp:comment_author_IP>
			<wp:comment_date>2011-10-27 15:48:19</wp:comment_date>
			<wp:comment_date_gmt>2011-10-27 22:48:19</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Don,

1) As I said, testing other examples is certainly a valid thing for people to do. I imagine that no matter what examples we tested, someone would complain.
2) I agree. We have a whole host of tests planned. To say that our test is NOT the final word is a significant understatement. It's actually pretty amazing how many people are interpreting our work as somehow a claim of "proof." It's one set of carefully controlled observations. People are reading into it much more than they should. That's the Internet, I guess.
3) You are thinking of different kind of experimental design. We ran a repeated measures design, which means any given participant used only one language for the entire test.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>6</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319755699.8661";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:13:"AndreasStefik";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>296</wp:comment_id>
			<wp:comment_author><![CDATA[Sina Bahram]]></wp:comment_author>
			<wp:comment_author_email>sina@sinabahram.com</wp:comment_author_email>
			<wp:comment_author_url>http://www.SinaBahram.com</wp:comment_author_url>
			<wp:comment_author_IP>152.14.241.151</wp:comment_author_IP>
			<wp:comment_date>2011-10-27 14:12:06</wp:comment_date>
			<wp:comment_date_gmt>2011-10-27 21:12:06</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[This is an extremely sincere and helpful response, Dr. Steffick. While your paper might make some controversial claims, it's so gratifying to see them backed up with actual statistics (which can be validated, reproduced, and analyzed) instead of gut feelings and emotionally charged unproductive comments. I look forward to reading more papers from you and your team in the future. Congratulations on the work thus far.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319749926.8833";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>298</wp:comment_id>
			<wp:comment_author><![CDATA[Sina Bahram]]></wp:comment_author>
			<wp:comment_author_email>sina@sinabahram.com</wp:comment_author_email>
			<wp:comment_author_url>http://www.SinaBahram.com</wp:comment_author_url>
			<wp:comment_author_IP>152.14.241.151</wp:comment_author_IP>
			<wp:comment_date>2011-10-27 14:13:11</wp:comment_date>
			<wp:comment_date_gmt>2011-10-27 21:13:11</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Oh, and sorry for mistyping your name!]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319749991.2927";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>302</wp:comment_id>
			<wp:comment_author><![CDATA[John Haugeland]]></wp:comment_author>
			<wp:comment_author_email>johnhaugeland@yahoo.com</wp:comment_author_email>
			<wp:comment_author_url>http://fullof.bs/</wp:comment_author_url>
			<wp:comment_author_IP>207.188.246.146</wp:comment_author_IP>
			<wp:comment_date>2011-10-27 14:58:41</wp:comment_date>
			<wp:comment_date_gmt>2011-10-27 21:58:41</wp:comment_date_gmt>
			<wp:comment_content><![CDATA["Response: This is false. Results show there is a 95.3% chance that novice Quorum users were more accurate than Perl users and a 99.6% chance that they were more accurate than Randomo. To say otherwise is misrepresentative of our results."

Your sample size and test structure is entirely inadequate to make these claims.  The idea that accuracy is a linearly measurable, countable thing shows a severe disconnect between this study and how work actually proceeds in the field.

I would strongly recommend that you take the time to investigate the work that was done in the 1970s, which does a far better and more scientifically legitimate job of making a survey like this.  Much of it underlies the construction of the COCOMO-II project.

It's worth noting that their results, which are taken over tens of thousands of programmers over the course of five years, suggest that your fundamental measurement is essentially nonsense.  This is just cyclomatic complexity without a null hypothesis all over again.

These claims aren't controversial.  They're just meaningless.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319752721.7454";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>307</wp:comment_id>
			<wp:comment_author><![CDATA[Don Satow]]></wp:comment_author>
			<wp:comment_author_email>dsatow@gmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>63.81.2.130</wp:comment_author_IP>
			<wp:comment_date>2011-10-27 15:10:51</wp:comment_date>
			<wp:comment_date_gmt>2011-10-27 22:10:51</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[While interesting, I see problems in the actual executing.
1) Many introductions to PERL use C style objects instead of easier to learn objects for a function.  The use of || instead of 'or' is one such example.  Many programming introductions teach || because its very C like instead of the more pseudo language style of 'or'  and as such the teaching of the language maybe biased towards how the lesson was taught.  It would have been better to use a more structured language.  One of the tenants of PERL is that 'there are many ways of skinning the cat' so to speak.  The for loop noted is a very C like construct verses creating a simpler for(a .. b) construct.
2) The number of actual programming languages are low (1).  A better test would be to reapply the test more languages.  Python, bash, ruby, tcl are all valid scripting languages.
3) With such a low test subject count, as noted, the deviation might be a little high.  But also with a low test subject count, the order in which the tests occurred might also be an issue.  If Quorum was taught before Randomo, the subjects learning Randomo would make mistakes using the wrong replacement  characters.  The reverse instruction order also needs to be tested to prove these claims.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319753451.7462";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>314</wp:comment_id>
			<wp:comment_author><![CDATA[Brad McEvoy]]></wp:comment_author>
			<wp:comment_author_email>brad@bradmcevoy.com</wp:comment_author_email>
			<wp:comment_author_url>http://www.bradmcevoy.com/</wp:comment_author_url>
			<wp:comment_author_IP>58.28.124.90</wp:comment_author_IP>
			<wp:comment_date>2011-10-27 17:05:58</wp:comment_date>
			<wp:comment_date_gmt>2011-10-28 00:05:58</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Andreas, you're awesome. The world needs more of your genes. If i were female I would offer to help propagate them.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319760358.6298";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>315</wp:comment_id>
			<wp:comment_author><![CDATA[AndreasStefik]]></wp:comment_author>
			<wp:comment_author_email>stefika@gmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>76.77.226.41</wp:comment_author_IP>
			<wp:comment_date>2011-10-27 17:06:08</wp:comment_date>
			<wp:comment_date_gmt>2011-10-28 00:06:08</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[John,

Exactly, I couldn't agree more! Thanks so much for your insightful comment! Perl is just a collection of language design choices, which many other languages share. By starting to break down the problem, we "might" be able to gain some insight.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>313</wp:comment_parent>
			<wp:comment_user_id>6</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319760368.1096";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:13:"AndreasStefik";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>316</wp:comment_id>
			<wp:comment_author><![CDATA[AndreasStefik]]></wp:comment_author>
			<wp:comment_author_email>stefika@gmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>76.77.226.41</wp:comment_author_IP>
			<wp:comment_date>2011-10-27 17:06:35</wp:comment_date>
			<wp:comment_date_gmt>2011-10-28 00:06:35</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[ROFL]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>314</wp:comment_parent>
			<wp:comment_user_id>6</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319760395.2779";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:13:"AndreasStefik";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>321</wp:comment_id>
			<wp:comment_author><![CDATA[Lewis Oxnard]]></wp:comment_author>
			<wp:comment_author_email>lewisoxnard28@yahoo.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>66.93.173.67</wp:comment_author_IP>
			<wp:comment_date>2011-10-27 18:43:26</wp:comment_date>
			<wp:comment_date_gmt>2011-10-28 01:43:26</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Seriously? 6 test subjects per language? That sample size is so small as to be nearly worthless. The only thing that the study is good for is to suggest that a real study be done with a sample size of two orders of magnitude (or more) larger that it laughingly small size it was done with. Variances in aptitude of one or more subjects is enough to completely invalidate the results. Also I didn't get an impression that the study was double-blind or that efforts were made to prevent the bias of the test creators and administrators out of the process, casting further doubt on any remaining validity of the study. Sorry, try again.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>308</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319766207.0194";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>324</wp:comment_id>
			<wp:comment_author><![CDATA[Norbert]]></wp:comment_author>
			<wp:comment_author_email>nthiebaud@gmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>24.173.34.18</wp:comment_author_IP>
			<wp:comment_date>2011-10-27 19:02:32</wp:comment_date>
			<wp:comment_date_gmt>2011-10-28 02:02:32</wp:comment_date_gmt>
			<wp:comment_content><![CDATA["Results show there is a 95.3% chance" Really ? 3 significant digits ?]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319767352.7663";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>325</wp:comment_id>
			<wp:comment_author><![CDATA[Joe Landman]]></wp:comment_author>
			<wp:comment_author_email>joe@scalability.org</wp:comment_author_email>
			<wp:comment_author_url>http://scalability.org</wp:comment_author_url>
			<wp:comment_author_IP>70.88.96.213</wp:comment_author_IP>
			<wp:comment_date>2011-10-27 19:33:39</wp:comment_date>
			<wp:comment_date_gmt>2011-10-28 02:33:39</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[When I first read the description, I thought to myself "oh no, yet another 'Perl is indistinguishable from line noise' argument".  This one wasn't just that, it had statistics.  And graphs.

Ok. Time for the critique (and yes I read, and understood the entire paper ... read up on my background at the website linked).

First:  Should be fairly obvious, but your sample size is too small for you to make anything even remotely approaching the sweeping generalizations you made.  Specifically "while Perl users were unable to write programs more accurately than those using a language designed with syntax chosen randomly from the ASCII table."  Had I been a reviewer on this paper, given this statistically insignificant sample size ... yeah, I probably would have recommended against publication, just based upon that.   Your sample size needs to be at least an order of magnitude larger.  Two OOM would be better, but lets start with one.  Even then, if you use that as a proxy for the entire novice non-programming community (even make a guess at what the size of this population is ... 1E+6 people?  1E+7 people?), I'd suggest something closer to the square root of the size of the population for the scale of the study you want to do.  Your statistics would be more meaningful, and your error bars would be (hopefully) smaller.  Which brings us to point number 

2) How on earth can you claim that your two data sets (say Quorum and Perl or Randomo) are significant when the points all fall within the error bars of each other?  Way back when I was TA'ing undergraduate physics lab, yeah, we saw that sort of mistake, with far simpler statistics.  But it is a common mistake.  Put the points for Quorum and Perl on the same graph with their error bars.  If the points representing the measurements are within the same error bars, within 1-2 sigma of the value, you do not have any basis to call these measurements distinguishable.  They are in-fact indistinguishable within the error of the measurment (which is high in large part due to the miniscule sample size).

Notice I am not attacking your thesis, that being that well designed programming languages that take into account how people think of programming languages and syntax.  I believe this to be a very valuable direction for research, and the results, when performed correctly, could be extremely beneficial to future language designers.

I am attacking your drawing of conclusions from a) too small a sample to be meaningful, and b) then doubling down on this issue and generating one of those "Perl is indistinguishable from random line noise" posts, when clearly, your own data not only doesn't support this, but when interpreted correctly, actively prevents you from drawing such a conclusion (see point 2 above).  

I have no problem indicating that I actively use Perl, and I find such attacks (be they lowbrow or otherwise) as tedious as they are poorly informed.  I would honestly have been as concerned with your analysis had this been Java, Python, etc. 

The analysis, if done correctly, with a far larger sample set, as well as multiple other languages, would be interesting.  I'd like to see numerous RAD languages included.  I don't think the "Randomo" language actually contributed anything to the mix, it may have actually detracted from the quality of the study.  Its not a real language in the sense of a compiler/interpreter (unless that is, you built a grammar, and a compiler or interpreter).  So from a pragmatic point of view, exactly what is the point of it (except for the bashing of Perl I mentioned before)?

I look forward to the larger sample sets.  It would be interesting to compare Quorum to Cobol (I noted the similarity myself) which was designed with a similar concept in mind.  As well as Fortran (still a staple of high performance computing), C++, Matlab/Octave, Chapel, and other languages that are designed for a specific set of tasks.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319769219.7762";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>350</wp:comment_id>
			<wp:comment_author><![CDATA[AndreasStefik]]></wp:comment_author>
			<wp:comment_author_email>stefika@gmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>146.163.144.209</wp:comment_author_IP>
			<wp:comment_date>2011-10-28 07:47:36</wp:comment_date>
			<wp:comment_date_gmt>2011-10-28 14:47:36</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Joe,

Looking up the math for a repeated measures ANOVA, the test we ran, would probably help you understand what is going on in this paper.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>325</wp:comment_parent>
			<wp:comment_user_id>6</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319813256.9633";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:13:"AndreasStefik";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>351</wp:comment_id>
			<wp:comment_author><![CDATA[AndreasStefik]]></wp:comment_author>
			<wp:comment_author_email>stefika@gmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>146.163.144.209</wp:comment_author_IP>
			<wp:comment_date>2011-10-28 08:03:49</wp:comment_date>
			<wp:comment_date_gmt>2011-10-28 15:03:49</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Lewis,

This is a mathematical argument you are (incorrectly) making. The results show the effect between languages is so large (partial-eta = .508), that it can even be detected in small samples. Had the effect not accounted for so much variance in the sample, statistics packages would have kicked it back and said "Sorry, try again." The effect (language) accounts for "nearly" half of the variance in the sample. That's what the formal mathematical equations show and that is what we are reporting.

With that said, as I have discussed over and over again, and which I said in the paper, this is a small scale (proof-of-concept) study. Clearly, I would be tickled if the broad community learned from this paper that, indeed, doing language studies is possible, and that we can now start the process of getting to where psychology and medicine was many years ago (e.g., expensive, large-scale, double blind studies). Any reasonable scientist would conduct small-scale experiments before conducting larger ones. Heck, even the myth busters do that. Although I suppose they might blow up a car afterword ...]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>321</wp:comment_parent>
			<wp:comment_user_id>6</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319814229.5362";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:13:"AndreasStefik";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>348</wp:comment_id>
			<wp:comment_author><![CDATA[AndreasStefik]]></wp:comment_author>
			<wp:comment_author_email>stefika@gmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>146.163.144.209</wp:comment_author_IP>
			<wp:comment_date>2011-10-28 07:41:24</wp:comment_date>
			<wp:comment_date_gmt>2011-10-28 14:41:24</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Hi Pedantic,

Let me first say that I really do appreciate your thoughts and comment. You are right that my explanation is slightly off. I'm doing the best I can to explain the results to a (sometimes) angry and non-technical audience. You're right, I could probably be doing a better job of describing some of these things ...

If you can come up with a better way to express point 5 in plain English, and no one else in Internet land complains that they don't like your explanation either, I'll listen.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>344</wp:comment_parent>
			<wp:comment_user_id>6</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319812884.4636";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:13:"AndreasStefik";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>328</wp:comment_id>
			<wp:comment_author><![CDATA[Is this another &#8220;Perl indistinguishable from line noise&#8221; argument? Don&#8217;t know &#8230; | scalability.org]]></wp:comment_author>
			<wp:comment_author_email></wp:comment_author_email>
			<wp:comment_author_url>http://scalability.org/?p=3446</wp:comment_author_url>
			<wp:comment_author_IP>70.88.96.213</wp:comment_author_IP>
			<wp:comment_date>2011-10-27 20:04:51</wp:comment_date>
			<wp:comment_date_gmt>2011-10-28 03:04:51</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[[...] I took the time to point this out. I was nice about it, I didn&#8217;t fisk it, or rip them as others did on this and the other site. [...]]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type>pingback</wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319771091.8723";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>334</wp:comment_id>
			<wp:comment_author><![CDATA[codelion]]></wp:comment_author>
			<wp:comment_author_email>code@banks.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>137.132.250.14</wp:comment_author_IP>
			<wp:comment_date>2011-10-27 23:00:22</wp:comment_date>
			<wp:comment_date_gmt>2011-10-28 06:00:22</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[As a programming myself I can easily attest to the study, Perl code is barely readable for the novice user. I don't know what all these other people are coding in. If anything this study doesn't come as a surprise for me.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[true]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:14:"1319781622.319";s:7:"message";s:35:"Akismet caught this comment as spam";s:5:"event";s:10:"check-spam";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319823979.3457";s:7:"message";s:39:"jorge reported this comment as not spam";s:5:"event";s:10:"report-ham";s:4:"user";s:5:"jorge";}]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_user_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_user</wp:meta_key>
				<wp:meta_value><![CDATA[jorge]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319824004.1234";s:7:"message";s:44:"jorge changed the comment status to approved";s:5:"event";s:15:"status-approved";s:4:"user";s:5:"jorge";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>337</wp:comment_id>
			<wp:comment_author><![CDATA[Victor Engmark]]></wp:comment_author>
			<wp:comment_author_email>victor.engmark@gmail.com</wp:comment_author_email>
			<wp:comment_author_url>https://l0b0.wordpress.com/</wp:comment_author_url>
			<wp:comment_author_IP>84.73.54.61</wp:comment_author_IP>
			<wp:comment_date>2011-10-28 01:50:45</wp:comment_date>
			<wp:comment_date_gmt>2011-10-28 08:50:45</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[This, at least, seems sure (and awesome) after all the attention this has received:
1) You will achieve one of the major goals of this study, that of igniting the community to perform and discuss more actual research. Touchy-feely ranting and flaming will of course continue, but at least there should be a rational alternative.
2) This kind of research will receive the attention and funding necessary to perform research with larger sample sizes.
3) Language designers, developers, and ultimately users will benefit.

Keep up the good work!]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319791845.4073";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>365</wp:comment_id>
			<wp:comment_author><![CDATA[Chris]]></wp:comment_author>
			<wp:comment_author_email>birmingh@gmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>124.168.22.67</wp:comment_author_IP>
			<wp:comment_date>2011-10-28 18:42:31</wp:comment_date>
			<wp:comment_date_gmt>2011-10-29 01:42:31</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[What Ian said!]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>347</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:14:"1319852551.973";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>344</wp:comment_id>
			<wp:comment_author><![CDATA[Pedantic Statistician]]></wp:comment_author>
			<wp:comment_author_email>guest@host.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>141.14.164.50</wp:comment_author_IP>
			<wp:comment_date>2011-10-28 05:26:40</wp:comment_date>
			<wp:comment_date_gmt>2011-10-28 12:26:40</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[I like the study.  If nothing else, it'll start some folks talking.

But please, whatever you do, fix your interpretation of the p-values.  A p-value of .004 does NOT mean a 99.6% chance that the one is more accurate.  You can't say that from the data you have.

Yes, it's statistically significant.  Yes, that means we can reject the null and say that novice users of Quorum are not equally accurate, but that we can't reject the null hypothesis that Perl users and Randomo users are equally accurate.  So we have to say that Quorum users seem to be more accurate than Randomo users, but Perl users don't. 

But no, it doesn't say anything about the odds of one being more accurate than another.

A p-value of .004 means that there's only a .4% chance that you would get data this or more extreme if the null hypothesis is true.  The null here is probably that the accuracy rates are the same, so we can say that it's very unlikely we'd get these results if novices were equally accurate.  That's statistical significance.

What we can't say is how likely it is that they're equally accurate based on these data.  The p-value the odds of the data given the null hypothesis, NOT the odds of the hypothesis given the data.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319804800.1216";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>345</wp:comment_id>
			<wp:comment_author><![CDATA[Pedantic Statistician]]></wp:comment_author>
			<wp:comment_author_email>guest@host.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>141.14.164.50</wp:comment_author_IP>
			<wp:comment_date>2011-10-28 05:46:57</wp:comment_date>
			<wp:comment_date_gmt>2011-10-28 12:46:57</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Yes, a larger sample would be better and would likely spot the Perl/Randomo difference.  But the rough ordering of it is unlikely to change, and the moral about intuitiveness for novice users, is still supported pretty well.

As for more languages, you gotta start somewhere, and here's a pretty good place.

For the error bars: the stats don't QUITE work that way.  2 standard errors is a good approximation of the critical value, but keep in mind that in a comparison like this what matters is the standard error of the DIFFERENCE, not the standard errors of either estimate.  In general, twice the standard error of the difference will be smaller than the sum of the individual standard errors.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>325</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:14:"1319806017.503";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>347</wp:comment_id>
			<wp:comment_author><![CDATA[Ian]]></wp:comment_author>
			<wp:comment_author_email>transatlantek@gmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>50.134.130.68</wp:comment_author_IP>
			<wp:comment_date>2011-10-28 07:02:53</wp:comment_date>
			<wp:comment_date_gmt>2011-10-28 14:02:53</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Thanks for this study. It is high time that science actually made another stand in what is really an area of practiced witch-doctory. There are a great many people in the area of "programming". There are many in the area of "development". There are very few who actually practice "computer engineering" and there are fewer still who actually practice "computer science" (this might have been your degree, but do you still use the actual science?).

Computer Science is an incredibly young field full of incredible ignorance. Studies like this, whether flawed or not (I am not worthy to comment), can only add to the pool of knowledge we have about our field. Maybe one day we may all be enlightened.

Sir I salute you.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319810573.1412";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>352</wp:comment_id>
			<wp:comment_author><![CDATA[AndreasStefik]]></wp:comment_author>
			<wp:comment_author_email>stefika@gmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>146.163.144.209</wp:comment_author_IP>
			<wp:comment_date>2011-10-28 08:12:00</wp:comment_date>
			<wp:comment_date_gmt>2011-10-28 15:12:00</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Norbert,

This is a interesting question with a non-obvious answer. To the best of my knowledge, different statistics packages give different levels of precision. The various statistical packages vary in their level of precision, to my understanding. In R, for example, if I make have an example test like this:

&gt; a  b  t.test(a,b)

	Welch Two Sample t-test

data:  a and b 
t = -6, df = 8, p-value = 0.0003234
alternative hypothesis: true difference in means is not equal to 0 
95 percent confidence interval:
 -8.306004 -3.693996 
sample estimates:
mean of x mean of y 
        3         9 

Notice the number of digits. With package X, your results may vary.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>324</wp:comment_parent>
			<wp:comment_user_id>6</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319814720.7799";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:13:"AndreasStefik";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>355</wp:comment_id>
			<wp:comment_author><![CDATA[Joe Landman]]></wp:comment_author>
			<wp:comment_author_email>joe@scalability.org</wp:comment_author_email>
			<wp:comment_author_url>http://scalability.org</wp:comment_author_url>
			<wp:comment_author_IP>173.10.54.97</wp:comment_author_IP>
			<wp:comment_date>2011-10-28 10:12:36</wp:comment_date>
			<wp:comment_date_gmt>2011-10-28 17:12:36</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[@Pedantic 

  Hmmm ... Lots of physicists would certainly like to hear why we were doing it wrong for the last hundred years or so :O.  Flippancy aside, error bars are there (if computed properly) to make sure you can visually tell if something is statistically significant in terms of difference or not.  Assuming these are calculated properly, its not the Perl/Randomo that is the problem.  Its Perl/Quorum that are indistinguishable.    Again, either the error bars are correct measures of the error in the measurement (which would support my interpretation) or the error bars as plotted have an entirely different meaning (which probably means they shouldn't be plotted as error bars, but as ... maybe ... box plots?  

No one was assailing the starting point.  I was pointing out that this is way early in the process and measurement to even consider drawing the type of conclusion that was drawn.  The data is pretty conclusive that it isn't conclusive ...]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>345</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319821956.2653";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>358</wp:comment_id>
			<wp:comment_author><![CDATA[Joe Landman]]></wp:comment_author>
			<wp:comment_author_email>joe@scalability.org</wp:comment_author_email>
			<wp:comment_author_url>http://scalability.org</wp:comment_author_url>
			<wp:comment_author_IP>173.10.54.97</wp:comment_author_IP>
			<wp:comment_date>2011-10-28 10:29:47</wp:comment_date>
			<wp:comment_date_gmt>2011-10-28 17:29:47</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[@AndreasStefik

   ... as noted, I read, and understood it.  I stand by my critiques that not only are your sample sizes too small to be meaningful, that because of the small sample sizes, your error bars are simply too large to allow you to draw the sort of conclusions that were drawn.  Do you disagree with this?  Are you indicating that a sample size of 24 people is adequate for this measurement?

  Again, as I said, I look forward to seeing what happens when the sample size is at least one OOM larger, preferably 2, and more languages included.  I personally would like to see R, Octave/Matlab, Fortran, and other commonly used  scientific languages included.  Wouldn't mind seeing Kx's 'q' language, as well as similar ones in there.  As I noted also, I don't see that "Randomo" actually adds anything to the discussion ... it may in fact detract from it.  If you feel you need to use a notoriously hard language to learn, why not use APL.  As a former APL user (of more than 20 years ago) I can attest that it has a long learning curve.

  This said, I have seen nothing in response to my critique on sample size, nor on error size and its effect on ability to support your conclusion that lead me to believe my critique is wrong, in error, or misinformed.  I did see a "review the math" which is ... well ... suspect ... as a response to the criticism.  There are size scaling effects in the error (standard deviations) that the greater number of samples accords you.  Conversely, these effects bite you hard if you attempt to imply a greater resolving ability than your data actually allows.

  If you insist upon using such a small number of samples, the statistics, pretty much no matter how you play with them, no matter which techniques you use, you will still be stuck with that annoying N**0.5 problem, for small N on your SD values.  Not much you can do there.  That is the scaling problem you have to deal with, and the right way to fix it isn't to tell critics to reread something they know,  it is to get more data.  The former doesn't address the criticism.  The latter does.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>350</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319822987.9844";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>359</wp:comment_id>
			<wp:comment_author><![CDATA[Joe Landman]]></wp:comment_author>
			<wp:comment_author_email>joe@scalability.org</wp:comment_author_email>
			<wp:comment_author_url>http://scalability.org</wp:comment_author_url>
			<wp:comment_author_IP>173.10.54.97</wp:comment_author_IP>
			<wp:comment_date>2011-10-28 10:30:59</wp:comment_date>
			<wp:comment_date_gmt>2011-10-28 17:30:59</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Thats N** (-0.5) ... my bad.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>358</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319823059.8083";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>361</wp:comment_id>
			<wp:comment_author><![CDATA[AndreasStefik]]></wp:comment_author>
			<wp:comment_author_email>stefika@gmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>146.163.144.209</wp:comment_author_IP>
			<wp:comment_date>2011-10-28 11:52:48</wp:comment_date>
			<wp:comment_date_gmt>2011-10-28 18:52:48</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[The problem you are having, I suspect, is that, unlike a simple T-test, it is genuinely not obvious how to tell whether a result is significant from a repeated measures design from visual inspection alone, unless you are familiar with the equations.

Seriously, don't take my word for it. Check out the repeated measures ANOVA equations and then come back and take a second look with a different frame of reference as to how this is computed. It helps. Really.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>355</wp:comment_parent>
			<wp:comment_user_id>6</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1319827968.7456";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:13:"AndreasStefik";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>384</wp:comment_id>
			<wp:comment_author><![CDATA[Christian Walde]]></wp:comment_author>
			<wp:comment_author_email>walde.christian@googlemail.com</wp:comment_author_email>
			<wp:comment_author_url>http://cat.eatsmou.se</wp:comment_author_url>
			<wp:comment_author_IP>92.77.75.180</wp:comment_author_IP>
			<wp:comment_date>2011-11-01 14:08:15</wp:comment_date>
			<wp:comment_date_gmt>2011-11-01 21:08:15</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[&gt; 2. Claim: $a to $c initializations are non-idiomatic and borked (or old). The syntax ($a,$b,$c) = @_; would be better. Or similarly, people might have chosen different examples.

This claim was never made and using it is a flat out dodging of the actual issue that *every* aspect of your chosen teaching material was incredibly outdated and flawed. Your choice of this claim and the response to it is nearly indistringuishable from trolling. Congratulations on that.

I'm not sure if you're the kind of person who would even be interested in hearing what *actual* issues were there in the single sample you published or would be more interested in going "feh" and lifting your nose at such comments. As such i'll not bother at the moment, though you can feel free to let me know if you're willing to engage in actual discourse. You have my email.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1320181695.4089";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>477</wp:comment_id>
			<wp:comment_author><![CDATA[Matt]]></wp:comment_author>
			<wp:comment_author_email>matt.mcknight@gmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>96.255.42.145</wp:comment_author_IP>
			<wp:comment_date>2011-11-19 22:26:57</wp:comment_date>
			<wp:comment_date_gmt>2011-11-20 06:26:57</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Quorum/Hop makes some weird decisions; "action" is a terrible name for a function/method/subroutine. I didn't understand how the sample answer code for Quorum in Fig. 2 could be correct without a main action.

I do see how getting parameters in Perl is bit a weird, enough to effect a result here...but ultimately quite flexible.  If the problem involved sending an arbitrary number of parameters to a function, surely it would be a bit more of a challenge in Quorum.

I also find the methodology of purely using code samples as non-representative of actual instruction techniques, and potentially biased towards more language heavy approaches in the code that become a serious burden for the frequent user.

This, then, is the serious problem with the objective of this course of study...finding a language that is easier for novices to learn in the first hour. If a language that is easier to learn in the first hour is less productive in the 10,000th hour, then it will ultimately fall into disuse. Is it better to give a student powerful tools- perhaps with training wheels, than to give them something that will ultimately prove frustrating?

I'd have a lot more confidence in your results if you had used Ruby or Python. I've had great success teaching kids (age 7-9) in Ruby and Python.  None of the "empirically designed" aspects of Quorum seem to match up to those...]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1321770417.8396";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>490</wp:comment_id>
			<wp:comment_author><![CDATA[Andreas Stefik]]></wp:comment_author>
			<wp:comment_author_email>stefika@gmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>76.77.233.51</wp:comment_author_IP>
			<wp:comment_date>2011-11-20 05:49:42</wp:comment_date>
			<wp:comment_date_gmt>2011-11-20 13:49:42</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[The comment from claim 2 came from one of the many responses we received, near verbatim. You can claim whatever you want, but a much more productive response would be to bring some scientific evidence to the table. Simply arguing about it and calling scientists trolls, without gathering data, is not a very effective scientific methodology.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>384</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1321796982.3575";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>492</wp:comment_id>
			<wp:comment_author><![CDATA[Andreas Stefik]]></wp:comment_author>
			<wp:comment_author_email>stefika@gmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>76.77.233.51</wp:comment_author_IP>
			<wp:comment_date>2011-11-20 06:09:44</wp:comment_date>
			<wp:comment_date_gmt>2011-11-20 14:09:44</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[A few thoughts here:

1) We didn't think the word action was very good choice either, but we ran two large-scale surveys with programmers and non-programmers. You can read about one of the two in this paper (2nd experiment):

A. Stefik and E. Gellenbeck. Empirical studies on programming language stimuli. Software Quality Journal, 19(1):65-99, 2011. 10.1007/s11219-010-9106-7.

After we received that result, we disbelieved some of the results so strongly (e.g., : instead of . for calling actions, action instead of function, etc), that we ran a full replication study at a different university with different questions and a slightly different methodology. We basically received the same answer. Interestingly, I learned yesterday that the Looking Glass group at Washington University ran some experiments and has come to the same conclusion, independently. Go figure.

2) Figure 2.

While Quorum does not require a main method, sort of like Turing, many languages do. This may or may not leave those languages at a disadvantage, however we have not tested this. In other words, by not including those language's main method in the experiment, we may have actually given those languages an unfair advantage against Quorum. I "speculate" that Perl would have done worse under these conditions, but it's something we plan to test formally at some point, in many languages.

3) The results may not apply under condition X

Well yes, we agree. Our point was that, under the conditions of our test, we have shown statistical analysis regarding novice behavior. Obviously, considering the almost complete lack of evidence regarding programming language design, many more tests are needed to fill out what works and what doesn't.

I would caution you, however, not to assume that if a language is "easy" at hour X, that this necessarily correlates with it being "difficult" at hour Y. This is an empirical question, which I think needs to be hammered out scientifically.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>477</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1321798184.4838";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
		<title>A field study of API learning obstacles</title>
		<link>http://www.neverworkintheory.org/?p=220</link>
		<pubDate>Tue, 08 Nov 2011 22:57:06 +0000</pubDate>
		<dc:creator>jorge</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=220</guid>
		<description></description>
		<content:encoded><![CDATA[<em><a href="http://www.cs.mcgill.ca/~martin/index.html">Martin P. Robillard</a> and <a href="http://research.microsoft.com/en-us/people/rdeline/">Rob DeLine</a>. <strong><a href="http://www.springerlink.com/content/g32350137247p233/">"A field study of API learning obstacles"</a></strong> ESE 16 (6), 2011.</em>
<blockquote><em>Large APIs can be hard to learn, and this can lead to decreased programmer productivity. But what makes APIs hard to learn? We conducted a mixed approach, multi-phased study of the obstacles faced by Microsoft developers learning a wide variety of new APIs. The study involved a combination of surveys and in-person interviews, and collected the opinions and experiences of over 440 professional developers. We found that some of the most severe obstacles faced by developers learning new APIs pertained to the documentation and other learning resources. We report on the obstacles developers face when learning new APIs, with a special focus on obstacles related to API documentation. Our qualitative analysis elicited five important factors to consider when designing API documentation: documentation of intent; code examples; matching APIs with scenarios; penetrability of the API; and format and presentation. We analyzed how these factors can be interpreted to prioritize API documentation development efforts.</em></blockquote>
Developers don't live on Stack Overflow alone. For many API questions, there are still materials and documentation that can help them speed up their learning process (or there <em>should </em>be, I think, while I try to learn node.js...). Robillard and DeLine's report is full of rich insights and practical implications relevant for anyone trying to improve the developer documentation of their products.]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>220</wp:post_id>
		<wp:post_date>2011-11-08 14:57:06</wp:post_date>
		<wp:post_date_gmt>2011-11-08 22:57:06</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>a-field-study-of-api-learning-obstacles</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="documentation"><![CDATA[Documentation]]></category>
		<category domain="category" nicename="qualitative-studies"><![CDATA[Qualitative Studies]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>411</wp:comment_id>
			<wp:comment_author><![CDATA[Irving Reid (@irvingreid)]]></wp:comment_author>
			<wp:comment_author_email>irving@cfrq.net</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>66.207.208.98</wp:comment_author_IP>
			<wp:comment_date>2011-11-09 07:07:07</wp:comment_date>
			<wp:comment_date_gmt>2011-11-09 15:07:07</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Is there a non-paywalled link to this publication? Neither of the authors lists it on their web site.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1320851227.9732";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>413</wp:comment_id>
			<wp:comment_author><![CDATA[Jorge Aranda]]></wp:comment_author>
			<wp:comment_author_email>jorge@neverworkintheory.org</wp:comment_author_email>
			<wp:comment_author_url>http://www.neverworkintheory.org/</wp:comment_author_url>
			<wp:comment_author_IP>142.104.21.204</wp:comment_author_IP>
			<wp:comment_date>2011-11-09 09:34:08</wp:comment_date>
			<wp:comment_date_gmt>2011-11-09 17:34:08</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[I wish there was. Whenever I find one I try to link to it from the corresponding blog post. However, researchers will almost always send you a copy if you ask for one nicely :-).]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>411</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1320860048.7413";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:5:"jorge";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
		<title>Codermetrics?</title>
		<link>http://www.neverworkintheory.org/?p=225</link>
		<pubDate>Mon, 28 Nov 2011 23:48:01 +0000</pubDate>
		<dc:creator>jorge</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=225</guid>
		<description></description>
		<content:encoded><![CDATA[As a new parent I haven't had much chance to go to the movies lately, and among the many new releases I've missed is <a title="Moneyball on IMDB" href="http://www.imdb.com/title/tt1210166/">"Moneyball"</a>. But I read enough about the movie to learn that it was about baseball and the folks behind <a href="http://en.wikipedia.org/wiki/Sabermetrics">Sabermetrics</a>, and so it did not surprise me when, shortly after the film came out, <a href="http://third-bit.com/">Greg Wilson</a> pointed me to the article <a href="http://radar.oreilly.com/2011/10/moneyball-for-software-enginee.html">"Moneyball for software engineering"</a>, by Jonathan Alexander, who also wrote <a href="http://shop.oreilly.com/product/0636920020134.do">a book</a> on the same topic. I decided to write about it here because it is, sadly, an illustrative example of the <a title="My previous post on controlling what you can't measure" href="http://catenary.wordpress.com/2007/01/11/controlling-what-you-cant-measure/">"you can't control what you can measure" trap</a> that we're too prone to fall for in our domain.

In his article, Alexander argues that the statistical approach featured in Moneyball can be applied to the software development domain. By gathering the right stats, he says, software companies can better assess the contributions from their employees, and create "more competitive teams". Here's a few of Alexander's proposed measurements:
<ul>
	<li>Productivity by looking at the number of tasks completed or the total complexity rating for all completed tasks.</li>
	<li>Utility by keeping track of how many areas someone works on or covers.</li>
	<li>Teamwork by tallying how many times someone helps or mentors others, or demonstrates behavior that motivates teammates.</li>
	<li>Innovation by noting the times when someone invents, innovates, or demonstrates strong initiative to solve an important problem.</li>
</ul>
If you're going down this route, you'll also need some way to assess success, and software development does not have the simple win/loss that baseball has. Alexander has a few metrics in mind though:
<ul>
	<li>Looking at the number of users acquired or lost.</li>
	<li>Calculating the impact of software enhancements that deliver benefit to existing users.</li>
	<li>...and so on.</li>
</ul>
And once you have all these metrics, you could play around with them, assessing performance, identifying different kinds of "roles", coaching on skills that the team is lacking, <em>et cetera</em>. That is Alexander's proposal, in short, and he says that a "growing number of companies" are starting to use it.

But there is no data on the efficacy of this approach, and frankly I cannot see how it could possibly work. There are two major problems with it.

The first problem is assuming that a technique that works for baseball will also work for software development. Baseball is the perfect home for a stats-heavy approach. It is a very discrete sport---that is, you can get discrete data fairly easily. There are clear win/loss conditions, and every single play can be classified according to given criteria and assigned to individual players with relative ease. That's not the case with software development. Exactly what counts as an innovation? What counts as an area of work? How do you assign a complexity rating for a completed task? And how could you ever get agreement on your answers to questions like these?

The second problem is that measurements can be gamed, and <a title="as discussed in this Wikipedia article about Campbell's Law" href="http://en.wikipedia.org/wiki/Campbell%27s_Law">measurements used to shape policy will be gamed</a>. Perhaps in baseball this is not an issue, and that may be because Sabermetrics measurements (as far as I know) tend not to focus on interpersonal or subjective criteria. That is not the case here, and it<em> can't</em> be the case here, as good software development often depends on interpersonal and subjective criteria. <a href="http://coderoom.wordpress.com/2010/01/28/3-simple-rules-that-will-make-you-a-superstar-developer/">See here for a wonderful illustration of a nightmare scenario that nonetheless would do great on the performance metrics above</a>.

This is not to say that measurements are not useful in our domain---we've covered several examples of the opposite in this blog already. But we often jump to the numbers a bit too quickly, no matter how careless was the process to come up with them. Perhaps this is because seeing percentages or trends gives us a warm fuzzy illusion of control, and we tend to forget that we're dealing with pretty complex constructs that can't be captured easily, and with intelligent professionals that will react to our observations in unintended ways. My advice: always be suspicious of your subjective appraisals, but if you start collecting metrics, be extra suspicious. All those seemingly hard numbers might make you forget that they are probably still subjective, but dressed up in objectivity: wolves in sheeps' clothing.]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>225</wp:post_id>
		<wp:post_date>2011-11-28 15:48:01</wp:post_date>
		<wp:post_date_gmt>2011-11-28 23:48:01</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>codermetrics</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="metrics"><![CDATA[Metrics]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>800</wp:comment_id>
			<wp:comment_author><![CDATA[Dan Enthoven]]></wp:comment_author>
			<wp:comment_author_email>denthoven@evolvondemand.com</wp:comment_author_email>
			<wp:comment_author_url>http://www.evolvondemand.com</wp:comment_author_url>
			<wp:comment_author_IP>67.188.43.39</wp:comment_author_IP>
			<wp:comment_date>2012-02-01 15:40:25</wp:comment_date>
			<wp:comment_date_gmt>2012-02-01 23:40:25</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[I think the key thing about the Moneyball story for companies is that the most important decision is who you hire.  This is what Billy Beane was really looking at.

What percent of people that get hired at your company wash out?  20%?  30%?  A great hire raises the quality of everyone's work, and a bad hire demotivates everyone. 

Most companies have a really bad process for determining who to hire. The most common tool is  use interviews. Charismatic people do well, but charisma doesn't equal performance.  

Other people give tests or "thought questions." (Write a code to find the prime numbers in this array.  How many AA batteries get sold each year?)

All the data out there shows that these filtering techniques are close to coin tossing when it comes to predicting performance.  

As companies think about how to use analytics, i think hiring has got to be the first thing they review.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1328139625.2318";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>660</wp:comment_id>
			<wp:comment_author><![CDATA[Jorge Aranda]]></wp:comment_author>
			<wp:comment_author_email>jorge@neverworkintheory.org</wp:comment_author_email>
			<wp:comment_author_url>http://www.neverworkintheory.org/</wp:comment_author_url>
			<wp:comment_author_IP>142.104.21.204</wp:comment_author_IP>
			<wp:comment_date>2011-11-29 11:10:04</wp:comment_date>
			<wp:comment_date_gmt>2011-11-29 19:10:04</wp:comment_date_gmt>
			<wp:comment_content><![CDATA["Even if Campbell’s Law didn’t apply and you could do accurate measurement on individual workers, it’s a bad idea to try to optimize individual workers, because people will optimize locally (for their own work) rather than optimizing the whole system (which is what you care about)"

That's a great point that should've been in the article too. Thanks!]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>659</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1322593804.3964";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:5:"jorge";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>661</wp:comment_id>
			<wp:comment_author><![CDATA[Jorge Aranda]]></wp:comment_author>
			<wp:comment_author_email>jorge@neverworkintheory.org</wp:comment_author_email>
			<wp:comment_author_url>http://www.neverworkintheory.org/</wp:comment_author_url>
			<wp:comment_author_IP>142.104.21.204</wp:comment_author_IP>
			<wp:comment_date>2011-11-29 11:12:10</wp:comment_date>
			<wp:comment_date_gmt>2011-11-29 19:12:10</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[One of my old favourites is measuring programmer productivity by lines of code written. It lends itself to all sorts of awful abuse.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>658</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:14:"1322593930.079";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:5:"jorge";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>654</wp:comment_id>
			<wp:comment_author><![CDATA[pmorrisonfl]]></wp:comment_author>
			<wp:comment_author_email>pmorrisonfl@gmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>108.203.0.6</wp:comment_author_IP>
			<wp:comment_date>2011-11-28 16:20:29</wp:comment_date>
			<wp:comment_date_gmt>2011-11-29 00:20:29</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[The book 'Measuring and Managing Performance In Organizations', Robert Austin, Dorset House 1996 covers this 'measurement dysfunction' very well.  It was extracted from the author's PhD thesis on the topic, so there's pretty good supporting evidence behind it.  I think Daniel Pink's TED talk on motivation is also good.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1322526029.9056";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>655</wp:comment_id>
			<wp:comment_author><![CDATA[Jorge Aranda]]></wp:comment_author>
			<wp:comment_author_email>jorge@neverworkintheory.org</wp:comment_author_email>
			<wp:comment_author_url>http://www.neverworkintheory.org/</wp:comment_author_url>
			<wp:comment_author_IP>142.104.21.204</wp:comment_author_IP>
			<wp:comment_date>2011-11-28 16:23:02</wp:comment_date>
			<wp:comment_date_gmt>2011-11-29 00:23:02</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Thanks. I know of Austin's book, but I haven't read it yet. His (and Lee Devin's) "Artful Making" book, however, is one of my favourites.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>654</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1322526182.2212";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:5:"jorge";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>657</wp:comment_id>
			<wp:comment_author><![CDATA[Software Carpentry &raquo; Three Short Thoughts]]></wp:comment_author>
			<wp:comment_author_email></wp:comment_author_email>
			<wp:comment_author_url>http://software-carpentry.org/2011/11/three-short-thoughts/</wp:comment_author_url>
			<wp:comment_author_IP>69.163.247.75</wp:comment_author_IP>
			<wp:comment_date>2011-11-29 06:43:45</wp:comment_date>
			<wp:comment_date_gmt>2011-11-29 14:43:45</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[[...] Aranda&#8217;s review of Codermetrics talks about the limitations to quantification in software engineering. I&#8217;ve said before that [...]]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type>pingback</wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:14:"1322577825.977";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>658</wp:comment_id>
			<wp:comment_author><![CDATA[Jamie Starke]]></wp:comment_author>
			<wp:comment_author_email>Jrstarke@gmail.com</wp:comment_author_email>
			<wp:comment_author_url>http://www.jamiestarke.com</wp:comment_author_url>
			<wp:comment_author_IP>24.68.120.137</wp:comment_author_IP>
			<wp:comment_date>2011-11-29 07:35:42</wp:comment_date>
			<wp:comment_date_gmt>2011-11-29 15:35:42</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Great article. One thing I'd like to add, how to you measure the number of times a person helps someone? How do you measure the quality of the help? If I give them the minimal help, they'll come ask me more, and I can increase my help numbers, rather than tell them what they should know up front. Totally set to game the numbers. Same kind of goes for the tasks completed. Who decides the complexity rating? If its automated, can I take a simple solution and increase the complexity unnessecarily to increase my numbers?]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1322580942.2829";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>659</wp:comment_id>
			<wp:comment_author><![CDATA[Lorin Hochstein]]></wp:comment_author>
			<wp:comment_author_email>lorin@isi.edu</wp:comment_author_email>
			<wp:comment_author_url>http://www.east.isi.edu/~lorin</wp:comment_author_url>
			<wp:comment_author_IP>65.114.169.36</wp:comment_author_IP>
			<wp:comment_date>2011-11-29 09:50:36</wp:comment_date>
			<wp:comment_date_gmt>2011-11-29 17:50:36</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[This post is bang-on, Jorge. 

I'll second the recommendation for Austin's book, he makes a good academic argument to illustrate Campbell's Law that you cite, how measurement is worse than useless for evaluation when it comes to individuals. 

Also recommend Deming's "Out of the Crisis" as a great book on measurement, even though it was written with manufacturing in mind and not software development. In particular, he makes points like:
* Even if Campbell's Law didn't apply and you could do accurate measurement on individual workers, it's a bad idea to try to optimize individual workers, because people will optimize locally (for their own work) rather than optimizing the whole system (which is what you care about)
* Because of random variation, the things that really matter in process measurement are the outliers, not whether X is 10% better than Y in the last measurement interval. (e.g., employee-of-the-month is meaningless)
* If you want to change overall outcomes, you have to introduce a change to the system. 

And, of course: http://dilbert.com/strips/comic/1995-11-13/]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>655</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1322589036.3177";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
		<title>The FCS1: A Language Independent Assessment of CS1 Knowledge</title>
		<link>http://www.neverworkintheory.org/?p=230</link>
		<pubDate>Fri, 02 Dec 2011 15:45:37 +0000</pubDate>
		<dc:creator>gvwilson</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=230</guid>
		<description></description>
		<content:encoded><![CDATA[<a href="http://www.aetew.com/">Allison Elliott Tew</a> and <a href="http://www.cc.gatech.edu/~guzdial/">Mark Guzdial</a>: "The FCS1: A Language Independent Assessment of CS1 Knowledge". SIGCSE'11, March 2011.
<blockquote><em>A primary goal of many CS education projects is to determine the extent to which a given intervention has had an impact on student learning. However, computing lacks valid assessments for pedagogical or research purposes. Without such valid assessments, it is difficult to accurately measure student learning or establish a relationship between the instructional setting and learning outcomes.
We developed the Foundational CS1 (FCS1) Assessment instrument, the first assessment instrument for introductory computer science concepts that is applicable across a variety of current pedagogies and programming languages. We applied methods from educational and psychological test development, adapting them as necessary to fit the disciplinary context. We conducted a large scale empirical study to demonstrate that pseudo-code was an appropriate mechanism for achieving programming language independence. Finally, we established the validity of the assessment using a multi-faceted argument, combining interview data, statistical analysis of results on the assessment, and CS1 exam scores.</em></blockquote>
People have been studying how we <em>learn</em> programming for even longer than they've been studying how we <em>do</em> it, and while the two aren't exactly the same, there's a lot of overlap in both methodologies and findings. Some of the best work I know has come out of the group at Georgia Tech led by Mark Guzdial (who is also a <a href="http://computinged.wordpress.com/">prolific and informative blogger</a>). In this paper, he and his student Allison Tew present the results of a multi-year project to develop an instrument that can be used to assess how well students have learned basic programming concepts, regardless of whether the language they learned in was Java, Python, or MATLAB. The long-term goal is to create a <a href="http://en.wikipedia.org/wiki/Concept_inventory">concept inventory</a> for computing similar to those that have been developed in physics, biology, and other sciences.

I think this is critically important work, and deserves a lot more attention from the software engineering community as a whole, not just that portion of it also interested in teaching. To paraphrase Dobzhansky, nothing in software engineering makes sense except in light of human psychology, so while measuring outputs like bugs per module is important, we won't know <em>why</em> some people are so much more productive than others until we get a handle on what people actually know.]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>230</wp:post_id>
		<wp:post_date>2011-12-02 07:45:37</wp:post_date>
		<wp:post_date_gmt>2011-12-02 15:45:37</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>the-fcs1-a-language-independent-assessment-of-cs1-knowledge</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="education"><![CDATA[Education]]></category>
		<category domain="category" nicename="quantitative-studies"><![CDATA[Quantitative Studies]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>682</wp:comment_id>
			<wp:comment_author><![CDATA[A decade of research and development on program animation: The Jeliot experience - It will never work in theory]]></wp:comment_author>
			<wp:comment_author_email></wp:comment_author_email>
			<wp:comment_author_url>http://www.neverworkintheory.org/?p=239</wp:comment_author_url>
			<wp:comment_author_IP>64.90.54.151</wp:comment_author_IP>
			<wp:comment_date>2011-12-10 13:08:37</wp:comment_date>
			<wp:comment_date_gmt>2011-12-10 21:08:37</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[[...] our two previous papers, this one is about software engineering education rather than software engineering per se, [...]]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type>pingback</wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1323551317.3341";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>671</wp:comment_id>
			<wp:comment_author><![CDATA[Online vs. Face-to-Face Pedagogical Code Reviews: An Empirical Comparison - It will never work in theory]]></wp:comment_author>
			<wp:comment_author_email></wp:comment_author_email>
			<wp:comment_author_url>http://www.neverworkintheory.org/?p=233</wp:comment_author_url>
			<wp:comment_author_IP>64.90.54.151</wp:comment_author_IP>
			<wp:comment_date>2011-12-04 11:41:53</wp:comment_date>
			<wp:comment_date_gmt>2011-12-04 19:41:53</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[[...] our previous selection, this paper comes from software engineering education rather than software engineering per se, but [...]]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type>pingback</wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1323027713.8234";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>1384</wp:comment_id>
			<wp:comment_author><![CDATA[Software Carpentry &raquo; If You Want to Teach, Isn&#8217;t It Only Fair to Learn a Few Things First?]]></wp:comment_author>
			<wp:comment_author_email></wp:comment_author_email>
			<wp:comment_author_url>http://software-carpentry.org/2012/06/if-you-want-to-teach-isnt-it-only-fair-to-learn-a-few-things-first/</wp:comment_author_url>
			<wp:comment_author_IP>69.163.247.75</wp:comment_author_IP>
			<wp:comment_date>2012-06-25 14:46:49</wp:comment_date>
			<wp:comment_date_gmt>2012-06-25 21:46:49</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[[...] ten years&#8217; use with physics, or its application to programming instruction). Find out what a concept inventory is, whether online code reviews help learners as much as their face-to-face equivalents, and [...]]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type>pingback</wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1340660809.5991";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
		<title>Online vs. Face-to-Face Pedagogical Code Reviews: An Empirical Comparison</title>
		<link>http://www.neverworkintheory.org/?p=233</link>
		<pubDate>Sun, 04 Dec 2011 19:41:47 +0000</pubDate>
		<dc:creator>gvwilson</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=233</guid>
		<description></description>
		<content:encoded><![CDATA[Christopher Hundhausen, Pawan Agarwal, and Michael Trevisan: "Online vs. Face-to-Face Pedagogical Code Reviews: An Empirical Comparison." <em>SIGCSE 2011</em>.
<blockquote><em>Given the increased importance of communication, teamwork, and critical thinking skills in the computing profession, we have been exploring studio-based instructional methods, in which students develop solutions and iteratively refine them through critical review by their peers and instructor. We have developed an adaptation of studio-based instruction for computing education called the pedagogical code review (PCR), which is modeled after the code inspection process used in the software industry. Unfortunately, PCRs are time-intensive, making them difficult to implement within a typical computing course. To address this issue, we have developed an online environment that allows PCRs to take place asynchronously outside of class. We conducted an empirical study that compared a CS 1 course with online PCRs against a CS 1 course with face-to-face PCRs. Our study had three key results: (a) in the course with face-to-face PCRs, student attitudes with respect to self-efficacy and peer learning were significantly higher; (b) in the course with face-to-face PCRs, students identified more substantive issues in their reviews; and (c) in the course with face-to-face PCRs, students were generally more positive about the value of PCRs. In light of our findings, we recommend specific ways online PCRs can be better designed.</em></blockquote>
Like our <a href="http://www.neverworkintheory.org/?p=230">previous selection</a>, this paper comes from software engineering education rather than software engineering per se, but has a lot to say about the latter. Code review is now a regular part of most open source projects, thanks in part to online code review tools like <a href="http://www.reviewboard.org/">ReviewBoard</a>. Here, the authors compare those kinds of reviews with face-to-face reviews, and find that the latter are more effective in several ways: people enjoy them more, they find more issues, and they are more likely to come away believing that reviews are worth doing.  It would be fascinating to replicate this study with both junior programmers joining established teams, and developers with more experience who are undertaking reviews systematically for the first time.]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>233</wp:post_id>
		<wp:post_date>2011-12-04 11:41:47</wp:post_date>
		<wp:post_date_gmt>2011-12-04 19:41:47</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>online-vs-face-to-face-pedagogical-code-reviews-an-empirical-comparison</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="controlled-experiments"><![CDATA[Controlled Experiments]]></category>
		<category domain="category" nicename="education"><![CDATA[Education]]></category>
		<category domain="category" nicename="quantitative-studies"><![CDATA[Quantitative Studies]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>1386</wp:comment_id>
			<wp:comment_author><![CDATA[Software Carpentry &raquo; If You Want to Teach, Isn&#8217;t It Only Fair to Learn a Few Things First?]]></wp:comment_author>
			<wp:comment_author_email></wp:comment_author_email>
			<wp:comment_author_url>http://software-carpentry.org/2012/06/if-you-want-to-teach-isnt-it-only-fair-to-learn-a-few-things-first/</wp:comment_author_url>
			<wp:comment_author_IP>69.163.247.75</wp:comment_author_IP>
			<wp:comment_date>2012-06-25 17:34:14</wp:comment_date>
			<wp:comment_date_gmt>2012-06-26 00:34:14</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[[...] or its application to programming instruction). Find out what a concept inventory is, whether online code reviews help learners as much as their face-to-face equivalents, and whether program animation can help people learn more quickly (hint: using animations is much [...]]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type>pingback</wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:14:"1340670854.132";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
		<title>Empirical Software Engineering&#039;s Greatest Hits</title>
		<link>http://www.neverworkintheory.org/?p=236</link>
		<pubDate>Mon, 05 Dec 2011 19:56:34 +0000</pubDate>
		<dc:creator>gvwilson</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=236</guid>
		<description></description>
		<content:encoded><![CDATA[Here are a couple of videos (the first about 8 minutes long, the second over an hour) discussing empirical studies in software engineering, and why they matter.

http://www.youtube.com/watch?v=T_63dB200tE

http://vimeo.com/9270320]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>236</wp:post_id>
		<wp:post_date>2011-12-05 11:56:34</wp:post_date>
		<wp:post_date_gmt>2011-12-05 19:56:34</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>empirical-software-engineerings-greatest-hits</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="uncategorized"><![CDATA[Uncategorized]]></category>
		<category domain="category" nicename="video"><![CDATA[Video]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_oembed_1a720afba01e5df87913e361f7e0a9b6</wp:meta_key>
			<wp:meta_value><![CDATA[<iframe src="http://player.vimeo.com/video/9270320" width="600" height="338" frameborder="0" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_oembed_f637e785f653fa2c095838444bff93ae</wp:meta_key>
			<wp:meta_value><![CDATA[<iframe width="600" height="450" src="http://www.youtube.com/embed/T_63dB200tE?fs=1&feature=oembed" frameborder="0" allowfullscreen></iframe>]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_oembed_0af38ab0a98e1c2c528f6e25e47df8d1</wp:meta_key>
			<wp:meta_value><![CDATA[<iframe src="http://player.vimeo.com/video/9270320" width="600" height="338" frameborder="0" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>704</wp:comment_id>
			<wp:comment_author><![CDATA[Pierre THierry]]></wp:comment_author>
			<wp:comment_author_email>pierre@nothos.net</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>90.13.46.50</wp:comment_author_IP>
			<wp:comment_date>2011-12-20 18:33:48</wp:comment_date>
			<wp:comment_date_gmt>2011-12-21 02:33:48</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Would there be somewhere a comprehensive list of papers and studies mentioned in the CUSEC talk?]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1324434828.6248";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>676</wp:comment_id>
			<wp:comment_author><![CDATA[Jeremy Noring]]></wp:comment_author>
			<wp:comment_author_email>kidjan@gmail.com</wp:comment_author_email>
			<wp:comment_author_url>http://goldfishforthought.blogspot.com</wp:comment_author_url>
			<wp:comment_author_IP>70.58.53.155</wp:comment_author_IP>
			<wp:comment_date>2011-12-05 12:10:42</wp:comment_date>
			<wp:comment_date_gmt>2011-12-05 20:10:42</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Thanks for both of these presentations; I watched both of them tonight and it was possibly the most eye-opening thing I've seen in years.

That said, I'm at a bit of a loss as to how to move forward.  Should I question Agile/Scrum stuff?  Should we do estimation as a team, and if so, how?  Having to question thing things you once assumed to be true is frankly daunting, so a summary of what we know to be true verses what's questionable at best might be helpful?]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:13:"1323115842.48";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>677</wp:comment_id>
			<wp:comment_author><![CDATA[Ken Bauer]]></wp:comment_author>
			<wp:comment_author_email>kenbauer@acm.org</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>72.249.185.194</wp:comment_author_IP>
			<wp:comment_date>2011-12-05 13:31:37</wp:comment_date>
			<wp:comment_date_gmt>2011-12-05 21:31:37</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Nicely put Greg, this video goes into my course materials for next semester.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1323120697.6182";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
		<title>A decade of research and development on program animation: The Jeliot experience</title>
		<link>http://www.neverworkintheory.org/?p=239</link>
		<pubDate>Sat, 10 Dec 2011 21:08:30 +0000</pubDate>
		<dc:creator>gvwilson</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=239</guid>
		<description></description>
		<content:encoded><![CDATA[Mordechai Ben-Ari and Roman Bednarik and Ronit Ben-Bassat Levy and Gil Ebel and Andrés Moreno and Niko Myller and Erkki Sutinen: "A decade of research and development on program animation: The Jeliot experience". <cite>Journal of Visual Languages &amp; Computing</cite>, 22(5), 2011.
<blockquote><em>Jeliot is a program animation system for teaching and learning elementary programming that has been developed over the past decade, building on the Eliot animation system developed several years before. Extensive pedagogical research has been done on various aspects of the use of Jeliot including improvements in learning, effects on attention, and acceptance by teachers. This paper surveys this research and development, and summarizes the experience and the lessons learned.</em></blockquote>
Like our two <a href="http://www.neverworkintheory.org/?p=230">previous</a> <a href="http://www.neverworkintheory.org/?p=233">papers</a>, this one is about software engineering education rather than software engineering per se, but (a) we're unlikely to improve the latter until we start getting the former right, and (b) education research has always had a strongly empirical flavor, which people studying "grown up" programmers could learn a lot from. What makes this paper interesting for me is that it describes how a specific research program has evolved over more than ten years. Ideas are turned into tools; how people use those tools, and what impact they have, are studied in situ; those studies produce new insights, which are turned into a new generation of tools, and the cycle repeats. Along the way, the researchers evolve as well: they learn how to ask more penetrating questions, and (hopefully) how to iterate more rapidly. Jonathan Weiner's book <a href="http://www.amazon.com/Time-Love-Memory-Biologist-Behavior/dp/0679444351"><cite>Time, Love, Memory</cite></a> does a great job of describing this process at greater length in genetics; young researchers (and those of us who are not so young) can learn a lot about our craft from reading both.

So what does this paper actually cover? It opens with an eight-paragraph summary of program visualization—tools and methods to draw pictures of the states of programs as they execute—followed by a brief discussion of the difference between <em>program</em> animation and <em>algorithm</em> animation. Section 3 then summarizes the evolution of their software testbed, while Section 4 shows readers what it looks like now. Sections 5-10 are the meat of the paper: what do users learn, and what effect does program visualization have on attention (both in the classroom as a whole and at the individual level), on teachers, and on collaboration. Section 11, an in-depth summary of lessons learned. In a way, it's the whole point of the paper, and everything that comes before it is scene-setting. I wish there were more summaries and retrospectives like this, since every shared insight can save other designers or researchers months of wasted effort going down blind alleys.]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>239</wp:post_id>
		<wp:post_date>2011-12-10 13:08:30</wp:post_date>
		<wp:post_date_gmt>2011-12-10 21:08:30</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>a-decade-of-research-and-development-on-program-animation-the-jeliot-experience</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="education"><![CDATA[Education]]></category>
		<category domain="category" nicename="tools"><![CDATA[Tools]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>1396</wp:comment_id>
			<wp:comment_author><![CDATA[Software Carpentry &raquo; If You Want to Teach, Isn&#8217;t It Only Fair to Learn a Few Things First?]]></wp:comment_author>
			<wp:comment_author_email></wp:comment_author_email>
			<wp:comment_author_url>http://software-carpentry.org/2012/06/if-you-want-to-teach-isnt-it-only-fair-to-learn-a-few-things-first/</wp:comment_author_url>
			<wp:comment_author_IP>69.163.247.75</wp:comment_author_IP>
			<wp:comment_date>2012-06-27 02:58:19</wp:comment_date>
			<wp:comment_date_gmt>2012-06-27 09:58:19</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[[...] whether online code reviews help learners as much as their face-to-face equivalents, and whether program animation can help people learn more quickly (hint: using animations is much less effective than building animations). Read Mark Guzdial&#8217;s [...]]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type>pingback</wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1340791099.6962";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
		<title>Research In Progress: How Mozilla Builds Software</title>
		<link>http://www.neverworkintheory.org/?p=244</link>
		<pubDate>Tue, 13 Dec 2011 12:28:23 +0000</pubDate>
		<dc:creator>gvwilson</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=244</guid>
		<description></description>
		<content:encoded><![CDATA[WebFWD recently <a href="http://blog.webfwd.org/post/13973466029/code-doesnt-build-software-people-build-software">posted</a> a video presentation by UC Berkeley's Prof. <a href="http://facultybio.haas.berkeley.edu/faculty-list/bahrami-homa">Homa Bahrami</a> and her student Claire Rudolph, who studied how Mozilla builds software.  It's full of useful insights about how a distributed mix of volunteers and paid professionals builds world-class software without drowning in information, and is a great example of research in progress.  We'd welcome pointers to more presentations of this kind.

<iframe src="http://player.vimeo.com/video/33371362?title=0&amp;byline=0&amp;portrait=0" frameborder="0" width="580" height="435"></iframe>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>244</wp:post_id>
		<wp:post_date>2011-12-13 04:28:23</wp:post_date>
		<wp:post_date_gmt>2011-12-13 12:28:23</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>research-in-progress-how-mozilla-builds-software</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="qualitative-studies"><![CDATA[Qualitative Studies]]></category>
		<category domain="category" nicename="video"><![CDATA[Video]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>760</wp:comment_id>
			<wp:comment_author><![CDATA[Cedric]]></wp:comment_author>
			<wp:comment_author_email>rixed@free.fr</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>80.214.8.191</wp:comment_author_IP>
			<wp:comment_date>2012-01-03 21:50:01</wp:comment_date>
			<wp:comment_date_gmt>2012-01-04 05:50:01</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[I second this. It is boring to encounter so many videos instead of the expected written work (that's also  more engaging for the authors).
If software engeneering process is to become a science we need some written content that's easier to study, to assimilate, to criticize and to refer to.
Or is engeneering becoming a spoken knowledge ?]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>686</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1325656201.7829";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>781</wp:comment_id>
			<wp:comment_author><![CDATA[gvwilson]]></wp:comment_author>
			<wp:comment_author_email>gvwilson@third-bit.com</wp:comment_author_email>
			<wp:comment_author_url>http://third-bit.com/</wp:comment_author_url>
			<wp:comment_author_IP>173.33.251.2</wp:comment_author_IP>
			<wp:comment_date>2012-01-17 03:00:26</wp:comment_date>
			<wp:comment_date_gmt>2012-01-17 11:00:26</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[This is an early-stage presentation of ongoing work; I'm sure the paper you want will be forthcoming.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>760</wp:comment_parent>
			<wp:comment_user_id>2</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1326798026.3885";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:8:"gvwilson";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>692</wp:comment_id>
			<wp:comment_author><![CDATA[Kim Moir]]></wp:comment_author>
			<wp:comment_author_email>kim.moir@gmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>199.246.40.54</wp:comment_author_IP>
			<wp:comment_date>2011-12-14 11:11:13</wp:comment_date>
			<wp:comment_date_gmt>2011-12-14 19:11:13</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Thanks for sharing, very interesting presentation.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1323889873.9606";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>686</wp:comment_id>
			<wp:comment_author><![CDATA[Matt Doar]]></wp:comment_author>
			<wp:comment_author_email>mdoar@pobox.com</wp:comment_author_email>
			<wp:comment_author_url>http://www.pobox.com/~doar</wp:comment_author_url>
			<wp:comment_author_IP>69.28.149.29</wp:comment_author_IP>
			<wp:comment_date>2011-12-13 10:11:00</wp:comment_date>
			<wp:comment_date_gmt>2011-12-13 18:11:00</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Sounds interesting, but a set of slides would be faster to absorb. Searched and didn't find them though.

~Matt]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1323799860.7616";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
		<title>Factors that Affect Software Systems Development Project Outcomes</title>
		<link>http://www.neverworkintheory.org/?p=248</link>
		<pubDate>Thu, 22 Dec 2011 00:04:03 +0000</pubDate>
		<dc:creator>jorge</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=248</guid>
		<description></description>
		<content:encoded><![CDATA[<em>Laurie McLeod and <a href="http://www.aut.ac.nz/study-at-aut/study-areas/computing--mathematical-sciences/profiles/our-staff/professors/stephen-macdonell">Stephen G. MacDonell</a>. <strong>"<a href="http://dl.acm.org/citation.cfm?id=1978803">Factors that Affect Software Systems Development Project Outcomes: A Survey of Research.</a>"</strong> ACM Computing Surveys, 2011.</em>
<blockquote><em>Determining the factors that have an influence on software systems development and deployment project outcomes has been the focus of extensive and ongoing research for more than 30 years. We provide here a survey of the research literature that has adressed this topic in the period 1996-2006, with a particular focus on empirical analyses. On the basis of this survey we present a new classification framework that represents an abstracted and synthesized view of the types of factors that have been asserted as influencing project outcomes.</em></blockquote>
Reading this literature review was a strange experience. Despite its 56-page length, and the fact that it was published only a couple of months ago, it manages to miss most of the interesting research in software development of recent years. There seem to be two reasons for this. First, the paper focuses almost entirely on research coming from the Information Systems community, which for reasons I've never understood is fairly disconnected from the Software Engineering research community (such as the TSE and ESE journals and the ICSE and FSE conferences). Second, the paper only considers research published between 1996 and 2006. It took me a while to realize this, but most of the exciting developments in our field (such as the link between organizational and code structure, the exploitation of data mining techniques to predict defects, and the rich and detailed qualitative evaluations of Agile practices) have only flourished in the last five years or so, and therefore would be out of scope for this survey.

In any case, McLeod and MacDonell's survey provides a long list of factors that have been found to affect software projects, along with citations for each of them, and in that sense it is a useful gateway to research on these topics. Just be aware as you read it that, despite its recent publication date, it is fairly dated already.

PS: The paper is still only available behind a paywall, but it may eventually be posted in the <a href="http://www.aut.ac.nz/study-at-aut/study-areas/computing--mathematical-sciences/profiles/research/software-engineering-research-laboratory-serl/overview/process-modelling,-assessment-and-improvement">authors' lab site</a>.]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>248</wp:post_id>
		<wp:post_date>2011-12-21 16:04:03</wp:post_date>
		<wp:post_date_gmt>2011-12-22 00:04:03</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>factors-that-affect-software-systems-development-project-outcomes</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="literature-reviews"><![CDATA[Literature Reviews]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>805</wp:comment_id>
			<wp:comment_author><![CDATA[Jorge Aranda]]></wp:comment_author>
			<wp:comment_author_email>jorge@neverworkintheory.org</wp:comment_author_email>
			<wp:comment_author_url>http://www.neverworkintheory.org/</wp:comment_author_url>
			<wp:comment_author_IP>184.66.174.163</wp:comment_author_IP>
			<wp:comment_date>2012-02-10 12:57:10</wp:comment_date>
			<wp:comment_date_gmt>2012-02-10 20:57:10</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[<em>A response from one of the authors, Stephen MacDonell, who asked me to post it here. Thanks, Stephen! --Jorge</em>

Thanks Jorge for your comments on our ACM Computing Surveys paper.

You are correct that the initial literature searches were conducted more from an IS perspective than an SE one, primarily due to the disciplinary focus that we had when Laurie began the study i.e. on systems success/failure from an organisational perspective rather than software success/failure from a technical perspective.  We did attempt, however, to encompass at least some of the SE literature particularly in the secondary phases of the search e.g. following citations to SE work in the publications selected previously.

In regard to the 1996-2006 range for the survey and the disconnect with a 2011 paper, this is due to the lengthy review and production cycles for the journal.  In fact, we actually extended the survey after the first round of reviews in an effort to improve its currency; however, the fact remains that the survey represents a particular snapshot of research as published in the 11 years covered.  We are confident that it is still useful, however, as many of the factors are enduring, and apply today just as they did a decade or more ago.

A postprint version of the paper is indeed available, from: http://aut.researchgateway.ac.nz/handle/10292/2523

Finally, we are in agreement with the remarks above regarding the largely unhelpful divide between IS and SE and in fact we have written about this issue in some of our other papers.  The divide was probably more sensible in the 1980s and early 1990s, but since then, as software has become both more pervasive and more contextualised, maintaining such a split seems incongruous.  In that sense it is promising to see some journals broadening their coverage to address issues of interest to the whole software systems community.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:14:"1328907430.792";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:5:"jorge";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>718</wp:comment_id>
			<wp:comment_author><![CDATA[Lorin Hochstein]]></wp:comment_author>
			<wp:comment_author_email>lorin@isi.edu</wp:comment_author_email>
			<wp:comment_author_url>http://lorinhochstein.org</wp:comment_author_url>
			<wp:comment_author_IP>65.114.169.36</wp:comment_author_IP>
			<wp:comment_date>2011-12-22 08:10:47</wp:comment_date>
			<wp:comment_date_gmt>2011-12-22 16:10:47</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[The IS/SE divide is a strange one. I think CS as a whole looks down on IS, but methodologically they're much better than SE at proposing and evaluating empirical models. My impression is that it would be harder to get an empirical paper into MIS Quarterly paper than it would be to get one into TSE or ESE.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1324570247.2665";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>720</wp:comment_id>
			<wp:comment_author><![CDATA[Jorge Aranda]]></wp:comment_author>
			<wp:comment_author_email>jorge@neverworkintheory.org</wp:comment_author_email>
			<wp:comment_author_url>http://www.neverworkintheory.org/</wp:comment_author_url>
			<wp:comment_author_IP>24.68.85.70</wp:comment_author_IP>
			<wp:comment_date>2011-12-22 11:21:11</wp:comment_date>
			<wp:comment_date_gmt>2011-12-22 19:21:11</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[I agree, especially if the paper in question deals with organizational studies.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>718</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1324581671.5841";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:5:"jorge";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
		<title>The Effects of Stand-Up and Sit-Down Meeting Formats on Meeting Outcomes</title>
		<link>http://www.neverworkintheory.org/?p=254</link>
		<pubDate>Fri, 06 Jan 2012 06:07:43 +0000</pubDate>
		<dc:creator>jorge</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=254</guid>
		<description></description>
		<content:encoded><![CDATA[<em><a href="http://business.missouri.edu/1312/228.aspx">Allen C. Bluedorn</a>, <a href="http://business.missouri.edu/28/243.aspx">Daniel B. Turban</a>, and <a href="http://www.siue.edu/~marlove/">Mary Sue Love</a>. <strong>"<a href="http://psycnet.apa.org/?&amp;fa=main.doiLanding&amp;doi=10.1037/0021-9010.84.2.277">The Effects of Stand-Up and Sit-Down Meeting Formats on Meeting Outcomes</a>".</strong> Journal of Applied Psychology 84(2), 1999.</em>
<blockquote><em>The effects of meeting format (standing or sitting) on meeting length and the quality of group decision making were investigated by comparing meeting outcomes for 56 five-member groups that conducted meetings in a standing format with 55 five-member groups that conducted meetings in a seated format. Sit-down meetings were 34% longer than stand-up meetings, but they produced no better decisions than stand-up meetings. Significant differences were also obtained for satisfaction with the meeting and task information use during the meeting but not for synergy or commitment to the group's decision. The findings were generally congruent with meeting-management recommendations in the time-management literature, although the lack of a significant difference for decision quality was contrary to theoretical expectations. This contrary finding may have been due to differences between the temporal context in which this study was conducted and those in which other time constraint research has been conducted, thereby revealing a potentially important contingency—temporal context.</em></blockquote>
If there's one practice that caught on with every software team that calls itself Agile, it's got to be daily stand-up meetings. If you hold your meetings standing up, the argument goes, they will go briskly, which is great because nobody likes meetings that drag on and on, especially if you hold them daily. This paper provides valuable evidence with respect to the efficacy of stand-up meetings: they are significantly shorter than sit-down meetings, and the decisions taken in them are just as good. Their only downside in the experiment is that participants were less satisfied with the meeting than those in sit-down meetings.

These were all 5-person meetings lasting 10-20 minutes and concerning a well-defined problem. The authors warn: "...additional research is needed to determine whether the stand-up meeting can be used for longer meetings dealing with problems that vary in their structure."

(Thanks to Laurent Bossavit for pointing me to this paper. If you know of interesting papers that are relevant for software practitioners, even---or especially---if they're from other disciplines, please send them our way! Also, note that we try to post links to freely downloadable versions of the papers we discuss. Sometimes, as in this case, we found none---but e-mailing the authors and asking nicely usually gets you a copy.)]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>254</wp:post_id>
		<wp:post_date>2012-01-05 22:07:43</wp:post_date>
		<wp:post_date_gmt>2012-01-06 06:07:43</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>the-effects-of-stand-up-and-sit-down-meeting-formats-on-meeting-outcomes</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="controlled-experiments"><![CDATA[Controlled Experiments]]></category>
		<category domain="category" nicename="practices"><![CDATA[Practices]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Got Issues? Do New Features and Code Improvements Affect Defects?</title>
		<link>http://www.neverworkintheory.org/?p=262</link>
		<pubDate>Thu, 12 Jan 2012 19:01:53 +0000</pubDate>
		<dc:creator>jorge</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=262</guid>
		<description></description>
		<content:encoded><![CDATA[<em><a href="http://entrepreneurship.ucdavis.edu/person.php?people_id=92">Daryl Posnett</a>, <a href="http://softwareprocess.es/">Abram Hindle</a>, and <a href="http://www.cs.ucdavis.edu/~devanbu/">Prem Devanbu</a>. <strong>"<a href="http://softwareprocess.es/a/issues.pdf">Got Issues? Do New Features and Code Improvements Affect Defects?</a>"</strong> WCRE 2011.</em>
<blockquote><em>There is a perception that when new features are added to a system that those added and modified parts of the source-code are more fault prone. Many have argued that new code and new features are defect prone due to immaturity, lack of testing, as well unstable requirements. Unfortunately most previous work does not investigate the link between a concrete requirement or new feature and the defects it causes, in particular the feature, the changed code and the subsequent defects are rarely investigated. In this paper we investigate the relationship between improvements, new features and defects recorded within an issue tracker. A manual case study is performed to validate the accuracy of these issue types. We combine defect issues and new feature issues with the code from version-control systems that introduces these features; we then explore the relationship of new features with the fault-proneness of their implementations. We describe properties and produce models of the relationship between new features and fault proneness, based on the analysis of issue trackers and version-control systems. We find, surprisingly, that neither improvements nor new features have any significant effect on later defect counts, when controlling for size and total number of changes.</em></blockquote>
<em></em>One piece of common wisdom in the software industry is that new code tends to be buggier than old code, because it is immature and more poorly tested. But in this short paper, Posnett, Hindle, and Devanbu present an interesting twist on this. In the open source projects they studied, they found that although code changes in general are associated with future defect fixing activity, as we might expect, those changes that correspond to new feature development and to code improvements are <strong>not</strong>. That's interesting and counter-intuitive---one would expect new feature code commits to be among the buggiest. The authors offer a possible explanation: well-established open source projects tend to be quite conservative, and new feature code is heavily scrutinized, so that most defects are found and sorted out before the code is integrated. Which means that projects that are not so careful might experience much more new feature pain.

&nbsp;]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>262</wp:post_id>
		<wp:post_date>2012-01-12 11:01:53</wp:post_date>
		<wp:post_date_gmt>2012-01-12 19:01:53</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>got-issues-do-new-features-and-code-improvements-affect-defects</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="mining"><![CDATA[Mining]]></category>
		<category domain="category" nicename="open-source"><![CDATA[Open Source]]></category>
		<category domain="category" nicename="qualitative-studies"><![CDATA[Qualitative Studies]]></category>
		<category domain="category" nicename="quality"><![CDATA[Quality]]></category>
		<category domain="category" nicename="quantitative-studies"><![CDATA[Quantitative Studies]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>A Survey of the Practice of Computational Science</title>
		<link>http://www.neverworkintheory.org/?p=267</link>
		<pubDate>Tue, 17 Jan 2012 21:28:33 +0000</pubDate>
		<dc:creator>gvwilson</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=267</guid>
		<description></description>
		<content:encoded><![CDATA[A survey of the practice of computational science. In <cite>International Conference for High Performance Computing, Networking, Storage and Analysis</cite>, pages 19:1–19:12, 2011. (<a href="http://dx.doi.org/10.1145/2063348.2063374">doi:10.1145/2063348.2063374</a>)
<blockquote><em>Computing plays an indispensable role in scientific research. Presently, researchers in science have different problems, needs, and beliefs about computation than professional programmers. In order to accelerate the progress of science, computer scientists must understand these problems, needs, and beliefs. To this end, this paper presents a survey of scientists from diverse disciplines, practicing computational science at a doctoral-granting university with very high research activity. The survey covers many things, among them, prevalent programming practices within this scientific community, the importance of computational power in different fields, use of tools to enhance performance and software productivity, computational resources leveraged, and prevalence of parallel computation. The results reveal several patterns that suggest interesting avenues to bridge the gap between scientific researchers and programming tools developers.</em></blockquote>
Several studies of scientific programmers and scientific programming have come out in the past few years [<a href="#1">1</a>]. This in-depth analysis, which is based on semi-structured interviews with 114 researchers in science and engineering at Princeton University, is probably the most insightful to date. It explores the languages and tools researchers use, their debugging techniques, the environments they use, their performance tuning strategies, their use of parallelism [<a href="#2">2</a>], and many other aspects of their work. While some of its conclusions are unsurprising (e.g., the fact that scientists don't test their programs rigorously), others highlight fruitful directions for future research—most particularly, the need to integrate performance analysis and tuning tools into everyday programming. More studies like this in other areas would be very welcome.
<p id="1">[1] Disclosure: one of us (GW) co-authored<a href="http://dl.acm.org/citation.cfm?id=1556928"> one of these studies</a>, a web-based survey of over 1900 scientists conducted in 2008-09.</p>
<p id="2">[2] Not surprisingly, job-level parallelism (i.e., running a sequential program many times with slightly different parameters) is by far the most common.</p>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>267</wp:post_id>
		<wp:post_date>2012-01-17 13:28:33</wp:post_date>
		<wp:post_date_gmt>2012-01-17 21:28:33</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>a-survey-of-the-practice-of-computational-science</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="practices"><![CDATA[Practices]]></category>
		<category domain="category" nicename="qualitative-studies"><![CDATA[Qualitative Studies]]></category>
		<category domain="category" nicename="quantitative-studies"><![CDATA[Quantitative Studies]]></category>
		<category domain="category" nicename="scientific-computing"><![CDATA[Scientific Computing]]></category>
		<category domain="category" nicename="survey"><![CDATA[Survey]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Realizing quality improvement through test driven development</title>
		<link>http://www.neverworkintheory.org/?p=271</link>
		<pubDate>Thu, 26 Jan 2012 00:01:29 +0000</pubDate>
		<dc:creator>jorge</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=271</guid>
		<description></description>
		<content:encoded><![CDATA[<em><a href="http://research.microsoft.com/en-us/people/nachin/">Nachiappan Nagappan</a>, <a href="http://www.maximilien.com/homepage/welcome.html">E. Michael Maximilien</a>, Thirumalesh Bhat, and <a href="http://collaboration.csc.ncsu.edu/laurie/">Laurie Williams</a>. <strong>"<a href="http://research.microsoft.com/en-us/groups/ese/nagappan_tdd.pdf">Realizing quality improvement through test driven development: results and experiences of four industrial teams</a>"</strong>. ESE 2008.</em>
<blockquote><em>Test-driven development (TDD) is a software development practice that has been used sporadically for decades. With this practice, a software engineer cycles minute-by-minute between writing failing unit tests and writing implementation code to pass those tests. Test- driven development has recently re-emerged as a critical enabling practice of agile software development methodologies. However, little empirical evidence supports or refutes the utility of this practice in an industrial context. Case studies were conducted with three development teams at Microsoft and one at IBM that have adopted TDD. The results of the case studies indicate that the pre-release defect density of the four products decreased between 40% and 90% relative to similar projects that did not use the TDD practice. Subjectively, the teams experienced a 15–35% increase in initial development time after adopting TDD.</em></blockquote>
In the test-driven development (TDD) chapter of <a href="http://shop.oreilly.com/product/9780596808303.do"><em>Making Software</em></a>, Turhan &amp; Co. reported that the evidence for it is mixed: there is moderate support for the claim that it improves quality, and it is not quite clear if this entails a productivity cost. To come up with this conclusion, the authors went through all the papers they could find on the topic---some of them reporting experiments with students, some with practitioners, and with highly varying quality.

In my opinion, one of the stronger papers in their sample was this one, by Nagappan &amp; Co. It reports on four teams, one at IBM and three at Microsoft, and it contrasts TDD vs. comparable non-TDD teams post-hoc (so the study did not bias data collection). As the abstract points out, there were far fewer defects in all four products, though managers at all teams reported an increase in development time.

The conservatism in the <em>Making Software</em> chapter is warranted: there is still conflicting empirical evidence with TDD, as with most other practices in software development. But studies like Nagappan &amp; Co.'s show that TDD is likely to be beneficial. Just note that (at least in the Microsoft teams they studied) "there was no enforcement and monitoring of the TDD practice; and decisions to use TDD were made as a group." In other words, developers applied TDD because they wanted to, not because of a decree from their manager. Whether it would've been as effective otherwise is an open question.

&nbsp;]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>271</wp:post_id>
		<wp:post_date>2012-01-25 16:01:29</wp:post_date>
		<wp:post_date_gmt>2012-01-26 00:01:29</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>realizing-quality-improvement-through-test-driven-development</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="case-studies"><![CDATA[Case Studies]]></category>
		<category domain="category" nicename="testing"><![CDATA[Testing]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>791</wp:comment_id>
			<wp:comment_author><![CDATA[Jorge Aranda]]></wp:comment_author>
			<wp:comment_author_email>jorge@neverworkintheory.org</wp:comment_author_email>
			<wp:comment_author_url>http://www.neverworkintheory.org/</wp:comment_author_url>
			<wp:comment_author_IP>142.104.165.150</wp:comment_author_IP>
			<wp:comment_date>2012-01-26 10:39:33</wp:comment_date>
			<wp:comment_date_gmt>2012-01-26 18:39:33</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[That would be interesting to know indeed. It's the question of whether TDD might help because it necessarily has a high coverage (if done right), in which case any technique that leads to high coverage is comparable, or because writing tests first forces one to understand the intent of the feature better, in which case TDD is fairly unique.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>790</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1327603173.8196";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:5:"jorge";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>790</wp:comment_id>
			<wp:comment_author><![CDATA[Mille]]></wp:comment_author>
			<wp:comment_author_email>millebesso@gmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>217.198.150.197</wp:comment_author_IP>
			<wp:comment_date>2012-01-25 23:23:14</wp:comment_date>
			<wp:comment_date_gmt>2012-01-26 07:23:14</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Very interesting. This is a constantly ongoing discussion in my team at the moment. Most developers agree that tests in general is a good thing but that it comes at a cost but what that cost is is difficult to quantify. Our focus has mostly been on test coverage where we have a rough figure for what we want to achieve. It would be interesting to know how it affects the result in this study if the tests are written in advance or added when the functionality is implemented.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1327562594.2888";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>803</wp:comment_id>
			<wp:comment_author><![CDATA[Jeremy Noring]]></wp:comment_author>
			<wp:comment_author_email>kidjan@gmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>97.125.46.201</wp:comment_author_IP>
			<wp:comment_date>2012-02-08 11:23:34</wp:comment_date>
			<wp:comment_date_gmt>2012-02-08 19:23:34</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[I've looked through this paper before.  It's generally good, but there were several things that stuck out as being questionable in my mind.

In particular, the authors assert that "the complexity of the TDD and non-TDD projects are comparable" because "these systems were compared within the same organization (with the same higher-level manager and sub-culture)."  This seems questionable.  It's also clear--from total lines of code and team size comparison--that it is unlikely these are "comparable projects."  They also don't list the experience breakdown of team members for the comparable projects.

Second, they include figures on "increase in time taken to code the feature due to TDD," and use "management estimates" as a source of data.  Given what we know about estimating things, is this really a valid method? 

Lastly, how do they conclude that TDD was solely responsible for the improvement?  Did the teams have other differences, such as doing code reviews?  Were programmers working together, or were they geographically dispersed?  How did management affect the various projects?  What other factors could have influenced their results?  They allude to some of this obliquely in their "threats" section.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1328729014.8501";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
		<title>Teachers Matter - Do Programmers?</title>
		<link>http://www.neverworkintheory.org/?p=277</link>
		<pubDate>Thu, 16 Feb 2012 15:12:33 +0000</pubDate>
		<dc:creator>gvwilson</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=277</guid>
		<description></description>
		<content:encoded><![CDATA[Raj Chetty and John Friedman (Harvard), and Jonah Rockoff (Columbia) recently published a study showing <a href="http://www.youtube.com/watch?v=vh22HBZMHvM">how much long-term impact teachers have on students</a>. To make a long story short, the answer is "a lot", and that impact persists long after the child leaves the classroom. As far as I know, no-one has ever done something similar for programmers, i.e., looked at the long-term impact a particular software developer has on a project (for either good or ill). I think the hardest part would be developing a measure of one person's impact on software; like all metrics, what you'd get out could all too easily be determined primarily by what assumptions you baked in.

But this example raises a broader question that we'd like to throw out to the whole community. What studies have you seen in other areas that you'd like to see replicated in software development? For example, Evan Robinson's classic article "<a href="http://www.igda.org/why-crunch-modes-doesnt-work-six-lessons">Why Crunch Mode Doesn't Work</a>" does a great job of summarizing research on the effects of sleep deprivation on productivity. None of those studies specifically looked at programmers; I suspect that one that did would be read and cited a lot. What other analyses would <em>you</em> like empirical software engineering researchers to transfer to our domain?]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>277</wp:post_id>
		<wp:post_date>2012-02-16 07:12:33</wp:post_date>
		<wp:post_date_gmt>2012-02-16 15:12:33</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>teachers-matter-do-programmers</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="general"><![CDATA[General]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Looking at the same thing in pair programming tasks</title>
		<link>http://www.neverworkintheory.org/?p=281</link>
		<pubDate>Thu, 23 Feb 2012 19:01:41 +0000</pubDate>
		<dc:creator>jorge</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=281</guid>
		<description></description>
		<content:encoded><![CDATA[<em><a href="http://people.epfl.ch/patrick.jermann">Patrick Jermann</a> and <a href="http://people.epfl.ch/137541">Marc-Antoine Nüssli</a>. <a href="http://dl.acm.org/citation.cfm?id=2145371"><strong>"Effects of Sharing Text Selections on Gaze Cross-recurrence and Interaction Quality in a Pair Programming Task"</strong></a> CSCW 2012.</em>
<blockquote><em>We present a dual eye-tracking study that demonstrates the effect of sharing selection among collaborators in a remote pair-programming scenario. Forty pairs of engineering students completed several program understanding tasks while their gaze was synchronously recorded. The coupling of the programmers’ focus of attention was measured by a cross- recurrence analysis of gaze that captures how much programmers look at the same sequence of spots within a short time span. A high level of gaze cross-recurrence is typical for pairs who actively engage in grounding efforts to build and maintain shared understanding. As part of their grounding efforts, programmers may use text selection to perform collaborative references. Broadcast selections serve as indexing sites for the selector as they attract non-selector’s gaze shortly after they become visible. Gaze cross-recurrence is highest when selectors accompany their selections with speech to produce a multimodal reference.</em></blockquote>
The fact that pair programming can work pretty well doesn't mean that it "just works." Instead, it requires its own set of skills and considerations, and perhaps some people are better suited for it than others. In a controlled experiment using an eye tracker, Jermann and Nüssli show the effect of some of the very low-level actions that people in pairs may take to improve their performance. Specifically, two seemingly simple kinds of actions (talking aloud and selecting the block of text that you're talking about) bring your partner's attention to the same screen area. When pairs do this, their level of code comprehension increases.

Jermann and Nüssli's study had engineers sitting separately, in front of different but shared screens. My guess is that if you and your pair are sitting side by side, other actions with the same purpose (such as pointing with your finger, or with your mouse) should have similar effects.

---

(As usual, we post links to the actual papers when we find them. I couldn't in this case, but remember that researchers are usually happy to share their work over email if you ask nicely...)

&nbsp;]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>281</wp:post_id>
		<wp:post_date>2012-02-23 11:01:41</wp:post_date>
		<wp:post_date_gmt>2012-02-23 19:01:41</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>looking-at-the-same-thing-in-pair-programming-tasks</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="controlled-experiments"><![CDATA[Controlled Experiments]]></category>
		<category domain="category" nicename="pair-programming"><![CDATA[Pair Programming]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Social coding in GitHub</title>
		<link>http://www.neverworkintheory.org/?p=286</link>
		<pubDate>Thu, 01 Mar 2012 16:00:18 +0000</pubDate>
		<dc:creator>jorge</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=286</guid>
		<description></description>
		<content:encoded><![CDATA[<em><a href="http://lauradabbish.com/">Laura Dabbish</a>, <a href="http://www.colleenstuart.com/">Colleen Stuart</a>, Jason Tsay, and <a href="http://herbsleb.org/">Jim Herbsleb</a>. <a href="http://www.cs.cmu.edu/~xia/resources/Documents/cscw2012_Github-paper-FinalVersion-1.pdf"><strong>"Social Coding in GitHub: Transparency and Collaboration in an Open Software Repository"</strong></a> CSCW 2012.</em>
<blockquote><em>Social applications on the web let users track and follow the activities of a large number of others regardless of location or affiliation. There is a potential for this transparency to radically improve collaboration and learning in complex knowledge-based activities. Based on a series of in-depth interviews with central and peripheral GitHub users, we examined the value of transparency for large-scale distributed collaborations and communities of practice. We find that people make a surprisingly rich set of social inferences from the networked activity information in GitHub, such as inferring someone else’s technical goals and vision when they edit code, or guessing which of several similar projects has the best chance of thriving in the long term. Users combine these inferences into effective strategies for coordinating work, advancing technical skills and managing their reputation.</em></blockquote>
Platforms like GitHub provide an interesting twist to social dynamics in open source: they make it easy for everyone to keep track of, interact, collaborate, and be aware of the work of other developers, including some of the best in the world, all in one place. This paper by Dabbish &amp; Co reports on work habits and perceptions of "central and peripheral" GitHub users. If you're new to GitHub, this paper is a good take on its social aspect, but if you're already used to working in GitHub, there will be little that will surprise you here. Still, I found some cool nuggets that might interest you. For instance, that once people amass an audience looking at their code production, they become more careful about what they make available publicly. Also, that some people get followers not because of programming ability or personal connections, but because they have "good taste" in the projects they themselves follow.]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>286</wp:post_id>
		<wp:post_date>2012-03-01 08:00:18</wp:post_date>
		<wp:post_date_gmt>2012-03-01 16:00:18</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>social-coding-in-github</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="collaboration"><![CDATA[Collaboration]]></category>
		<category domain="category" nicename="open-source"><![CDATA[Open Source]]></category>
		<category domain="category" nicename="qualitative-studies"><![CDATA[Qualitative Studies]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Component reuse vs. snippet remixing</title>
		<link>http://www.neverworkintheory.org/?p=294</link>
		<pubDate>Tue, 10 Apr 2012 15:00:47 +0000</pubDate>
		<dc:creator>jorge</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=294</guid>
		<description></description>
		<content:encoded><![CDATA[<em><a href="http://www.ics.uci.edu/~ses/">Susan Elliott Sim</a>, <a href="http://www.ics.uci.edu/~rgallard/">Rosalva Gallardo-Valencia</a>, <a href="http://www.humanities.uci.edu/critical/kp/index.html">Kavita Philip</a>, <a href="http://userpages.umbc.edu/~medha1/">Medha Umarji</a>, <a href="http://edlab.tc.columbia.edu/index.php?q=user/2295">Megha Agarwala</a>, <a href="http://www.ics.uci.edu/~lopes/">Cristina V. Lopes</a>, and <a href="http://www.isr.uci.edu/~sratanot/">Sukanya Ratanotayanon</a>. <strong>"<a href="http://dl.acm.org/citation.cfm?id=2145407">Software Reuse through Methodical Component Reuse and Amethodical Snippet Remixing</a>",</strong> CSCW 2012.</em>
<blockquote><em>Every method for developing software is a prescriptive model. Applying a deconstructionist analysis to methods reveals that there are two texts, or sets of assumptions and ideals: a set that is privileged by the method and a second set that is left out, or marginalized by the method. We apply this analytical lens to software reuse, a technique in software development that seeks to expedite one’s own project by using programming artifacts created by others. By analyzing the methods prescribed by Component-Based Software Engineering (CBSE), we arrive at two texts: Methodical CBSE and Amethodical Remixing. Empirical data from four studies on code search on the web draws attention to four key points of tension: status of component boundaries; provenance of source code; planning and process; and evaluation criteria for candidate code. We conclude the paper with a discussion of the implications of this work for the limits of methods, structure of organizations that reuse software, and the design of search engines for source code.</em></blockquote>
One of the ways in which the Internet transformed software development is the prevalence of the "programming by Google" practice: searching online for a function or snippet that does what you want, and copy-and-pasting it into one's own code, stitching it as needed to make it work. This practice is great in some ways (it speeds up development, it helps cross-pollinate ideas and techniques), but it also has its problems (maintaining code provenance, intellectual property, and diverging from policy, for example).

In this paper, Sim &amp; Co provide a very good exploration of the distinction between the safer, more planned, and stuffier "component reuse" approach and the ad-hoc, versatile, under-the-table "snippet remixing" approach to code reuse. They have some interesting statistics on the use of both approaches (for instance: 92% of surveyed developers admit to remixing snippets of code), and they identify points of tension between them. Their paper should be a wake-up call for Software Engineering professors to stop acting as if component-based reuse was all there is to code reuse, and an invitation to practitioners to consider the strengths and weaknesses of both approaches and to define the right balance between them in their own contexts.

<em>(Disclosure: Susan Sim is my academic sister---we had the same graduate advisor, though we did not overlap. Also, here is one more reminder that we link to PDFs of the papers we discuss when we find them. In cases we do not, asking the authors nicely for a copy usually works.)</em>

---

<strong>Update, April 30:</strong> There is now a freely available electronic copy <a href="http://www.drsusansim.org/publications.html#cscw2012">here</a>.]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>294</wp:post_id>
		<wp:post_date>2012-04-10 08:00:47</wp:post_date>
		<wp:post_date_gmt>2012-04-10 15:00:47</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>component-reuse-vs-snippet-remixing</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="uncategorized"><![CDATA[Uncategorized]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>904</wp:comment_id>
			<wp:comment_author><![CDATA[Glyph]]></wp:comment_author>
			<wp:comment_author_email>glyph@twistedmatrix.com</wp:comment_author_email>
			<wp:comment_author_url>http://glyph.twistedmatrix.com</wp:comment_author_url>
			<wp:comment_author_IP>173.13.137.18</wp:comment_author_IP>
			<wp:comment_date>2012-04-11 01:15:32</wp:comment_date>
			<wp:comment_date_gmt>2012-04-11 08:15:32</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[First, thanks for the delicious irony of a paper about copying and pasting snippets off the internet, which is apparently not, itself, freely available on the internet.  (Lawrence Lessig has a great talk about the corrupting influence of money on institutions, and one of the examples is the now largely redundant industry of journal editing.)

Second, it is slightly troubling to me that the problems cited in the blog post here.  All of these issues - code provenance, intellectual property, and policy compliance - are the job of accountants and lawyers.  Why are these the first that occur to you?  The real problem with "snippet remixing", the problem that a software developer ought to be concerned with first and foremost, is the additional maintenance overhead of the copy-pasted code.  If you duplicate code, you duplicate defects, doubling the amount of work that will be required to correct them, or to adjust the behavior of a system.  New defects appear as one instance of the copy-paste mutation is adjusted, but others aren't.

Finally, "snippet remixing" isn't the best label for this practice.  I'd suggest something like "turd shuffling" but I suspect that the ACM wouldn't publish that.  When a musician creates a remix, the original master tracks are left unmodified; in other words, in the actual field of music, "remixing" is actually a lot more like invoking subroutines than glomming together random garbage you found on w3schools.com.

(It's worth noting that "remix" used to mean something fairly specific: when a modern musical recording artist creates a song, they record several tracks separately, and then the audio engineer takes those master tracks and "mixes" them, blending them together at specific volumes, sometimes with tempo corrections, edits, etc.  A "re-mix" is a version of the song that takes the original tracks and puts them together in a different combination; the whole concept of remixing is dependent upon a sort of maintainable musical source code to which both the original mix and the re-mix refer.  Recently the term has come to mean any new version of a song, including an arrangement, a sampling, a cover, a re-recording, etc, so in this looser sense it might be accurate.)]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1334132132.3999";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>958</wp:comment_id>
			<wp:comment_author><![CDATA[Susan Sim]]></wp:comment_author>
			<wp:comment_author_email>ses@drsusansim.org</wp:comment_author_email>
			<wp:comment_author_url>http://www.drsusansim.org</wp:comment_author_url>
			<wp:comment_author_IP>69.165.246.84</wp:comment_author_IP>
			<wp:comment_date>2012-04-30 15:28:24</wp:comment_date>
			<wp:comment_date_gmt>2012-04-30 22:28:24</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Here is a link to a free version of the paper. http://www.drsusansim.org/publications.html#cscw2012

I have truly enjoyed reading the comments. As an academic, we so rarely hear feedback on our work outside of nasty reviewer comments and inbred conferences.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1335824904.5949";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>965</wp:comment_id>
			<wp:comment_author><![CDATA[Example Embedding - It will never work in theory]]></wp:comment_author>
			<wp:comment_author_email></wp:comment_author_email>
			<wp:comment_author_url>http://www.neverworkintheory.org/?p=315</wp:comment_author_url>
			<wp:comment_author_IP>64.90.54.151</wp:comment_author_IP>
			<wp:comment_date>2012-05-02 20:00:41</wp:comment_date>
			<wp:comment_date_gmt>2012-05-03 03:00:41</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[[...]   Recent commentsJorge Aranda on Component reuse vs. snippet remixingSusan Sim on Component reuse vs. snippet remixingGlyph on Component reuse vs. snippet remixingJorge [...]]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type>pingback</wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1336014041.7954";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>960</wp:comment_id>
			<wp:comment_author><![CDATA[Jorge Aranda]]></wp:comment_author>
			<wp:comment_author_email>jorge@neverworkintheory.org</wp:comment_author_email>
			<wp:comment_author_url>http://www.neverworkintheory.org/</wp:comment_author_url>
			<wp:comment_author_IP>24.68.85.70</wp:comment_author_IP>
			<wp:comment_date>2012-04-30 19:34:30</wp:comment_date>
			<wp:comment_date_gmt>2012-05-01 02:34:30</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Many thanks, Susan!]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>958</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1335839670.8353";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:5:"jorge";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>901</wp:comment_id>
			<wp:comment_author><![CDATA[Leif Singer]]></wp:comment_author>
			<wp:comment_author_email>leif.singer@inf.uni-hannover.de</wp:comment_author_email>
			<wp:comment_author_url>http://leif.me</wp:comment_author_url>
			<wp:comment_author_IP>79.194.216.133</wp:comment_author_IP>
			<wp:comment_date>2012-04-10 12:10:11</wp:comment_date>
			<wp:comment_date_gmt>2012-04-10 19:10:11</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Dear Hendrik,

it seems you read a lot of (positive) judgment into the paper and the blog post. It's not dangerous to create a label -- labels help communicate about things that exist in the real world. And, as you probably know, this phenomenon definitely does exist. 

Yes -- much of the copy-paste-coding might be done by programmers that are not in the top 1%. Yet, we shouldn't let our gut instincts cloud our judgments here -- I'm sure many great developers will need to google an API call they don't know by heart from time to time and then reuse a small portion of the examples they find. But I have no data on that, and as far as I know, the paper doesn't claim to have statistics on the diffusion of this method, either. 

But, to go with your apparent gripe, do you claim that only highly skilled people should program? Where do you draw the line? Will we need a driver's license for developers? I believe that's not how business works, anyway -- companies buy the time of developers that can get the job done for the least amount of money. If part of the job is writing testable, maintainable code, that will be reflected in the price. But -- and that is a startling realization every software engineering researcher will make at some point -- companies don't necessarily want quality code. They want to solve business problems. If that can be done cheaper by stitching together PHP snippets found on the internet, they will choose this way. 

Finally, it *is* an established method -- a way of doing things that is happening in the real world. That doesn't mean it's endorsed by anyone or that everyone should do it. For all that I can see, the paper merely acknowledges that the method is indeed in use (established) and discusses the pros and cons. 

Surely I can see your pain. But I think you're reading too much into the paper / abstract -- it describes, not prescribes, the real world.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1334085011.6897";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>898</wp:comment_id>
			<wp:comment_author><![CDATA[Ben Damm]]></wp:comment_author>
			<wp:comment_author_email>bdamm-neverworkintheory@dammfine.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>74.121.22.10</wp:comment_author_IP>
			<wp:comment_date>2012-04-10 08:56:33</wp:comment_date>
			<wp:comment_date_gmt>2012-04-10 15:56:33</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Bingo... now hopefully the practice moves towards code creation patterns that are remix-friendly, as a design goal.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1334073394.2797";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>899</wp:comment_id>
			<wp:comment_author><![CDATA[Hendrik]]></wp:comment_author>
			<wp:comment_author_email>hendrik.schnepel@gmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>82.113.121.99</wp:comment_author_IP>
			<wp:comment_date>2012-04-10 10:27:58</wp:comment_date>
			<wp:comment_date_gmt>2012-04-10 17:27:58</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Hey there,

to me this abstract is not only interesting by itself, but also very surprising as it deviates very much from my expectations/prejudices towards academics.

On one hand I am amazed that phrases like "amethodical snippet remixing" even exist (in a positive way, really), on the other hand I feel that it's a dangerous idea to create such a label and thus some kind of academic approval.

From what I've seen, the very special art of voo-doo copy-pasting is almost always done by programmers who couldn't come up with the solution on their own. And I do mean for intellectual reasons, not due to time constraints.

It follows that these people can not reason about "their" implementation and their stitching can't possibly contribute to a quality codebase. (On the contrary). Yes, I do see "snippet remixing" in practice, and it leads more to WTF moments than e.g. cross-pollination of ideas. (Of course, because people don't care as much about the idea as about getting their task done.) In the long term this leads to high maintenance costs and less fun for everyone.

In the rare case that someone really copies code to learn about the idea, that's great - but it will certainly take some time to understand that code and cleanly(!) integrate it into the codebase. So there goes the efficiency.

All in all I think it's a good idea to acknowledge that there are different methods of "reuse" and it will certainly help when professors prepare students better for that reality. What makes me a bit nervous are the positive connotations I read here, like speed up (only short-term), cross-pollination (does not really happen) or "snippet remixing" (there is nothing artistic or even creative about this).

Please, make novices stay away from copy-pasting. It's okay for learning and trying out things, but don't describe it as an established method.

-- Hendrik

(No, I did not read the non-free paper, sorry. May be I should (somehow?), to understand the reasoning a little better?)]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1334078879.0452";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>915</wp:comment_id>
			<wp:comment_author><![CDATA[Glyph]]></wp:comment_author>
			<wp:comment_author_email>glyph@twistedmatrix.com</wp:comment_author_email>
			<wp:comment_author_url>http://glyph.twistedmatrix.com</wp:comment_author_url>
			<wp:comment_author_IP>173.13.137.18</wp:comment_author_IP>
			<wp:comment_date>2012-04-12 22:02:45</wp:comment_date>
			<wp:comment_date_gmt>2012-04-13 05:02:45</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[I did not mean to say that developers should not be concerned at all about these problems.  I take IP and compliance issues very seriously, as do all the other developers I know.  What I meant was that while developers should of course be concerned with policy compliance and IP provenance, those are secondary responsibilities to actually getting the code to work well.  The whole point of having IP lawyers and accountants and managers in the software business is that someone else, not your developers, should be responsible for those other issues, so developers can do development.

Also, I was just surprised to note that those were the first concerns you thought to raise - of course I know you believe maintainability is important too.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>907</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1334293365.9724";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>910</wp:comment_id>
			<wp:comment_author><![CDATA[Leif Singer]]></wp:comment_author>
			<wp:comment_author_email>leif.singer@inf.uni-hannover.de</wp:comment_author_email>
			<wp:comment_author_url>http://leif.me</wp:comment_author_url>
			<wp:comment_author_IP>79.194.216.74</wp:comment_author_IP>
			<wp:comment_date>2012-04-11 12:23:40</wp:comment_date>
			<wp:comment_date_gmt>2012-04-11 19:23:40</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[I'd really love NWIT to add another guideline to its existing ones: only open access papers OR papers with publicly available pre-prints. Paywalls for (often publicly funded) research hamper the dissemination of results.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>904</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1334172221.5604";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>911</wp:comment_id>
			<wp:comment_author><![CDATA[Leif Singer]]></wp:comment_author>
			<wp:comment_author_email>leif.singer@inf.uni-hannover.de</wp:comment_author_email>
			<wp:comment_author_url>http://leif.me</wp:comment_author_url>
			<wp:comment_author_IP>79.194.216.74</wp:comment_author_IP>
			<wp:comment_date>2012-04-11 12:33:07</wp:comment_date>
			<wp:comment_date_gmt>2012-04-11 19:33:07</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[I surely agree that stitching code together shouldn't be embraced indiscriminately. But it's not going away, either. So I think the best strategy would be if educators, researchers, and industry would start to openly acknowledge the practice. That way, we would be able to make a conscious effort at improving the situtation -- for example, as the paper points out, by working on code search engines. Another idea could be making IDEs aware of the source of pasted code, which might have applications regarding licensing, compliance, and developer support. 

And I think this conscious acknowledgment is what Jorge hinted at (correct me if I'm wrong) when he was mentioning educators -- they need to become aware of the phenomenon, openly acknowledge it, and do their best to educate their students about its short- and long-term implications.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>903</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1334172789.2031";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>912</wp:comment_id>
			<wp:comment_author><![CDATA[Jorge Aranda]]></wp:comment_author>
			<wp:comment_author_email>jorge@neverworkintheory.org</wp:comment_author_email>
			<wp:comment_author_url>http://www.neverworkintheory.org/</wp:comment_author_url>
			<wp:comment_author_IP>24.68.85.70</wp:comment_author_IP>
			<wp:comment_date>2012-04-11 15:45:17</wp:comment_date>
			<wp:comment_date_gmt>2012-04-11 22:45:17</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[It's worth considering.

Note that we get much better luck with older papers---researchers usually put up their work on their websites, but they don't do it immediately after every new publication. When we post stuff that has only been around for a couple of months, like this paper, chances are it hasn't made it to the web yet (or rather, only behind a paywall).]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>910</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1334184318.2563";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:5:"jorge";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>907</wp:comment_id>
			<wp:comment_author><![CDATA[Jorge Aranda]]></wp:comment_author>
			<wp:comment_author_email>jorge@neverworkintheory.org</wp:comment_author_email>
			<wp:comment_author_url>http://www.neverworkintheory.org/</wp:comment_author_url>
			<wp:comment_author_IP>24.68.85.70</wp:comment_author_IP>
			<wp:comment_date>2012-04-11 08:30:30</wp:comment_date>
			<wp:comment_date_gmt>2012-04-11 15:30:30</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Thanks, Glyph. Additional maintenance overhead is an issue with any kind of code reuse, of course. But it is not true that developers should not be concerned with provenance, IP, and policy compliance---like quality, they are everybody's concerns.

By the way, I meant policy compliance as in <emph>company</emph> policy compliance. There's also compliance with government policies, and they are also relevant, though perhaps less of a concern for developers.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>904</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1334158232.0671";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:5:"jorge";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>903</wp:comment_id>
			<wp:comment_author><![CDATA[Hendrik]]></wp:comment_author>
			<wp:comment_author_email>hendrik.schnepel@gmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>217.91.144.108</wp:comment_author_IP>
			<wp:comment_date>2012-04-11 00:46:47</wp:comment_date>
			<wp:comment_date_gmt>2012-04-11 07:46:47</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Leif,

I wouldn't have expected an answer any less wise from you.

Also, thanks for bringing up the elitist argument! ;) Although it's definitely possible to argue (and I really love to) that in professional programming/software *engineering* a license should be required just as in some other professions, that's not how reality works.

Actually I'm really happy with everyone and their mom programming on whatever level they can deliver. Really, that's cool - well, at least as long as no lifes depend on that software. In the end it's just money being burned, so what. For me personally though, this is more than just a job and I'm not willing to give up fun for fixing stitches. And of course I'm not talking about looking up an API. This is about taking complete implementations of more or less fitting use cases, e.g. "Hm, feels like I need a schema-free database. Hey, these PHP snippets look like they do something like that within MySQL. I'll roll with that. Why is there a dependency to jQuery? Well, whatever."

Yes, companies will most often go for the lowest price. They ask for results and usually don't really care how these are achieved. Heck, they aren't even qualified in the first place to judge the quality of the engineering work. And they shouldn't have to be!

The problem is of course that they fool themselves. Nobody can specify completely all requirements up front, so every project will start with an approach less complex (and less expensive) than what the product will eventually become. (Don't forget how once the project has begun the company is more or less stuck with the vendor.) Now as soon as the requirements change or grow, the company will of course pay for maintenance and refactoring costs, and these will very much depend on the quality and effort (and maybe the price) put into the initial work.

In my opinion, the price for growing and extending software should scale logarithmically and I'm very sure that this is possible with a quality codebase. As a customer, I think I even could live with a linear scale, it will probably still feel like a fair or at least predictable price. However, with a highly "remixed" codebase your cost will "scale" exponentially and that's just insane.

Anyway, that's not even my point. I didn't mean to say that the abstract was bad or biased in any way! It's just me being horrified by the relevancy that "Programming by Google" seems to have reached and that the abstract uses such positive connotations (which I listed) for something very bad. Actually I would hope for more bias! :) I know, that's probably not the job of a scientific paper, yet the abstract includes a recommendation to teachers and that's where you need to be careful. Ok, maybe the paper does make an objective enough comparison.

Also, I'm not sure about the interpretation of "a method" here. Sure, stitching happens, so that may make it "a method", but I would stay away from lifting it to being a "methodology". Even if it's widely spread that should not make it accepted.

So, as I said I find this is a very interesting topic and after all I have no reason to think this is a bad paper! =)

-- Hendrik

(Disclaimer, maybe: Yes, I do work "in the industry" and I guess me and my colleagues are guilty of the one or other "stitch". However, I really think that so far I've been employed with the more responsible type of companies and the really extreme experiences come from 3rd party implementations that I had to migrate from (oh, yes, sometimes companies do try again with another vendor!) or integrate with. I'm not lying. Go, employer! Seriously.)]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>901</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1334130407.5683";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
		<title>Ensemble effort estimation</title>
		<link>http://www.neverworkintheory.org/?p=301</link>
		<pubDate>Tue, 17 Apr 2012 15:00:06 +0000</pubDate>
		<dc:creator>jorge</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=301</guid>
		<description></description>
		<content:encoded><![CDATA[<em><a href="http://www.kocaguneli.com/">Ekrem Kocaguneli</a>, <a href="http://menzies.us/">Tim Menzies</a>, and <a href="http://www4.comp.polyu.edu.hk/~cswkeung/Home.html">Jacky Keung</a>. <a href="http://menzies.us/pdf/11comba.pdf"><strong>"On the value of ensemble effort estimation"</strong></a>, TSE 2011.</em>
<blockquote><em><strong>Background:</strong> Despite decades of research, there is no consensus on which software effort estimation methods produce the most accurate models.</em><em><strong></strong></em>

<em><strong>Aim:</strong> Prior work has reported that, given M estimation methods, no single method consistently outperforms all others. Perhaps rather than recommending one estimation method as best, it is wiser to generate estimates from ensembles of multiple estimation methods.</em>

<em><strong>Method:</strong> 9 learners were combined with 10 pre-processing options to generate 9 × 10 = 90 solo-methods. These were applied to 20 data sets and evaluated using 7 error measures. This identified the best n (in our case n = 13) solo-methods that showed stable performance across multiple datasets and error measures. The top 2, 4, 8 and 13 solo-methods were then combined to generate 12 multi-methods, which were then compared to the solo-methods.</em><em><strong></strong></em>

<em><strong>Results:</strong> (i) The top 10 (out of 12) multi-methods significantly out-performed all 90 solo-methods. (ii) The error rates of the multi-methods were significantly less than the solo-methods. (iii) The ranking of the best multi-method was remarkably stable.</em><em><strong></strong></em>

<em><strong>Conclusion:</strong> While there is no best single effort estimation method, there exist best combinations of such effort estimation methods.</em></blockquote>
Anybody who has ever done software effort estimation knows that it's a pretty hard thing to do. It's tough even for small individual tasks for someone without practice, and it's a horribly difficult task for large-scale group projects even for estimators with lots of practice. There are many methods that estimators could use, but as Kocaguneli &amp; Co remind us, "no single method consistently outperforms all others"---sometimes you're better off using method A, other times, method B would've been more appropriate. Their proposal: to build ensembles of methods, each of them deficient on their own, and to plug them with different automated learners in the hope that these new multi-methods will provide estimates with less error and more consistency.

The multi-methods approach worked well in their (pretty large) dataset of nearly 1,200 projects. This does <em>not</em> mean that the method that came out on top for them will come out on top for you, too. It only means that ensembles of methods are a good workaround for the problem of inconsistency of method efficacy. What the authors propose is for practitioners to learn the basics of machine learning and build method ensembles themselves:
<blockquote>Therefore, our recommendations to practitioners, who are willing to use multi-methods but lack the knowledge of machine learning algorithms are:
<ul>
	<li>Start with initial 2 learners and build the associated multi-methods</li>
	<li>See the performance of the current multi-methods</li>
	<li>Build new multi-methods only if you are not pleased with the performance of the current ones</li>
</ul>
</blockquote>
That won't be an easy task, but it may be less painful than committing to using a single method that often won't work. If you're interested in doing it, this paper has several references and pointers to get you started.

&nbsp;]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>301</wp:post_id>
		<wp:post_date>2012-04-17 08:00:06</wp:post_date>
		<wp:post_date_gmt>2012-04-17 15:00:06</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>ensemble-effort-estimation</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="estimation"><![CDATA[Estimation]]></category>
		<category domain="category" nicename="quantitative-studies"><![CDATA[Quantitative Studies]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>On the naturalness of software</title>
		<link>http://www.neverworkintheory.org/?p=308</link>
		<pubDate>Thu, 26 Apr 2012 18:00:11 +0000</pubDate>
		<dc:creator>jorge</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=308</guid>
		<description></description>
		<content:encoded><![CDATA[<em><a href="http://softwareprocess.es/static/SoftwareProcess.es.html">Abram Hindle</a>, <a href="http://earlbarr.com/">Earl Barr</a>, <a href="http://www.cs.ucdavis.edu/~su/">Zhendong Su</a>, <a href="http://www.cs.ucdavis.edu/~devanbu/">Prem Devanbu</a>, and <a href="http://www.utdallas.edu/~mark.gabel/">Mark Gabel</a>. <a href="http://macbeth.cs.ucdavis.edu/natural.pdf"><strong>"On the Naturalness of Software"</strong></a>, ICSE 2012.</em>
<blockquote><em>Natural languages like English are rich, complex, and powerful. The highly creative and graceful use of languages like English and Tamil, by masters like Shakespeare and Avvaiyar, can certainly delight and inspire. But in practice, given cognitive constraints and the exigencies of daily life, most human utterances are far simpler and much more repetitive and predictable. In fact, these utterances can be very usefully modeled using modern statistical methods. This fact has led to the phenomenal success of statistical approaches to speech recognition, natural language translation, question-answering, and text mining and comprehension.</em>

<em>We begin with the conjecture that most software is also natural, in the sense that it is created by humans at work, with all the attendant constraints and limitations—and thus, like natural language, it is also likely to be repetitive and predictable. We then proceed to ask whether a) code can be usefully modeled by statistical language models and b) such models can be leveraged to support software engineers. Using the widely adopted n-gram model, we provide empirical evidence supportive of a positive answer to both these questions. We show that code is also very repetitive, and in fact even more so than natural languages. As an example use of the model, we have developed a simple code completion engine for Java that, despite its simplicity, already improves Eclipse’s completion capability. We conclude the paper by laying out a vision for future research in this area.</em></blockquote>
This paper is not directly applicable to software practice, but you may still find it pretty cool and a great read. It uses the statistical approach to Natural Language Processing that is used to such good effect by tools such as Google Translate, but applied to lines of code. The authors find that code is much more amenable to statistical modelling than English. This means that more powerful code completion and code suggestion tools are viable (they prototyped one for Eclipse), and it also opens the door to new approaches in software mining research. Exciting stuff...]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>308</wp:post_id>
		<wp:post_date>2012-04-26 11:00:11</wp:post_date>
		<wp:post_date_gmt>2012-04-26 18:00:11</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>on-the-naturalness-of-software</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="mining"><![CDATA[Mining]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Example Embedding</title>
		<link>http://www.neverworkintheory.org/?p=315</link>
		<pubDate>Thu, 03 May 2012 03:00:08 +0000</pubDate>
		<dc:creator>LeifSinger</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=315</guid>
		<description></description>
		<content:encoded><![CDATA[<em><a title="Ohad Barzilay" href="http://www.cs.tau.ac.il/~ohadbr/">Ohad Barzilay</a></em>. <strong><a title="Ohad Barzilay. Example Embedding. " href="http://www.cs.tau.ac.il/~ohadbr/publications/ExampleEmbedding-onward2011Essay.pdf">“Example Embedding”</a></strong>, <em>Onward! 2011. </em>
<blockquote>Using code examples in professional software development is like teenage sex. Those who say they do it all the time are probably lying. Although it is natural, those who do it feel guilty. Finally, once they start doing it, they are often not too concerned with safety, they discover that it is going to take a while to get really good at it, and they realize they will have to come up with a bunch of new ways of doing it before they really figure it all out.</blockquote>
After we had an interesting discussion with input from industry a few weeks ago with the paper <strong><a href="http://www.neverworkintheory.org/?p=294">"Component reuse vs. snippet remixing"</a></strong>, I want to follow-up in that direction with another perspective. Apart from the hilarious abstract, it is a paper that reads well and entertains. In addition, it sheds some light onto a common, yet shunned practice.

From time to time, developers use example code from the Web in their own code. In his essay, Barzilay lays the foundation for talking about this phenomenon and identifies the elements of that ecosystem. For example, he mentions what kinds of sites are used by developers and what the process of reusing an example can look like. Addressing concerns from the <em>Component reuse vs. snippet remixing</em> paper, he discusses potential solutions for making the practice safer and more systematic. Finally, as an interesting analogy, Barzilay contrasts example embedding with academic practices.

While the use of examples from the Web may be looked down upon by several developers, it is a pervasive practice. Yet, neither industry nor research provide comprehensive support for making it safer. Barzilay's essay helps us understand what the example ecosystem looks like and gives us ideas for possible solutions of its problems.

<em>Finally: thanks to Jorge, Neil, and Greg for having me here at NWIT! </em>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>315</wp:post_id>
		<wp:post_date>2012-05-02 20:00:08</wp:post_date>
		<wp:post_date_gmt>2012-05-03 03:00:08</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>example-embedding</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="education"><![CDATA[Education]]></category>
		<category domain="category" nicename="practices"><![CDATA[Practices]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[18]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>A Review of &quot;Code Simplicity&quot;</title>
		<link>http://www.neverworkintheory.org/?p=323</link>
		<pubDate>Thu, 03 May 2012 10:16:13 +0000</pubDate>
		<dc:creator>gvwilson</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=323</guid>
		<description></description>
		<content:encoded><![CDATA[Max Kanat-Alexander: <a href="http://www.amazon.com/Code-Simplicity-Software-Development-ebook/dp/B007NZU848/"><cite>Code Simplicity: The Science of Software Development</cite></a> (Kindle edition). O'Reilly, 2012, B007NZU848.

The goal of this ambitious new book from O'Reilly, stated in its preface, is to "[lay] out scientific laws for software development, in a simple form that anybody can read." What it actually does, however, is demonstrate that its author doesn't really know what science is, or what science has already told us about his chosen subject.

Let's start with the first point. Kanat-Alexander's definition of a science is the traditional one: it is composed of facts that have been collected and organized, and contains general truths or basic laws that have been validated experimentally. Where he comes up short is in applying the last part of that definition. There are plenty of sweeping claims, many of which I actually agree with, but where's the data? Where are the experiments (or at least studies) showing how that data backs up his claims, and that those claims aren't actually refuted by any data? The only hard evidence on offer in the whole book is a table in chapter 5 showing how five files changed over time. The files aren't identified; neither are the projects they came from, and we're not told the timescale of the changes (was it days or years?).

The second failing of this book is that it completely ignores what we actually do know about programs and programmers. 20% of the way through the book [<a href="#1">1</a>], as he's trying to explain how we got into our present mess, he writes:
<blockquote>Then along came <cite>The Mythical Man Month</cite>, a book by Fred Brooks, who actually looked at the process of software development in a real project and pointed our some facts about it... He didn't come up wiht a whole science, but he did make some good observations... After that came a flurry of software development methods: the Rational Unified Process, the Capability Maturity Model, Agile Software Development, and many others. And that, basically, brings us up to where we are today: lots of methods, but no real <em>science</em>.</blockquote>
Well, no. Where we actually are today is in the middle of an explosion in real scientific understanding of how programmers work, how software evolves, how likely it is to contain bugs, and dozens of related topics. If this year matches 2011, something like 200 new peer-reviewed studies will be published, some by academics, and some by researchers at IBM, Microsoft Research, and other industrial labs. That's a lot for a working programmer to read, which is why we put together <a href="http://www.amazon.com/Making-Software-Really-Works-Believe/dp/0596808321/"><em>Making Software</em></a> (ironically, also published by O'Reilly) to summarize what we actually know and why we believe it's true.

So what are Kanat-Alexander's "laws", and how substantial are they?

<dl><dt><em>1. The purpose of software is <em>to help people</em>.</em></dt><dd>If I said, "The purpose of cars is to move people around," would you consider that a "law"?</dd><dt><em>2. The desirability of a change is directly proportional to the value now plus the future value, and inversely proportional to the effort of implementation plus the effort of maintenance.</em></dt><dd>Replace the word "desirability" with "value", and this is simply the definition of net present value.</dd><dt><em>3. The longer your program exists, the more likely it is that any piece of it will have to change.</em></dt><dd>Really? How does that claim stand up against the data that Elaine Weyuker and Tom Ostrand analyzed at AT&amp;T, or the work Nachi Nagappan, Tom Ball, and their colleagues have done at Microsoft Research?</dd><dt><em>4. The chance of introducing a defect into your program is proportional to the size of the changes you make to it.</em></dt><dd>The people listed above, plus others like Dewayne Perry, have found that small changes are proportionally more likely to introduce faults than large ones. If they're wrong, can Kanat-Alexander show where they made their mistake?</dd><dt><em>5. The ease of maintenance of any piece of software is proportional to the simplicity of its individual pieces.</em></dt><dd>If Kanat-Alexander knows how to measure the simplicity of a piece of software, he deserves the Turing Award: as El Emam shows and colleagues showed in 2001 (see Herraiz and Hassan's chapter in <cite>Making Software</cite> for a summary), we still don't have a complexity measure that performs any better than counting lines of code. If he <em>doesn't</em> know how to measure simplicity, how can he say that anything else is proportional to it? And either way, I strongly suspect that maintenance costs are influenced more by the complexity of the couplings between the components, rather than by their individual simplicity.</dd><dt><em>6. The degree to which you know how your software behaves is the degree to which you have accurately tested it.</em></dt><dd>I think this is saying that the degree to which we can predict how a program will behave is correlated with the amount of testing we've done. That's a plausible claim (assuming we agree on ways to measure "predictability" and "amount of testing"), but <em>where's the data?</em></dd></dl>The author of this book is clearly intelligent and passionate about his craft. He has undoubtedly written and shipped more good software in the last ten years than I ever will. If he doesn't know what we've discovered about software engineering in the last forty years, that's a clear sign that we're not doing our jobs properly. It isn't enough to be right: if we want our work to matter, we must communicate it to others, and this book shows that we have clearly failed to do that.
<p id="1">[1] How <em>do</em> you specify a location in an e-book that doesn't have page numbers?</p>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>323</wp:post_id>
		<wp:post_date>2012-05-03 03:16:13</wp:post_date>
		<wp:post_date_gmt>2012-05-03 10:16:13</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>a-review-of-code-simplicity</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="book-reviews"><![CDATA[Book Reviews]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>975</wp:comment_id>
			<wp:comment_author><![CDATA[Lauren Smith]]></wp:comment_author>
			<wp:comment_author_email>twittertext@gmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>50.46.164.204</wp:comment_author_IP>
			<wp:comment_date>2012-05-03 20:39:43</wp:comment_date>
			<wp:comment_date_gmt>2012-05-04 03:39:43</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Thanks for the excellent review. I agree the purpose of software is to help people. This book reminds me of another good read I just finished by John R. Fox entitled, Digital Work in an Analog World: Improving Software Engineering Through Applied Psychology. The author writes about the process of software development through a non-technical perspective and offers insight into techniques, teamwork and management. You can learn more about the book here: http://www.analogdevelopment.com/]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1336102783.6484";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>974</wp:comment_id>
			<wp:comment_author><![CDATA[mlindgren]]></wp:comment_author>
			<wp:comment_author_email>lindgren.mitch@gmail.com</wp:comment_author_email>
			<wp:comment_author_url>http://mlindgren.ca</wp:comment_author_url>
			<wp:comment_author_IP>174.3.183.120</wp:comment_author_IP>
			<wp:comment_date>2012-05-03 18:12:29</wp:comment_date>
			<wp:comment_date_gmt>2012-05-04 01:12:29</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Kindle has "location numbers" which work like page numbers.  They are not dependent on font size.  If you hit the menu key when reading a Kindle e-book, it will display the location number at the bottom of the page (and sometimes the page number as well, but I think that is extra data not provided by all books.)

I would assume most other e-book readers have something similar.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1336093949.4764";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>973</wp:comment_id>
			<wp:comment_author><![CDATA[John F]]></wp:comment_author>
			<wp:comment_author_email>johngeorgeferguson@gmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>85.211.137.190</wp:comment_author_IP>
			<wp:comment_date>2012-05-03 16:58:00</wp:comment_date>
			<wp:comment_date_gmt>2012-05-03 23:58:00</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Good blog post. Regarding your footnote about locations in e-books. The Bible has a good system of specifying location, so how about (Chapter_Number, Paragraph_Number, Sentence_Number), where Sentence_Number is optional.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1336089480.6277";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>991</wp:comment_id>
			<wp:comment_author><![CDATA[Brooks Moses]]></wp:comment_author>
			<wp:comment_author_email>brooks.moses@dpdx.net</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>64.81.73.35</wp:comment_author_IP>
			<wp:comment_date>2012-05-05 12:04:38</wp:comment_date>
			<wp:comment_date_gmt>2012-05-05 19:04:38</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[On your comment on law 2: "Replace the word “desirability” with “value”, and this is simply the definition of net present value."

That's not actually quite true, as anyone who's taken an engineering economics 101 course should remember -- it's the definition of net present value _if you assume that value tomorrow is exactly equivalent to value today_.  Usually there's a time-cost-of-money factor, so that you consider having a certain amount of money a year from now to be 95% (or whatever) as valuable as having it today.

I point this out, because I think that assumption is an error in the original; time-cost-of-value factors apply to program desirability and effort just as much as they apply to cash.  This is an error I've seen many times -- if I have a choice between releasing a good product now and spending half of the next five years fixing the architectural duct tape, or releasing a somewhat better product with no duct tape after a year of architectural redesign up front, Kanat-Alexander's law would tell me that the latter is more desirable.  In practice, it probably sinks my project because there's no incoming revenue for a year and someone pursuing the other strategy is taking over the market.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:14:"1336244678.566";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>1004</wp:comment_id>
			<wp:comment_author><![CDATA[Erik]]></wp:comment_author>
			<wp:comment_author_email>edlunde@gmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>128.6.168.245</wp:comment_author_IP>
			<wp:comment_date>2012-05-08 11:16:50</wp:comment_date>
			<wp:comment_date_gmt>2012-05-08 18:16:50</wp:comment_date_gmt>
			<wp:comment_content><![CDATA["How do you specify a location in an e-book that doesn’t have page numbers?" The simplest answer for generic electronic documents [1] is that you quote an extensive enough amount that a simple text search turns up the relevant section. The need for specifying a location is peculiar to the non-searchability of paper media.

[1] I have no experience with ebooks, but if they are different something is very wrong with them.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1336501010.4252";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
		<title>Cohesive and Isolated Development with Branches</title>
		<link>http://www.neverworkintheory.org/?p=327</link>
		<pubDate>Sun, 06 May 2012 10:43:09 +0000</pubDate>
		<dc:creator>gvwilson</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=327</guid>
		<description></description>
		<content:encoded><![CDATA[<em>Earl T. Barr, Christian Bird, Peter C. Rigby, Abram Hindle, Daniel M. German, and Premkumar Devanbu: <strong><a href="http://research.microsoft.com/apps/pubs/default.aspx?id=157290">Cohesive and Isolated Development with Branches</a></strong>.</em> FASE 2012.
<blockquote><em>The adoption of distributed version control (DVC), such as Git and Mercurial, in open-source software (OSS) projects has been explosive. Why is this and how are projects using DVC? This new generation of version control supports two important new features: <em>distributed repositories</em>, and <em>history-preserving branching and merging</em> where branching is easier, faster, and more accurately recorded. We observe that the vast majority of projects using DVC continue to use a centralized model of code sharing, while using branching much more extensively than when using CVC. In this study, we examine how branches are used by over sixty projects adopting DVC in an effort to understand and evaluate how branches are used and what benefits they provide. Through interviews with lead developers in OSS projects and a quantitative analysis of mined data from development histories, we find that projects that have made the transition are using observable branches more heavily to enable natural collaborative processes: history-preserving branching allow developers to collaborate on tasks in highly cohesive branches, while enjoying <em>reduced interference</em> from developers working on other tasks, even if those tasks are <em>strongly coupled</em> to theirs.</em></blockquote>
As the authors observe, distributed version control has become a must-have for fashionable open source developers in the past four years. But is it actually more productive than traditional (centralized) version control? Is it actually even <em>different</em>, once the hype is cleared away? According to this new study by Barr et al, the answer is a qualified "yes": while most projects (and developers) still use a hub-and-spoke model in practice, they make heavy use of DVCSes' support for lightweight branching and merging. Knowing this may help designers of the next generation of version control systems find better ways to support what people actually do.]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>327</wp:post_id>
		<wp:post_date>2012-05-06 03:43:09</wp:post_date>
		<wp:post_date_gmt>2012-05-06 10:43:09</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>cohesive-and-isolated-development-with-branches</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="qualitative-studies"><![CDATA[Qualitative Studies]]></category>
		<category domain="category" nicename="quantitative-studies"><![CDATA[Quantitative Studies]]></category>
		<category domain="category" nicename="tools"><![CDATA[Tools]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>The Architecture of Open Source Applications: Volume 2</title>
		<link>http://www.neverworkintheory.org/?p=333</link>
		<pubDate>Tue, 08 May 2012 17:54:52 +0000</pubDate>
		<dc:creator>gvwilson</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=333</guid>
		<description></description>
		<content:encoded><![CDATA[We are very pleased to announce that <a href="http://www.lulu.com/content/paperback-book/the-architecture-of-open-source-applications-volume-ii/12652487"><em>The Architecture of Open Source Applications: Volume 2</em></a> is now available from Lulu. A PDF version will go on sale in the next few days, and e-book will become available as soon as we can produce it. Many thanks to everyone who contributed, and to the indefatigable <a href="http://www.amyrbrown.ca/">Amy Brown</a> for pulling it all together. As always, all royalties will go directly to <a href="http://www.amnesty.org">Amnesty International</a>, so if you buy a copy, you’ll be helping to make the world a better place.]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>333</wp:post_id>
		<wp:post_date>2012-05-08 10:54:52</wp:post_date>
		<wp:post_date_gmt>2012-05-08 17:54:52</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>the-architecture-of-open-source-applications-volume-2</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="uncategorized"><![CDATA[Uncategorized]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Supporting Professional Spreadsheet Users by Generating Leveled Dataflow Diagrams</title>
		<link>http://www.neverworkintheory.org/?p=335</link>
		<pubDate>Thu, 24 May 2012 18:00:49 +0000</pubDate>
		<dc:creator>LeifSinger</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=335</guid>
		<description></description>
		<content:encoded><![CDATA[<em><a href="https://twitter.com/felienne">Felienne Hermans</a>, <a href="https://twitter.com/pinzger">Martin Pinzger</a>, and <a href="https://twitter.com/avandeursen">Arie van Deursen</a></em>. <strong><a title="Felienne Hermans, Martin Pinzger, and Arie van Deursen. Supporting Professional Spreadsheet Users by Generating Leveled Dataflow Diagrams." href="http://swerl.tudelft.nl/twiki/pub/Main/TechnicalReports/TUD-SERG-2010-036.pdf">“Supporting Professional Spreadsheet Users by Generating Leveled Dataflow Diagrams”</a></strong>, <em>ICSE 2011. </em>
<blockquote>Thanks to their flexibility and intuitive programming model, spreadsheets are widely used in industry, often for business- critical applications. Similar to software developers, pro- fessional spreadsheet users demand support for maintaining and transferring their spreadsheets.

In this paper, we first study the problems and information needs of professional spreadsheet users by means of a survey conducted at a large financial company. Based on these needs, we then present an approach that extracts this information from spreadsheets and presents it in a compact and easy to understand way, using leveled dataflow diagrams. Our approach comes with three different views on the dataflow and allows the user to analyze the dataflow diagrams in a top-down fashion also using slicing techniques.

To evaluate the usefulness of the proposed approach, we conducted a series of interviews as well as nine case studies in an industrial setting. The results of the evaluation clearly indicate the demand for and usefulness of our approach in ease the understanding of spreadsheets.</blockquote>

Many professional software developers might cringe when thinking about spreadsheets, or simply not take them seriously because they're not "real programming". They are, however, a fact of business and often get the job done. While they can be developed much faster, they also bear a great potential for errors. Felienne and her co-authors embraced this reality and decided to do something about it -- using approaches from software engineering. 

Ignoring any assumptions regarding the problems of spreadsheet users, they used Grounded Theory in an industry setting to find out which problems really existed in business. One thing they found was that existing spreadsheets often need to be understood by new users. Diving deeper, they found that the comprehensibility of such inherited spreadsheets was often seriously lacking -- posing a great risk from a business perspective. 

The authors then developed a tool to help with this issue. It creates dataflow diagrams that make dependencies in spreadsheet formulas visible. An evaluation with business users showed that these diagrams are indeed comprehensible and useful -- that is, they help end-users in understanding unfamiliar spreadsheets. Another interesting finding was that the creators of -- in their view -- simple spreadsheets only realized the actual complexity of their own creations after having used the tool. 

The best part is: Felienne, Martin, and Arie demonstrated the practical relevance again by launching <a href="http://infotron.nl/">a successful startup based on this research</a>! The company is now part of the Dutch startup incubator "YesDelft", has partnerships with several IT service companies, and has paying customers. How's that for practical relevance of research?]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>335</wp:post_id>
		<wp:post_date>2012-05-24 11:00:49</wp:post_date>
		<wp:post_date_gmt>2012-05-24 18:00:49</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>supporting-professional-spreadsheet-users-by-generating-leveled-dataflow-diagrams</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="collaboration"><![CDATA[Collaboration]]></category>
		<category domain="category" nicename="qualitative-studies"><![CDATA[Qualitative Studies]]></category>
		<category domain="category" nicename="tools"><![CDATA[Tools]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[18]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>1275</wp:comment_id>
			<wp:comment_author><![CDATA[Robert Klemme]]></wp:comment_author>
			<wp:comment_author_email>shortcutter@googlemail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>193.0.246.21</wp:comment_author_IP>
			<wp:comment_date>2012-06-06 06:11:34</wp:comment_date>
			<wp:comment_date_gmt>2012-06-06 13:11:34</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[What I find interesting about the spread sheets I see is that people seem to be uncomfortable to use cell functions. Instead often these sheets are filled with script code which does calculations in a procedural way. While this is understandable from a user's perspective (people tend to use the tools they know) this often ends in abuse of the spread sheet application and has a few drawbacks (in no particular order):

- often slower
- error prone because procedures may miss updates
- more obscure i.e. harder to understand
- generally it does not fit well with the computational model of spread sheets which propagate cell changes efficiently through their sophisticated dependency tracking mechanisms]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1338988294.4081";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>6385</wp:comment_id>
			<wp:comment_author><![CDATA[From spreadsheets to dataflow diagrams | Modeling Languages]]></wp:comment_author>
			<wp:comment_author_email></wp:comment_author_email>
			<wp:comment_author_url>http://modeling-languages.com/from-spreadsheets-to-dataflow-diagrams/</wp:comment_author_url>
			<wp:comment_author_IP>64.50.165.102</wp:comment_author_IP>
			<wp:comment_date>2013-05-06 21:50:17</wp:comment_date>
			<wp:comment_date_gmt>2013-05-07 04:50:17</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[[...] It will never work in practice, I discover the work (and of Felienne Hermans, Martin Pinzger and Arie van Deursen on [...]]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type>pingback</wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";d:1367902217.4273269176483154296875;s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
		<title>Do Faster Releases Improve Software Quality?</title>
		<link>http://www.neverworkintheory.org/?p=341</link>
		<pubDate>Thu, 17 May 2012 12:14:01 +0000</pubDate>
		<dc:creator>gvwilson</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=341</guid>
		<description></description>
		<content:encoded><![CDATA[<em>Foutse Khomh, Tejinder Dhaliwal, Ying Zou, and Bram Adams: <strong>Do Faster Releases Improve Software Quality? An Empirical Case Study of Mozilla Firefox</strong>. MSR 2012</em>
<blockquote><em>Nowadays, many software companies are shifting from the traditional 18-month release cycle to shorter release cycles. For example, Google Chrome and Mozilla Firefox release new versions every 6 weeks. These shorter release cycles reduce the users' waiting time for a new release and offer better marketing opportunities to companies, but it is unclear if the quality of the software product improves as well, since shorter release cycles result in shorter testing periods. In this paper, we empirically study the development process of Mozilla Firefox in 2010 and 2011, a period during which the project transitioned to a shorter release cycle. We compare crash rates, median uptime, and the proportion of post-release bugs of the versions that had a shorter release cycle with those having a traditional release cycle, to assess the relation between release cycle length and the software quality observed by the end user. We found that (1) with shorter release cycles, users do not experience significantly more post-release bugs and (2) bugs are fixed faster, yet (3) users experience these bugs earlier during software execution (the program crashes earlier).</em></blockquote>
Designing and building software is not like assembly-line manufacturing, but some aspects of it <em>can</em> be studied and improved like other industrial processes. In this upcoming paper, Khomh et al. examine the effects of Mozilla's switch from a yearly (or longer) release cycle to a much more frequent cycle. Their raw material is bug and crash data; their conclusions are:
<ol>
	<li>Users experience crashes earlier during the execution of versions developed following a rapid release model.</li>
	<li>The Firefox rapid release model fixes bugs faster than using the traditional model, but fixes proportionally less bugs.</li>
	<li>With a rapid release model, users adopt new versions faster compared to the traditional release model.</li>
</ol>
#3 is good news; #2 is (mostly) good, but #1 is a puzzle for which the authors don't have an explanation—at least, not yet. We'd welcome suggestions about why it might be.]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>341</wp:post_id>
		<wp:post_date>2012-05-17 05:14:01</wp:post_date>
		<wp:post_date_gmt>2012-05-17 12:14:01</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>do-faster-releases-improve-software-quality</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="mining"><![CDATA[Mining]]></category>
		<category domain="category" nicename="open-source"><![CDATA[Open Source]]></category>
		<category domain="category" nicename="quantitative-studies"><![CDATA[Quantitative Studies]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>1080</wp:comment_id>
			<wp:comment_author><![CDATA[David Jones]]></wp:comment_author>
			<wp:comment_author_email>drj@climatecode.org</wp:comment_author_email>
			<wp:comment_author_url>http://climatecode.org/</wp:comment_author_url>
			<wp:comment_author_IP>78.33.160.35</wp:comment_author_IP>
			<wp:comment_date>2012-05-18 02:07:10</wp:comment_date>
			<wp:comment_date_gmt>2012-05-18 09:07:10</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[#1's comments are interesting.  It is also possible that the "bugs come earlier in the execution time" effect is simply that the author's looked at a number of different variables: Time taken to fix a bug, number of lines of code in a bug fix patch, size of file in which bug fixes were made, and so on; and it's just that "time since execution began" was the one that happened to show a significant difference across the change in process. If you look at 20 variables one of them is bound to show a significant change (if you set your threshold at p &lt; 0.05).  http://xkcd.com/882/]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1337332030.4761";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>1063</wp:comment_id>
			<wp:comment_author><![CDATA[Will W]]></wp:comment_author>
			<wp:comment_author_email>will@wykeham.net</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>85.133.81.36</wp:comment_author_IP>
			<wp:comment_date>2012-05-17 09:00:50</wp:comment_date>
			<wp:comment_date_gmt>2012-05-17 16:00:50</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[#3 as an effect of this I slightly disagree with. It's more a question of it being a prerequisite.

A shorter release cycle tends to be either enabled by, or require the creation of an update system with reduced friction.
Updates that only happened every 18 months could tolerate a certain amount of user inconvenience and user input, but updates that happen every 6 weeks can't without significantly annoying the userbase. Google Chrome has a completely automatic, background update process that the user doesn't even notice, and Mozilla has moved towards that.

There is a potentially interesting question as to whether completely unattended updates _require_ rapid release cycles. If a major, obvious change suddenly appeared, users might not be so keen. But over the same 18 months, if the same change is delivered in a series of small increments, smoothing the user from point a to point b.

I'm dubious as to the weight that the conclusions can be given, given we don't know what other process changes would inevitably have accompanied such a shift in the way of working (and that it's a sample size of 1).]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1337270450.4603";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>1091</wp:comment_id>
			<wp:comment_author><![CDATA[Foutse]]></wp:comment_author>
			<wp:comment_author_email>foutse.khomh@queensu.ca</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>130.15.16.166</wp:comment_author_IP>
			<wp:comment_date>2012-05-18 11:17:36</wp:comment_date>
			<wp:comment_date_gmt>2012-05-18 18:17:36</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[David, we did use the Bonferroni correction to counteract the problem you are raising. The “time since execution began” was significant with a p-value of 6.11 e-06.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>1080</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1337365056.6889";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>1090</wp:comment_id>
			<wp:comment_author><![CDATA[Foutse]]></wp:comment_author>
			<wp:comment_author_email>foutse.khomh@queensu.ca</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>130.15.16.166</wp:comment_author_IP>
			<wp:comment_date>2012-05-18 11:08:04</wp:comment_date>
			<wp:comment_date_gmt>2012-05-18 18:08:04</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[David, we did use the Bonferroni correction to counteract the problem you are raising. The "time since execution began" was significant with a p-value of 6.11 e-06.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1337364484.6931";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>1089</wp:comment_id>
			<wp:comment_author><![CDATA[Atul]]></wp:comment_author>
			<wp:comment_author_email>avarma@mozilla.com</wp:comment_author_email>
			<wp:comment_author_url>http://toolness.com</wp:comment_author_url>
			<wp:comment_author_IP>66.207.208.98</wp:comment_author_IP>
			<wp:comment_date>2012-05-18 10:20:04</wp:comment_date>
			<wp:comment_date_gmt>2012-05-18 17:20:04</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[I suspect that (1) might be due to the ridiculous spectrum of end-user machine configurations which alter our software's behavior in unpredictable ways. This means that there can be "bugs" in our software that are actually impossible for us to detect at implementation time, and which can only be found by letting the software "bake"--i.e. letting real users try out the product on their own machines.

This implies that certain interoperability bugs can only be found by having a very large, very representative group of testers try our software on their own computers. A longer release cycle ultimately gave the software more time to bake, which meant we found more interop bugs before the product got to the general public.

Anyhow, that's just my guess, based on having shipped some desktop software before joining Mozilla, but I could easily be wrong.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1337361604.4259";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>1061</wp:comment_id>
			<wp:comment_author><![CDATA[Zack]]></wp:comment_author>
			<wp:comment_author_email>zackw@panix.com</wp:comment_author_email>
			<wp:comment_author_url>http://www.owlfolio.org/</wp:comment_author_url>
			<wp:comment_author_IP>99.113.33.155</wp:comment_author_IP>
			<wp:comment_date>2012-05-17 08:14:37</wp:comment_date>
			<wp:comment_date_gmt>2012-05-17 15:14:37</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[As a (mostly lapsed) Mozilla developer, I suspect #1 is due to an unrelated change that happened at roughly the same time as the switch to rapid releases: we started adding defensive code to make crashes happen closer to the point of the actual bug.  This both makes the actual bug easier to find and fix, and reduces the odds that the bug can be exploited to compromise security.  Or that's the theory, anyway.  It'd be really interesting to see a study of _that_.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1337267677.7114";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>1095</wp:comment_id>
			<wp:comment_author><![CDATA[Bram Adams]]></wp:comment_author>
			<wp:comment_author_email>bram.adams@polymtl.ca</wp:comment_author_email>
			<wp:comment_author_url>http://mcis.polymtl.ca/</wp:comment_author_url>
			<wp:comment_author_IP>132.207.169.84</wp:comment_author_IP>
			<wp:comment_date>2012-05-18 13:56:49</wp:comment_date>
			<wp:comment_date_gmt>2012-05-18 20:56:49</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[That's an interesting insight, thanks for the suggestion!]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>1061</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1337374609.6324";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>1158</wp:comment_id>
			<wp:comment_author><![CDATA[Jon Watte]]></wp:comment_author>
			<wp:comment_author_email>jwatte@gmail.com</wp:comment_author_email>
			<wp:comment_author_url>http://engineering.imvu.com/</wp:comment_author_url>
			<wp:comment_author_IP>204.225.145.242</wp:comment_author_IP>
			<wp:comment_date>2012-05-24 11:26:59</wp:comment_date>
			<wp:comment_date_gmt>2012-05-24 18:26:59</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[I'd be interested in seeing how continuous deployment (50 times a day!) would change the numbers. Unfortunately, I don't know of an organization has history without continuous deployment to compare to other history with continuous deployment.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1337884019.5982";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
		<title>Willingness to Share Research Data Is Related to the Strength of the Evidence and the Quality of Reporting of Statistical Results</title>
		<link>http://www.neverworkintheory.org/?p=348</link>
		<pubDate>Fri, 18 May 2012 15:12:57 +0000</pubDate>
		<dc:creator>gvwilson</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=348</guid>
		<description></description>
		<content:encoded><![CDATA[J.M. Wicherts, M. Bakker, and D. Molenaar: "<a href="http://www.plosone.org/article/info%3Adoi%2F10.1371%2Fjournal.pone.0026828">Willingness to Share Research Data Is Related to the Strength of the Evidence and the Quality of Reporting of Statistical Results</a>". <cite>PLoS ONE</cite>, 6(11): e26828, 2011, doi:10.1371/journal.pone.0026828.
<blockquote><em><strong>Background</strong>
The widespread reluctance to share published research data is often hypothesized to be due to the authors' fear that reanalysis may expose errors in their work or may produce conclusions that contradict their own. However, these hypotheses have not previously been studied systematically.</em>

<em><strong>Methods and Findings</strong>
We related the reluctance to share research data for reanalysis to 1148 statistically significant results reported in 49 papers published in two major psychology journals. We found the reluctance to share data to be associated with weaker evidence (against the null hypothesis of no effect) and a higher prevalence of apparent errors in the reporting of statistical results. The unwillingness to share data was particularly clear when reporting errors had a bearing on statistical significance.</em>

<em><strong>Conclusions</strong>
Our findings on the basis of psychological papers suggest that statistical results are particularly hard to verify when reanalysis is more likely to lead to contrasting conclusions. This highlights the importance of establishing mandatory data archiving policies.</em></blockquote>
There has been a lot of debate in recent years about how open science should be. Should people be required to share data? Should they be required to share code? And if so, how early in the research-to-publication process, and what restrictions should be put on re-use? Most of the arguments have been based on principle, but this work by Wicherts et al provides a powerful empirical basis for the "pro" side. Simply put, they found that the more reluctant researchers are to share their data, the more likely it is that their papers contain statistical errors. While correlation doesn't imply causation, it's hard to believe that there <em>isn't</em> a connection. Going forward, we will therefore try to note where the data (and analytic code) used in various papers is publicly available.]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>348</wp:post_id>
		<wp:post_date>2012-05-18 08:12:57</wp:post_date>
		<wp:post_date_gmt>2012-05-18 15:12:57</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>willingness-to-share-research-data-is-related-to-the-strength-of-the-evidence-and-the-quality-of-reporting-of-statistical-results</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="quantitative-studies"><![CDATA[Quantitative Studies]]></category>
		<category domain="category" nicename="reproducibility"><![CDATA[Reproducibility]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Open access research at NWIT, and everywhere</title>
		<link>http://www.neverworkintheory.org/?p=351</link>
		<pubDate>Tue, 29 May 2012 16:00:50 +0000</pubDate>
		<dc:creator>jorge</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=351</guid>
		<description></description>
		<content:encoded><![CDATA[We interrupt our regular programming to let you know of a slight change in editorial policy here at Never Work in Theory: although we always try to present journal and conference papers that are freely accessible online, we've made exceptions for interesting research that is only available behind a paywall. But our goal is to build bridges between software research and practice, and paywalled papers do not help---especially when considering that they report on research that, more often than not, citizens already paid for with their taxes. Therefore, from now on, <em>open access</em> is one of our few basic requirements for discussing papers at NWIT---the others being <em>empirical findings</em>, <em>relevance to practitioners</em>, and <em>no self-promotion</em>.

To clarify: at this point we don't care if the papers we present are available to the public through an Open Access journal (there's still <a title="danah boyd's curated list of Open Access journals" href="http://zephoria.tumblr.com/post/1054392618/open-access-journals">few of those in our area</a>) or through a researcher's personal website, as long as you can access them for free.

Open Access is gathering steam right now, and for good reason: <a title="Monbiot on academic publishing" href="http://www.monbiot.com/2011/08/29/the-lairds-of-learning/">academic publishing is one of the most abusive and least necessary businesses around</a>. Currently, <a title="Open Access Week" href="http://www.openaccessweek.org/profiles/blogs/sign-the-white-house-petition-on-open-access-to-research-today">in the United States</a>, there is <a title="Open Access - White House petition" href="https://wwws.whitehouse.gov/petitions/#!/petition/require-free-access-over-internet-scientific-journal-articles-arising-taxpayer-funded-research/wDX82FLQ">an online petition at the White House website</a> to require free access over the Internet to scientific articles arising from taxpayer-funded research. If enough people sign the petition, the White House is bound to consider it. It's currently about 6,000 signatures below the threshold; if this is something you care for at all, please consider adding your name today.]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>351</wp:post_id>
		<wp:post_date>2012-05-29 09:00:50</wp:post_date>
		<wp:post_date_gmt>2012-05-29 16:00:50</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>open-access-research-at-nwit-and-everywhere</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="announcements"><![CDATA[Announcements]]></category>
		<category domain="category" nicename="meta"><![CDATA[Meta]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>1220</wp:comment_id>
			<wp:comment_author><![CDATA[Jorge Aranda]]></wp:comment_author>
			<wp:comment_author_email>jorge@neverworkintheory.org</wp:comment_author_email>
			<wp:comment_author_url>http://www.neverworkintheory.org/</wp:comment_author_url>
			<wp:comment_author_IP>142.104.125.21</wp:comment_author_IP>
			<wp:comment_date>2012-05-29 10:22:54</wp:comment_date>
			<wp:comment_date_gmt>2012-05-29 17:22:54</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[I personally don't like that service much, but as long as readers can access the paper for free, it's all good for NWIT.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>1216</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1338312175.0112";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:5:"jorge";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>1216</wp:comment_id>
			<wp:comment_author><![CDATA[Adrian Schroeter]]></wp:comment_author>
			<wp:comment_author_email>adrian.schroeter@googlemail.com</wp:comment_author_email>
			<wp:comment_author_url>http://adrian-schroeter.com</wp:comment_author_url>
			<wp:comment_author_IP>142.104.21.213</wp:comment_author_IP>
			<wp:comment_date>2012-05-29 09:16:46</wp:comment_date>
			<wp:comment_date_gmt>2012-05-29 16:16:46</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[How is your assessment of the ACM authorize service, would that be enough to guarantee access for everyone or do you require the paper to be posted as pdf directly linkable from the web.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1338308207.1319";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
		<title>Crowd Documentation</title>
		<link>http://www.neverworkintheory.org/?p=357</link>
		<pubDate>Tue, 05 Jun 2012 16:00:30 +0000</pubDate>
		<dc:creator>jorge</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=357</guid>
		<description></description>
		<content:encoded><![CDATA[<em><a href="http://www.cc.gatech.edu/~vector/">Chris Parnin</a>, <a href="http://www.ctreude.ca/">Christoph Treude</a>, <a href="http://sites.google.com/site/larsgrammel/">Lars Grammel</a>, and <a href="http://margaretannestorey.wordpress.com/">Margaret-Anne Storey</a>. <strong><a href="http://www.cc.gatech.edu/~vector/papers/CrowdDoc-GIT-CS-12-05.pdf">Crowd Documentation: Exploring the Coverage and the Dynamics of API Discussions on Stack Overflow</a>.</strong> Georgia Tech Technical Report, 2012.</em>
<blockquote><em>Traditionally, many types of software documentation, such as API documentation, require a process where a few people write for many potential users. The resulting documentation, when it exists, is often of poor quality and lacks sufficient examples and explanations. In this paper, we report on an empirical study to investigate how Question and Answer (Q&amp;A) websites, such as Stack Overflow, facilitate crowd documentation — knowledge that is written by many and read by many. We examine the crowd documentation for three popular APIs: Android, GWT, and the Java programming language. We collect usage data using Google Code Search, and analyze the coverage, quality, and dynamics of the Stack Overflow documentation for these APIs. We find that the crowd is capable of generating a rich source of content with code examples and discussion that is actively viewed and used by many more developers. For example, over 35,000 developers contributed questions and answers about the Android API, covering 87% of the classes. This content has been viewed over 70 million times to date. However, there are shortcomings with crowd documentation, which we identify. In addition to our empirical study, we present future directions and tools that can be leveraged by other researchers and software designers for performing API analytics and mining of crowd documentation.</em></blockquote>
The process of figuring out how to use an API has changed radically since Q&amp;A sites (and in particular <a href="http://stackoverflow.com/">StackOverflow</a>) came along. But to what extent can we depend on such sites for complete, speedy documentation? Parnin and colleagues looked into this, and got some pretty interesting stats (a sample: 87% of all classes of the Android API and 77% of the Java API classes have at least one thread at StackOverflow; questions are answered in a median time of 11 minutes), and some visualization tools for you to play with the data: <a href="http://blog.ninlabs.com/2012/05/crowd-documentation/">see Chris Parnin's blog for more details</a>.

<em>(Disclaimer: I'm currently associated with Dr. Storey's lab. However, I did not participate in this research.)</em>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>357</wp:post_id>
		<wp:post_date>2012-06-05 09:00:30</wp:post_date>
		<wp:post_date_gmt>2012-06-05 16:00:30</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>crowd-documentation</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="documentation"><![CDATA[Documentation]]></category>
		<category domain="category" nicename="mining"><![CDATA[Mining]]></category>
		<category domain="category" nicename="quantitative-studies"><![CDATA[Quantitative Studies]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Software development estimation biases: the role of interdependence</title>
		<link>http://www.neverworkintheory.org/?p=359</link>
		<pubDate>Tue, 12 Jun 2012 16:00:42 +0000</pubDate>
		<dc:creator>jorge</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=359</guid>
		<description></description>
		<content:encoded><![CDATA[<em><a href="http://simula.no/people/magnej">Magne Jørgensen</a> and <a href="http://simula.no/people/steingr">Stein Grimstad</a>. <a href="http://simula.no/research/se/publications/Simula.SE.667/simula_pdf_file"><strong>"Software development estimation biases: the role of interdependence."</strong></a> TSE 2012 38(3).</em>
<blockquote><em>Software development effort estimates are frequently too low, which may lead to poor project plans and project failures. One reason for this bias seems to be that the effort estimates produced by software developers are affected by information that has no relevance for the actual use of effort. We attempted to acquire a better understanding of the underlying mechanisms and the robustness of this type of estimation bias. For this purpose, we hired 374 software developers working in outsourcing companies to participate in a set of three experiments. The experiments examined the connection between estimation bias and developer dimensions: self-construal (how one sees oneself), thinking style, nationality, experience, skill, education, sex, and organizational role. We found that estimation bias was present along most of the studied dimensions. The most interesting finding may be that the estimation bias increased significantly with higher levels of interdependence, i.e., with stronger emphasis on connectedness, social context, and relationships. We propose that this connection may be enabled by an activation of one’s self-construal when engaging in effort estimation, and a connection between a more interdependent self-construal and increased search for indirect messages, lower ability to ignore irrelevant context, and a stronger emphasis on socially desirable responses.</em></blockquote>
Researchers know that estimates of software development effort can be biased pretty easily by anchors and by irrelevant information. An important question, though, is whether these biases occur due to purely cognitive reasons or due to a desire to please and to connect with others. Jørgensen and Grimstad help answer this question, by getting hundreds of paid developers from several countries to participate in an experiment. Some of their findings:
<blockquote>Bias in effort estimation seems to be present for developers from all the countries studied. We were unable to find strong and systematic differences between countries or regions (Eastern Europe and Asia). (...)

In spite of the lack of any strong and systematic difference between the countries and regions, there may be culturally related variables that are useful for understanding the mechanisms by which estimation biases occur. In particular, a developer’s level of interdependence (emphasis on connectedness, social context, and relationship) seems to be connected systematically with how much he or she was affected by irrelevant and misleading information and with lower effort estimates.</blockquote>
In other words, they found that everyone (that would include <em>you</em> and your peers) seems susceptible to estimation biases, that people with greater levels of "interdependence" (those that give greater weight to relationships and connectedness) are more subject to bias, and that despite this, cultural differences by country do not seem to play an important role in estimation bias. The best thing you can do, in any case, is to try to shield estimators from anchors and other sources of bias as much as possible.]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>359</wp:post_id>
		<wp:post_date>2012-06-12 09:00:42</wp:post_date>
		<wp:post_date_gmt>2012-06-12 16:00:42</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>software-development-estimation-biases-the-role-of-interdependence</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="controlled-experiments"><![CDATA[Controlled Experiments]]></category>
		<category domain="category" nicename="estimation"><![CDATA[Estimation]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Tiny Transactions on Computer Science</title>
		<link>http://www.neverworkintheory.org/?p=366</link>
		<pubDate>Fri, 15 Jun 2012 14:41:28 +0000</pubDate>
		<dc:creator>gvwilson</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=366</guid>
		<description></description>
		<content:encoded><![CDATA[<a href="http://tinytocs.org/">TinyToCS</a> seeks papers describing significant research contributions to the field of computer science. Submissions can be up to 140 characters in length, with an abstract of no more than 250 words and a title of no more than 118 characters. Their sample is:
<blockquote>
<p style="text-align: center;"><strong>Reducibility Among Combinatorial Problems</strong></p>
<p style="text-align: center;">Kichard Rarp</p>
<p style="text-align: center;">University of Balifornia, Cerkeley</p>
<p style="text-align: center;">ABSTRACT</p>
A large class of computational problems involve the determination of properties of graphs, digraphs, integers, arrays of integers, finite families of finite sets, boolean formulas and elements of other countable domains. Through simple encodings from such domains into the set of words over a finite alphabet these problems can be converted into language recognition problems, and we can inquire into their computational complexity. It is reasonable to consider such a problem satisfactorily solved when an algorithm for its solution is found which terminates within a number of steps bounded by a polynomial in the length of the input.

Many problems with wide applicability – e.g., set cover, knapsack, hitting set, max cut, and satisfiability – lack a polynomial algorithm for solving them, but also lack a proof that no such polynomial algorithm exists. Hence, they remain “open problems.”

This paper references the recent work, “On the Reducibility of Combinatorial Problems” [1].

BODY

<em>A large class of open problems are mutually convertible via poly-time reductions. Hence, either all can be solved in poly-time, or none can.</em>

REFERENCES

[1] R. Karp. Reducibility Among Combinatorial Problems. In Complexity of Computer Computations, 1972.</blockquote>
So, what results from empirical software engineering can you summarize in a tweet? Answers in comments, please, and we'll award a copy of either <em><a href="http://www.amazon.com/Making-Software-Really-Works-Believe/dp/0596808321">Making Software</a></em> or <em><a href="http://www.amazon.com/Architecture-Open-Source-Applications-Volume/dp/1105571815/">The Architecture of Open Source Applications (Vol 2)</a></em> to the best answer.<em></em>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>366</wp:post_id>
		<wp:post_date>2012-06-15 07:41:28</wp:post_date>
		<wp:post_date_gmt>2012-06-15 14:41:28</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>tiny-transactions-on-computer-science</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="announcements"><![CDATA[Announcements]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>1321</wp:comment_id>
			<wp:comment_author><![CDATA[Leo]]></wp:comment_author>
			<wp:comment_author_email>lmeyerov@gmail.com</wp:comment_author_email>
			<wp:comment_author_url>http://www.eecs.berkeley.edu/~lmeyerov</wp:comment_author_url>
			<wp:comment_author_IP>136.152.209.45</wp:comment_author_IP>
			<wp:comment_date>2012-06-17 18:55:53</wp:comment_date>
			<wp:comment_date_gmt>2012-06-18 01:55:53</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Socio-PLT: Quantifying Language Perception

Leo Meyerovich and Ari Rabkin (UC Berkeley)

TWEET:
In polls about programming language, we found many surprises. For example, type systems anti-correlate with code reuse. 


ABSTRACT:
See tweet. 

Experimental setup: 14,000 respondents filled out an online survey over 2 years. They ranked different statements about different languages that they claimed to be familiar with. The Glicko algorithm was used, for each statement, to sort how well the languages matched it. From there, we found an anti-correlation between the "strongly typed" statement position and "code reuse" position for most languages.

This work is a quantitative follow-up to our recent analytic work on social theories that predict and explain non-obvious language adoption behavior and perceptions [1].

REFERENCES

[1]. Leo Meyerovich, Ari Rabkin. Socio-PLT: Sociological Principles for Programming Language Adoption. Onward! 2012.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1339984553.6308";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>1310</wp:comment_id>
			<wp:comment_author><![CDATA[Adrian Schroeter]]></wp:comment_author>
			<wp:comment_author_email>adrian.schroeter@googlemail.com</wp:comment_author_email>
			<wp:comment_author_url>http://adrian-schroeter.com</wp:comment_author_url>
			<wp:comment_author_IP>142.104.21.213</wp:comment_author_IP>
			<wp:comment_date>2012-06-15 10:15:50</wp:comment_date>
			<wp:comment_date_gmt>2012-06-15 17:15:50</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Cross-project Defect Prediction: A Large Scale Experiment on Data vs. Domain vs. Process

Thomas Zimmermann, Nachiappan Nagappan, Brendan Murphy  
Microsoft Research 

Harald Gall, Emanuel Giger 
University of Zurich  

ABSTRACT

Prediction of software defects works well within projects as long as there is a sufficient amount of data available to train any models. However, this is rarely the case for new software projects and for many companies. So far, only a few have studies focused on transferring prediction models from one project to another. In this paper, we study cross-project defect prediction models on a large scale. For 12 real-world applications, we ran 622 cross-project predictions. Our results indicate that cross-project prediction is a serious challenge, i.e., simply using models from projects in the same domain or with the same process does not lead to accurate predictions. To help software engineers choose models wisely, we identified factors that do influence the success of cross-project predictions. We also derived decision trees that can provide early estimates for precision, recall, and accuracy before a prediction is attempted.

This work [1] was presented as ESEC/FSE.

BODY

We haven't found a single set of variables that can predict defects across projects.

REFERENCES

[1] T. Zimmermann, N. Naggapan, H. Gall, E. Giger, B. Murphy. Cross-project defect prediction: a large scale experiment on data vs. domain vs. process  -- http://thomas-zimmermann.com/publications/files/zimmermann-esecfse-2009.pdf]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1339780551.1802";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>1330</wp:comment_id>
			<wp:comment_author><![CDATA[Craig Stuntz]]></wp:comment_author>
			<wp:comment_author_email>craig_stuntz@acm.org</wp:comment_author_email>
			<wp:comment_author_url>http://blogs.teamb.com/craigstuntz/</wp:comment_author_url>
			<wp:comment_author_IP>70.60.2.26</wp:comment_author_IP>
			<wp:comment_date>2012-06-18 09:57:52</wp:comment_date>
			<wp:comment_date_gmt>2012-06-18 16:57:52</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[One of my favorites, which I found on this blog:

"Perl users were unable to write programs more accurately than those using a language designed by chance."

http://www.neverworkintheory.org/?p=197]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1340038673.0933";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
		<title>Usability Analysis of Visual Programming Environments: a &#039;Cognitive Dimensions&#039; Framework</title>
		<link>http://www.neverworkintheory.org/?p=370</link>
		<pubDate>Mon, 25 Jun 2012 18:18:08 +0000</pubDate>
		<dc:creator>neil</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=370</guid>
		<description></description>
		<content:encoded><![CDATA[<em>Thomas Green and <a href="http://mcs.open.ac.uk/mp8/">Marian Petre</a></em>, <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.54.3584&amp;rep=rep1&amp;type=pdf">“Usability Analysis of Visual Programming Environments: a 'cognitive dimensions' framework”</a>, <em>Visual Languages and Computing</em>, 7:131—174, 1996.
<blockquote>The cognitive dimensions framework is a broad-brush evaluation technique for interactive devices and for non-interactive notations. It sets out a small vocabulary of terms designed to capture the cognitively-relevant aspects of structure, and shows how they can be traded off against each other. The purpose of this paper is to propose the framework as an evaluation technique for visual programming environments. We apply it to two commercially-available dataflow languages (with further examples from other systems) and conclude that it is effective and insightful; other HCI-based evaluation techniques focus on different aspects and would make good complements. Insofar as the examples we used are representative, current VPLs are successful in achieving a good ‘closeness of match’, but designers need to consider the ‘viscosity’ (resistance to local change) and the ‘secondary notation’ (possibility of conveying extra meaning by choice of layout, colour, etc.).</blockquote>
It must be a major coup as a researcher for your research to make in <a href="http://en.wikipedia.org/wiki/Cognitive_dimensions_of_notations">onto Wikipedia</a> (and not get deleted for “notability”). The reason the Cognitive Dimensions framework has had such impact is that it is a great way to assess user interfaces without conducting user studies (which are costly and often of questionable value). Green’s Cognitive Dimensions framework proposes a set of heuristic criteria which evaluate how well the interface supports certain tasks. These criteria include <em>consistency</em>, <em>hard mental operations</em> and <em>error-proneness</em>.

In this paper Green and Petre apply the framework to visual programming environments (e.g., <a href="http://www.mathworks.com/products/simulink/">Simulink</a>). The research question they investigate is the degree to which these tools help in writing software compared to a text editor for Basic programming, using a yardstick problem of calculating rocket trajectory.

Some of their findings:
<ul>
	<li>Visual programming languages can easily grow incomprehensible, placing “severe demands on working memory” as concepts become intertwined.</li>
	<li>Abstraction is easier to manage in visual languages, since low-level items can literally be hidden away.</li>
	<li>Adding new code to existing visual programs was very slow: from 508 seconds for LabView, 194 seconds for Prograph and only 63 seconds in Basic, which they note is “an astonishing ratio of 8:1 between extremes”.</li>
	<li>These languages, like spreadsheets, make long-range data dependencies difficult to track down.</li>
	<li>Textual languages (like Pascal or Basic) support secondary notations such as the use of whitespace or statement ordering to communicate other information. In the two visual languages they studied, these notations are meagre. Visual layout is not terribly useful for communicating information. For example,</li>
</ul>
<blockquote>"I quite often spend an hour or two just moving boxes and wires around, with no change in functionality, to make it that much more comprehensible when I come back to it.” It is hard to imagine a Pascal programmer having to spend an hour or two doing nothing but re-arranging the components of the program to make it comprehensible.</blockquote>
Many of these findings are even more relevant today in the model-driven design (MDD) field, and show the power of a simple set of heuristics in uncovering potential difficulties. Designers of modern visual language tools (like <a href="http://www.metacase.com/mwb/">Metacase</a>) should be able to explain how they overcome these challenges.]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>370</wp:post_id>
		<wp:post_date>2012-06-25 11:18:08</wp:post_date>
		<wp:post_date_gmt>2012-06-25 18:18:08</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>usability-analysis-of-visual-programming-environments-a-cognitive-dimensions-framework</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="programming-languages"><![CDATA[Programming Languages]]></category>
		<category domain="category" nicename="qualitative-studies"><![CDATA[Qualitative Studies]]></category>
		<category domain="category" nicename="tools"><![CDATA[Tools]]></category>
		<category domain="category" nicename="usability"><![CDATA[Usability]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>1471</wp:comment_id>
			<wp:comment_author><![CDATA[Agris Sostaks]]></wp:comment_author>
			<wp:comment_author_email>agris.shostaks@gmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>85.254.199.118</wp:comment_author_IP>
			<wp:comment_date>2012-07-05 08:13:37</wp:comment_date>
			<wp:comment_date_gmt>2012-07-05 15:13:37</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[You should definetily look at "Physics of Notations" by D.Moody
http://goo.gl/3KbW6]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1341501218.0543";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
		<title>Combining Functional and Imperative Programming for Multicore Software: An Empirical Study Evaluating Scala and Java</title>
		<link>http://www.neverworkintheory.org/?p=375</link>
		<pubDate>Mon, 18 Jun 2012 13:06:51 +0000</pubDate>
		<dc:creator>gvwilson</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=375</guid>
		<description></description>
		<content:encoded><![CDATA[<em><a href="http://www.victorpankratius.com/">Victor Pankratius</a>, Felix Schmidt, and Gilda Garretón: <a href="http://www.rz.uni-karlsruhe.de/~kb95/papers/pankratius-Scala-ICSE12-preprint.pdf">"Combining Functional and Imperative Programming for Multicore Software: An Empirical Study Evaluating Scala and Java."</a> <a href="http://www.ifi.uzh.ch/icse2012/">ICSE 2012</a>.</em>



<blockquote>
  <em>Recent multi-paradigm programming languages combine functional and imperative programming styles to make software development easier. Given today's proliferation of multicore processors, parallel programmers are supposed to benefit from this combination, as many difficult problems can be expressed more easily in a functional style while others match an imperative style. Due to a lack of empirical evidence from controlled studies, however, important software engineering questions are largely unanswered. Our paper is the first to provide thorough empirical results by using Scala and Java as a vehicle in a controlled comparative study on multicore software development. Scala combines functional and imperative programming while Java focuses on imperative shared-memory programming. We study thirteen programmers who worked on three projects, including an industrial application, in both Scala and Java. In addition to the resulting 39 Scala programs and 39 Java programs, we obtain data from an industry software engineer who worked on the same project in Scala. We analyze key issues such as effort, code, language usage, performance, and programmer satisfaction. Contrary to popular belief, the functional style does not lead to bad performance. Average Scala run-times are comparable to Java, lowest run-times are sometimes better, but Java scales better on parallel hardware. We confirm with statistical significance Scala's claim that Scala code is more compact than Java code, but clearly refute other claims of Scala on lower programming effort and lower debugging effort. Our study also provides explanations for these observations and shows directions on how to improve multi-paradigm languages in the future.</em>


</blockquote>

Functional programming has been the "next big thing" in computing for thirty years, and people joke that it still will be thirty years from now. These days, arguments for it are often based on the claim that parallel programming is easier in the absence of side effects. Like any plausible claim, though, that one needs to be tested empirically before it can be accepted.



This study by Pankratius et al is one such test. Thirteen Master's students in Computer Science with an average of four years of Java experience, and no previous Scala experience, were given four weeks of training in both Java and Scala, then required to provide implementations of the Dining Philosophers problem and a basic mergesort algorithm. With that warmup out of the way, the subjects moved on to the real task: implementing a 17-page spec for a VLSI layout problem. To do this, they were divided randomly into two groups: one tackled the problem in Scala first, then in Java, while the other group did Java, then Scala. (This counter-balancing allows assessment of learning effects.)



The results? First, it took participants longer to solve the problem in Scala than in Java (median times were <del>6</del> 56 hours and 43 hours respectively). What was really interesting was that programmer skill (as measured by a pre-test) did not have a significant influence on testing and debugging time, which suggests that the difference was <em>not</em> skill-based. One hypothesis (based on interviews) is that Scala's automatic type inference actually made debugging more difficult.



A second result was that the final Scala programs were significantly smaller than their Java counterparts. However, the difference was smaller than many of the claims one can find on the Internet: only 2.6% (mean) or 15.2% (median), rather than factors of two, five, or ten. On the other hand, the Scala programs performed as well as their Java counterparts, or better, which contrasts with claims that functional programming is inherently slow.



Overall, this was a well-executed study of an important subject, and a good demonstration of the value of studying programming languages empirically. If anyone would like to translate it into a tweet, we'd be happy to enter the result in <a href="/?p=366">our competition</a>.



**<em>Errata: ***Median times were 56 hours for Scala and 43 for Java, not 6 and 43. Post edited to fix the typo. *--J.A.</em>


]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>375</wp:post_id>
		<wp:post_date>2012-06-18 06:06:51</wp:post_date>
		<wp:post_date_gmt>2012-06-18 13:06:51</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>combining-functional-and-imperative-programming-for-multicore-software-an-empirical-study-evaluating-scala-and-java</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="controlled-experiments"><![CDATA[Controlled Experiments]]></category>
		<category domain="category" nicename="programming-languages"><![CDATA[Programming Languages]]></category>
		<category domain="category" nicename="quantitative-studies"><![CDATA[Quantitative Studies]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>1328</wp:comment_id>
			<wp:comment_author><![CDATA[Daniel Sobral]]></wp:comment_author>
			<wp:comment_author_email>dcsobral@gmail.com</wp:comment_author_email>
			<wp:comment_author_url>http://dcsobral.blogspot.com/</wp:comment_author_url>
			<wp:comment_author_IP>189.9.0.2</wp:comment_author_IP>
			<wp:comment_date>2012-06-18 09:51:13</wp:comment_date>
			<wp:comment_date_gmt>2012-06-18 16:51:13</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[In my and others experience, a programmer writes Java in Scala after three weeks, and only starts to benefit from functional features after about three months. Given the four years Java experience and no time of Scala experience, the four weeks training seems awfully inadequate.

I'm still going to read the paper, but it would be interesting to have some static assessment on how idiomatic the code produced was, by comparing against open source Scala projects usage of features such as val vs var, mutable vs immutable collections, foreach vs map/flatMap loops, use of indices, Option vs Null, specific patterns of Option usage (if/get vs pattern matching vs map/getOrElse), and type class/context bounds vs inheritance.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1340038273.8537";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>1326</wp:comment_id>
			<wp:comment_author><![CDATA[Jorge Aranda]]></wp:comment_author>
			<wp:comment_author_email>jorge@neverworkintheory.org</wp:comment_author_email>
			<wp:comment_author_url>http://www.neverworkintheory.org/</wp:comment_author_url>
			<wp:comment_author_IP>142.104.21.204</wp:comment_author_IP>
			<wp:comment_date>2012-06-18 09:09:42</wp:comment_date>
			<wp:comment_date_gmt>2012-06-18 16:09:42</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[While we find a reliable pdf link, you can find a cached version of the paper <a href="http://webcache.googleusercontent.com/search?q=cache:nTg4g64VqhAJ:https://files.ifi.uzh.ch/icse2012/proceedings/icse12-online/icse12/p123-285-pankratius.pdf" rel="nofollow">here</a>.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>1325</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1340035782.4072";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:5:"jorge";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>1325</wp:comment_id>
			<wp:comment_author><![CDATA[item]]></wp:comment_author>
			<wp:comment_author_email>itemStateChanged@yahoo.de</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>92.238.121.43</wp:comment_author_IP>
			<wp:comment_date>2012-06-18 08:29:58</wp:comment_date>
			<wp:comment_date_gmt>2012-06-18 15:29:58</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[So where is the paper?]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1340033399.1509";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>1360</wp:comment_id>
			<wp:comment_author><![CDATA[huynhjl]]></wp:comment_author>
			<wp:comment_author_email>jlh276-gh@yahoo.com</wp:comment_author_email>
			<wp:comment_author_url>http://stackoverflow.com/users/257449/huynhjl</wp:comment_author_url>
			<wp:comment_author_IP>99.169.164.109</wp:comment_author_IP>
			<wp:comment_date>2012-06-22 07:21:13</wp:comment_date>
			<wp:comment_date_gmt>2012-06-22 14:21:13</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[The subjects in this study were 3rd/4th year CS students with 4 year of Java and zero exerience in Scala. They got additional Java training on top for this study. So that is huge head start for Java. It means that would have some familiarity with the Java API and the ecosystem. So when you look at the end results, they achieved in Scala as well as Java *only* after an average *20 hours* of additional work. 

I also think that none of that is adequate training and background to write good code - if you are dealing with normal people. Given that concurrent and parallel programming is one of the hardest thing to do it would take more exposure to other concurrent/parallel tasks to solve before making smart decisions. 

How long does it take to be good at programming? Years. What are 20 hours of additional effort for somebody to get some functional programming exposure and have one more arrow in their quiver?]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>1332</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1340374874.1651";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>1336</wp:comment_id>
			<wp:comment_author><![CDATA[Darrin Thompson]]></wp:comment_author>
			<wp:comment_author_email>darrinth@gmail.com</wp:comment_author_email>
			<wp:comment_author_url>http://willowbend.cx/</wp:comment_author_url>
			<wp:comment_author_IP>99.179.162.91</wp:comment_author_IP>
			<wp:comment_date>2012-06-18 19:27:55</wp:comment_date>
			<wp:comment_date_gmt>2012-06-19 02:27:55</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[You said 4 months, but I'd guess that evaluating people 4 years of Scala experience would be interesting.

If you said to me or one of my coworkers, if you learn and use this new language you will write faster and possibly better code but after 4 weeks of training you will write code at only 20% the speed of Java. I would believe the claim and probably not recommend that we switch wholesale to Scala.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>1332</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1340072875.6383";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>1348</wp:comment_id>
			<wp:comment_author><![CDATA[Cedric]]></wp:comment_author>
			<wp:comment_author_email>rixed@free.fr</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>80.214.8.190</wp:comment_author_IP>
			<wp:comment_date>2012-06-19 21:29:42</wp:comment_date>
			<wp:comment_date_gmt>2012-06-20 04:29:42</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[I was also very intrigued as to how the authors managed to get around the significant experience gapbetween the 2 languages, and now that I've read the article I am quite disapointed that this factor was apparently not deamed important enough.

Which gives us our tweet version: "We compared how beginers in Scala performs compared to experienced Java programmers, and find out that they require a few more time to complete" :-)

Also, it's not clear exactly what's the level of experience of the Oracle professional. If he's indeed experienced in Scala then the fact that he did not perform significantly better than the students for the parallel version is very interresting ("We compared how a functionnal language helps writing parallel code and find out that it's equaly hard whatever the tools and experience")]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1340166582.4253";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>1362</wp:comment_id>
			<wp:comment_author><![CDATA[Brian Burg]]></wp:comment_author>
			<wp:comment_author_email>burg@cs.washington.edu</wp:comment_author_email>
			<wp:comment_author_url>http://www.cs.washington.edu/homes/burg/</wp:comment_author_url>
			<wp:comment_author_IP>128.208.4.223</wp:comment_author_IP>
			<wp:comment_date>2012-06-22 13:24:02</wp:comment_date>
			<wp:comment_date_gmt>2012-06-22 20:24:02</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[I agree with the concerns related to studying experienced vs. novice programmers. Unfortunately, evaluations in academia will continue to use students for studies greater than tiny-scale due to the high cost of compensating programmers for their time. It is possible to find experienced volunteers for such studies, but then the population is very self-selected. Volunteers also do not come dozens at a time, which makes it hard to conduct or publish a study in a reasonable amount of time.

The two most viable ways forward, in my opinion, are: use small tasks to minimize the time/payment required per subject (at significant risk of screwing up validity), or conduct the study internally at a company, so that money is not an issue.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1340396643.0083";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>1671</wp:comment_id>
			<wp:comment_author><![CDATA[Sandro Gržičić]]></wp:comment_author>
			<wp:comment_author_email>sandro.grzicic@fer.hr</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>93.137.134.216</wp:comment_author_IP>
			<wp:comment_date>2012-08-28 06:19:58</wp:comment_date>
			<wp:comment_date_gmt>2012-08-28 13:19:58</wp:comment_date_gmt>
			<wp:comment_content><![CDATA["Thirteen Master’s students in Computer Science with an average of four years of Java experience, and no previous Scala experience"

"were given four weeks of training in both Java and Scala"

"The results? First, it took participants longer to solve the problem in Scala than in Java (median times were 56 hours and 43 hours respectively)"

So you're telling me that after only 4 weeks of introduction to Scala, it took only 30% longer (basically nothing) to produce valid Scala code, as compared to 4 YEARS of Java experience? That's great, it proves that Scala is simple, easy to learn and you can be productive in a really short time.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1346159998.9573";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>1329</wp:comment_id>
			<wp:comment_author><![CDATA[gvwilson]]></wp:comment_author>
			<wp:comment_author_email>gvwilson@third-bit.com</wp:comment_author_email>
			<wp:comment_author_url>http://third-bit.com/</wp:comment_author_url>
			<wp:comment_author_IP>66.207.208.98</wp:comment_author_IP>
			<wp:comment_date>2012-06-18 09:53:50</wp:comment_date>
			<wp:comment_date_gmt>2012-06-18 16:53:50</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[The paper does include discussion of code reviews, use of idiomatic features, etc. If someone would like to help them organize a repeat experiment with more experienced Scala programmers, I'm sure they'd be thrilled :-)]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>1328</wp:comment_parent>
			<wp:comment_user_id>2</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1340038430.7876";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:8:"gvwilson";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>1332</wp:comment_id>
			<wp:comment_author><![CDATA[Daniel Sobral]]></wp:comment_author>
			<wp:comment_author_email>dcsobral@gmail.com</wp:comment_author_email>
			<wp:comment_author_url>http://dcsobral.blogspot.com/</wp:comment_author_url>
			<wp:comment_author_IP>189.9.0.2</wp:comment_author_IP>
			<wp:comment_date>2012-06-18 10:38:27</wp:comment_date>
			<wp:comment_date_gmt>2012-06-18 17:38:27</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[So, read the paper. Pretty good, but it doesn't really address my concerns. I'd still like to know how "idiomatic" the code was, for the purpose of size comparisons, and there is one point that I'm having trouble accepting:

"In this phase, we also measuredthe level of proficiency; a Java pretest classified 7 subjectsas experts and 6 as beginners. A Scala pretest classified 7subjects as experts, and 6 as beginners. At the end of phaseone, everyone passed and was ready to work on a larger project."

It's easy to get imperative proficiency with Scala, but functional proficiency takes longer, since most programmers know imperative paradigm before-hand, but not functional paradigm. Given the description of the programmers and their training, these expert/beginners rating seem improbable, and no explanation was given on how this assessment was made. Or, perhaps, I skipped it by mistake, but I was looking for that.

This concern of mine is further reinforced by this:

"Interview data suggeststhat subjects needed time to figure out how to exactly takeadvantage of the functional style in their particular program."

Needless to say, that's not a sign of expertise.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1340041107.9243";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>1337</wp:comment_id>
			<wp:comment_author><![CDATA[Adrian]]></wp:comment_author>
			<wp:comment_author_email>akuhn@iam.unibe.ch</wp:comment_author_email>
			<wp:comment_author_url>http://twitter.com/akuhn</wp:comment_author_url>
			<wp:comment_author_IP>24.85.90.36</wp:comment_author_IP>
			<wp:comment_date>2012-06-18 20:53:40</wp:comment_date>
			<wp:comment_date_gmt>2012-06-19 03:53:40</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[I hope they get a chance to repeat the experiment with experienced Scala developers.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1340078021.0519";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>1338</wp:comment_id>
			<wp:comment_author><![CDATA[Raymond]]></wp:comment_author>
			<wp:comment_author_email>raymondtay1974@gmail.com</wp:comment_author_email>
			<wp:comment_author_url>http://raymondtay.blogspot.com</wp:comment_author_url>
			<wp:comment_author_IP>220.255.2.166</wp:comment_author_IP>
			<wp:comment_date>2012-06-18 21:15:57</wp:comment_date>
			<wp:comment_date_gmt>2012-06-19 04:15:57</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Not to be overly critical over the experiment but the various points in the paper were derived from the subjects limited experience with Scala and Java in the experiment and as Daniel Sobral pointed out on functional vs. imperative proficiencies; i thought Adrian's suggestion was good and perhaps a second study can be conducted where the subjects are experienced Scala/Java developers and a comparison study of that sort would make more sense since the more experienced folks tend to use more idiomatic code in both languages. Definitely a more all-rounded coverage.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1340079357.7637";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>1339</wp:comment_id>
			<wp:comment_author><![CDATA[Darrin Thompson]]></wp:comment_author>
			<wp:comment_author_email>darrinth@gmail.com</wp:comment_author_email>
			<wp:comment_author_url>http://willowbend.cx/</wp:comment_author_url>
			<wp:comment_author_IP>207.250.96.103</wp:comment_author_IP>
			<wp:comment_date>2012-06-19 06:20:53</wp:comment_date>
			<wp:comment_date_gmt>2012-06-19 13:20:53</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[It would be a lot more expensive.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>1337</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1340112053.5687";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>1341</wp:comment_id>
			<wp:comment_author><![CDATA[Rogach]]></wp:comment_author>
			<wp:comment_author_email>platon7pronko@gmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>85.21.143.104</wp:comment_author_IP>
			<wp:comment_date>2012-06-19 10:31:13</wp:comment_date>
			<wp:comment_date_gmt>2012-06-19 17:31:13</wp:comment_date_gmt>
			<wp:comment_content><![CDATA["...it took participants longer to solve the problem in Scala than in Java (median times were 6 hours and 43 hours respectively)" - is it a mistake? Maybe you meant 4.3 hours?]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1340127074.0974";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>1342</wp:comment_id>
			<wp:comment_author><![CDATA[Jorge Aranda]]></wp:comment_author>
			<wp:comment_author_email>jorge@neverworkintheory.org</wp:comment_author_email>
			<wp:comment_author_url>http://www.neverworkintheory.org/</wp:comment_author_url>
			<wp:comment_author_IP>142.104.219.183</wp:comment_author_IP>
			<wp:comment_date>2012-06-19 10:49:33</wp:comment_date>
			<wp:comment_date_gmt>2012-06-19 17:49:33</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Good catch---it's <em>56</em> hours, not 6. I'll fix the typo in the post.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>1341</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1340128173.2959";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:5:"jorge";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>1675</wp:comment_id>
			<wp:comment_author><![CDATA[Darrin Thompson]]></wp:comment_author>
			<wp:comment_author_email>darrinth@gmail.com</wp:comment_author_email>
			<wp:comment_author_url>http://willowbend.cx/</wp:comment_author_url>
			<wp:comment_author_IP>99.179.162.91</wp:comment_author_IP>
			<wp:comment_date>2012-08-28 15:44:33</wp:comment_date>
			<wp:comment_date_gmt>2012-08-28 22:44:33</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Long term productivity would be hard to measure. But maybe "changability" would be a reasonable proxy.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>1674</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:13:"1346193873.99";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>1723</wp:comment_id>
			<wp:comment_author><![CDATA[Steering Cockroaches &amp;c &laquo; Kynosarges Weblog]]></wp:comment_author>
			<wp:comment_author_email></wp:comment_author_email>
			<wp:comment_author_url>http://kynosarges.wordpress.com/2012/09/08/steering-cockroaches-c/</wp:comment_author_url>
			<wp:comment_author_IP>72.232.113.15</wp:comment_author_IP>
			<wp:comment_date>2012-09-08 01:32:05</wp:comment_date>
			<wp:comment_date_gmt>2012-09-08 08:32:05</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[[...] Wilson reports on an empirical study by Pankratius, Schmidt &amp; Garretón on the relative productivity of Java and Scala. [...]]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type>pingback</wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1347093126.1053";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>1673</wp:comment_id>
			<wp:comment_author><![CDATA[Tommy McGuire]]></wp:comment_author>
			<wp:comment_author_email>mcguire@crsr.net</wp:comment_author_email>
			<wp:comment_author_url>http://maniagnosis.crsr.net</wp:comment_author_url>
			<wp:comment_author_IP>128.158.1.172</wp:comment_author_IP>
			<wp:comment_date>2012-08-28 09:44:11</wp:comment_date>
			<wp:comment_date_gmt>2012-08-28 16:44:11</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Since the cached version seems to be MIA, you can find a preprint of the paper on Victor Pankratius' site: http://www.rz.uni-karlsruhe.de/~kb95/papers/pankratius-Scala-ICSE12-preprint.pdf]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1346172251.7871";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>1674</wp:comment_id>
			<wp:comment_author><![CDATA[JC]]></wp:comment_author>
			<wp:comment_author_email>jc1976@m.codng.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>200.89.155.146</wp:comment_author_IP>
			<wp:comment_date>2012-08-28 15:03:45</wp:comment_date>
			<wp:comment_date_gmt>2012-08-28 22:03:45</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[I think they're measuring the wrong thing. Productivity is a short-term problem that's usually a non-issue, what you should measure is maintainability over several years, which is what's most difficult about software development, and what ends up affecting *actual* productivity the most.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1346191425.7203";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>1678</wp:comment_id>
			<wp:comment_author><![CDATA[Tommy McGuire]]></wp:comment_author>
			<wp:comment_author_email>mcguire@crsr.net</wp:comment_author_email>
			<wp:comment_author_url>http://mainagnosis.crsr.net</wp:comment_author_url>
			<wp:comment_author_IP>128.158.1.172</wp:comment_author_IP>
			<wp:comment_date>2012-08-29 09:59:59</wp:comment_date>
			<wp:comment_date_gmt>2012-08-29 16:59:59</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Actually, that's what struck me about the study: productivity seems to me to be one of the biggest differences with experience in a programming language.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>1674</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1346259599.2666";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>1672</wp:comment_id>
			<wp:comment_author><![CDATA[Sam Wilshire]]></wp:comment_author>
			<wp:comment_author_email>bbuchsba@yahoo.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>63.243.143.228</wp:comment_author_IP>
			<wp:comment_date>2012-08-28 07:21:03</wp:comment_date>
			<wp:comment_date_gmt>2012-08-28 14:21:03</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[A hypothetical study.

"We randomly assigned 26 students with four years of training in French and gave them four weeks of training in Esperanto and additional four weeks of training in French. The students were then wrote essays in French and Esperanto, depending on the the group they were randomly assigned to. The French essays had fewer grammatical errors, better use of vocabulary, and were longer than the Esperanto essays. This shows that French is a better language than Esperanto"]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1346163663.6802";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>1576</wp:comment_id>
			<wp:comment_author><![CDATA[trying to find plumbers company]]></wp:comment_author>
			<wp:comment_author_email>nan.ramon@web.de</wp:comment_author_email>
			<wp:comment_author_url>http://cresselia2121.snappages.com</wp:comment_author_url>
			<wp:comment_author_IP>184.73.41.245</wp:comment_author_IP>
			<wp:comment_date>2012-07-23 13:06:56</wp:comment_date>
			<wp:comment_date_gmt>2012-07-23 20:06:56</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[It is not my first time to visit this site, i am browsing this site dailly and 
take nice information from here all the time.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1343074016.9807";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>1720</wp:comment_id>
			<wp:comment_author><![CDATA[Hani Suleiman]]></wp:comment_author>
			<wp:comment_author_email>hani@formicary.net</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>50.74.33.178</wp:comment_author_IP>
			<wp:comment_date>2012-09-06 10:43:51</wp:comment_date>
			<wp:comment_date_gmt>2012-09-06 17:43:51</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[What struck me the most about the study is how many scala apologists there are.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1346953432.0703";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
		<title>Programmer Information Needs After Memory Failure</title>
		<link>http://www.neverworkintheory.org/?p=383</link>
		<pubDate>Wed, 04 Jul 2012 17:00:35 +0000</pubDate>
		<dc:creator>LeifSinger</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=383</guid>
		<description></description>
		<content:encoded><![CDATA[<em><a href="http://www.cc.gatech.edu/~vector/">Chris Parnin</a>, <a href="http://www.cc.gatech.edu/~spencer/">Spencer Rugaber</a>.</em> <strong>"<a href="http://www.cc.gatech.edu/~vector/papers/memoryfailures.pdf">Programmer Information Needs After Memory Failure</a>".</strong> ICPC 2012.
<blockquote>Despite its vast capacity and associative powers, the human brain does not deal well with interruptions. Particularly in situations where information density is high, such as during a programming task, recovering from an interruption requires extensive time and effort. Although modern program development environments have begun to recognize this problem, none of these tools take into account the brain's structure and limitations. In this paper, we present a conceptual framework for understanding human memory organization and its strengths and weaknesses, particularly with respect to dealing with work interruptions. The framework explains empirical results obtained from experiments in which programmers were interrupted. The intent is to use the framework to design development tools capable of compensating for human memory limitations. We also delineate programmer information needs such tools must satisfy and suggest several memory aids such tools could provide.</blockquote>
Parnin and Rugaber discuss several cognitive challenges that probably every developer has faced at some point: tracking many code locations at once while doing a big refactoring, or trying to remind ourselves to continue work on a certain problem when an external event has occurred. For these challenges, they give examples for coping strategies that, again, probably every programmer has used one time or the other. We send reminder e-mails to ourselves, add <code>// TODO</code> comments that we forget about later, or deliberately create compiler errors as an anchor into our current task.

The authors analyze and classify these challenges and coping strategies using existing research from neuroscience. The result is a theoretical framework that is mostly interesting to researchers and a few practitioners who wish to create better developer tools. Wearing my researcher hat, I cannot help but to instantly try thinking of neat ways to leverage this framework as a designing aid for developer support mechanisms.

However, when I put on my developer hat, I realize that it's even more than that. Parnin's and Rugaber's framework helps me reflect upon my own programming habits and provides some explanations for their existence. For example, why is it that so many <code>TODO</code>s remain in code for so long, never to be <code>DONE</code>? They are passive reminders that are never triggered!

Even without the tool support that Parnin and Rugaber are creating, their paper provides an interesting look at ourselves as developers, our habits, our weaknesses, and our coping strategies. In doing so, it raises our awareness for these issues and inspires us to slight modifications of our work practices that are better tailored to our human brains. The next time I write a <code>TODO</code>, I'll make sure to create an automatic reminder as well.]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>383</wp:post_id>
		<wp:post_date>2012-07-04 10:00:35</wp:post_date>
		<wp:post_date_gmt>2012-07-04 17:00:35</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>programmer-information-needs-after-memory-failure</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="refactoring"><![CDATA[Refactoring]]></category>
		<category domain="category" nicename="tools"><![CDATA[Tools]]></category>
		<category domain="category" nicename="usability"><![CDATA[Usability]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[18]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>1467</wp:comment_id>
			<wp:comment_author><![CDATA[sivaram]]></wp:comment_author>
			<wp:comment_author_email>sivaram.psg@gmail.com</wp:comment_author_email>
			<wp:comment_author_url>http://myworldasisee.wordpress.com</wp:comment_author_url>
			<wp:comment_author_IP>158.234.251.71</wp:comment_author_IP>
			<wp:comment_date>2012-07-04 23:38:27</wp:comment_date>
			<wp:comment_date_gmt>2012-07-05 06:38:27</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[I regularly follow your blog posts and thanks for sharing the information.Anyways I dont like the blog design.Can you change to something that is easy to read?.Thanks]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1341470308.0354";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>1504</wp:comment_id>
			<wp:comment_author><![CDATA[Kevin Moore]]></wp:comment_author>
			<wp:comment_author_email>nwtheory@kevin.moore.name</wp:comment_author_email>
			<wp:comment_author_url>http://kevin.moore.name</wp:comment_author_url>
			<wp:comment_author_IP>86.6.205.177</wp:comment_author_IP>
			<wp:comment_date>2012-07-11 12:59:43</wp:comment_date>
			<wp:comment_date_gmt>2012-07-11 19:59:43</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Next time a manager doesn't get why a 5 minute interruption can cost me a good half-hour or why a "quick meeting" is so unwelcome, I'll give them a copy of this paper.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1342036783.7203";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>2031</wp:comment_id>
			<wp:comment_author><![CDATA[Nicholas Perry]]></wp:comment_author>
			<wp:comment_author_email>ape.inago@gmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>199.21.137.81</wp:comment_author_IP>
			<wp:comment_date>2012-11-05 06:32:22</wp:comment_date>
			<wp:comment_date_gmt>2012-11-05 14:32:22</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[I would suggest getting the blog via an RSS reader, which you can then customize to your liking.  I've had good luck with google reader: http://www.google.com/reader/]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>1467</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1352125942.6577";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>2030</wp:comment_id>
			<wp:comment_author><![CDATA[Nicholas Perry]]></wp:comment_author>
			<wp:comment_author_email>ape.inago@gmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>199.21.137.81</wp:comment_author_IP>
			<wp:comment_date>2012-11-05 06:31:04</wp:comment_date>
			<wp:comment_date_gmt>2012-11-05 14:31:04</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Habits are a powerful tool to trigger yourself. If you get in the habit of checking a trusted system for your next todo, you will always be triggered.

I might suggest further research on tricks to help you form a habit. I'm sure there are tons of them that would help alleviate certain brain-failures from programming.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1352125865.4223";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
		<title>Anthony Finkelstein&#039;s &quot;SoftEng&quot; blog</title>
		<link>http://www.neverworkintheory.org/?p=396</link>
		<pubDate>Wed, 11 Jul 2012 16:00:23 +0000</pubDate>
		<dc:creator>jorge</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=396</guid>
		<description></description>
		<content:encoded><![CDATA[<a title="Anthony Finkelstein's blog" href="http://blog.prof.so/">Anthony Finkelstein</a>, the <a title="Finkelstein's academic page" href="http://www0.cs.ucl.ac.uk/staff/A.Finkelstein/">Dean of the Faculty of Engineering Sciences of University College London</a> (and my academic grandfather), has set up <a title="The SoftEng blog" href="http://blog.softeng.info/">a new blog</a> with a similar purpose as ours: he publishes "snappy summaries" of software engineering research with the aim of supporting practitioners. Be sure to check it out! And if you're doing research, I'd suggest you also read his lists of the<a href="http://blog.prof.so/2012/05/top-10-software-engineering-challenges.html"> Top Ten</a> and <a href="http://blog.prof.so/2012/06/bottom-10-software-engineering.html">Bottom Ten Software Engineering Challenges</a>.]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>396</wp:post_id>
		<wp:post_date>2012-07-11 09:00:23</wp:post_date>
		<wp:post_date_gmt>2012-07-11 16:00:23</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>anthony-finkelsteins-softeng-blog</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="announcements"><![CDATA[Announcements]]></category>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Clustering duplicate crash reports</title>
		<link>http://www.neverworkintheory.org/?p=400</link>
		<pubDate>Wed, 18 Jul 2012 16:00:50 +0000</pubDate>
		<dc:creator>jorge</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=400</guid>
		<description></description>
		<content:encoded><![CDATA[<em><a href="http://research.microsoft.com/en-us/people/yidang/">Yingnong Dang</a>, Rongxin Wu, <a href="https://sites.google.com/site/hongyujohn/">Hongyu Zhang</a>, Dongmei Zhang, and Peter Nobel. <strong><a href="http://research.microsoft.com/en-us/groups/sa/rebucket-icse2012.pdf">"ReBucket: A Method for Clustering Duplicate Crash Reports Based on Call Stack Similarity"</a>.</strong> ICSE 2012.</em>
<blockquote><em>Software often crashes. Once a crash happens, a crash report could be sent to software developers for investigation upon user permission. To facilitate efficient handling of crashes, crash reports received by Microsoft’s Windows Error Reporting (WER) system are organized into a set of “buckets”. Each bucket contains duplicate crash reports that are deemed as manifestations of the same bug. The bucket information is important for prioritizing efforts to resolve crashing bugs. To improve the accuracy of bucketing, we propose ReBucket, a method for clustering crash reports based on call stack matching. ReBucket measures the similarities of call stacks in crash reports and then assigns the reports to appropriate buckets based on the similarity values. We evaluate ReBucket using crash data collected from five widely-used Microsoft products. The results show that ReBucket achieves better overall performance than the existing methods. On average, the F-measure obtained by ReBucket is about 0.88.</em></blockquote>
For successful software products, one nasty consequence of a massive user base is the similarly massive amount of crash reports that they produce. Somebody (or some tool) needs to sift through all of them and categorize them to figure out if there's anything that's new and worthy of investigation, as well as which bugs are in most urgent need of attention. Dang &amp; Co developed a method to cluster these crash reports (the paper describes it in some detail), and it seems to have pretty good results so far---and although it has been tried only on Microsoft data, the authors are planning to move onto other projects as well.]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>400</wp:post_id>
		<wp:post_date>2012-07-18 09:00:50</wp:post_date>
		<wp:post_date_gmt>2012-07-18 16:00:50</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>clustering-duplicate-crash-reports</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="metrics"><![CDATA[Metrics]]></category>
		<category domain="category" nicename="quality"><![CDATA[Quality]]></category>
		<category domain="category" nicename="quantitative-studies"><![CDATA[Quantitative Studies]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Ten Questions for Researchers</title>
		<link>http://www.neverworkintheory.org/?p=407</link>
		<pubDate>Wed, 22 Aug 2012 16:58:56 +0000</pubDate>
		<dc:creator>gvwilson</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=407</guid>
		<description></description>
		<content:encoded><![CDATA[I gave the opening talk at <a href="http://msrcanada.org/msrvision2020/">MSR Vision 2020</a> in Kingston on Monday (<a href="http://www.slideshare.net/gvwilson/two-solitudes">slides</a>), and in the wake of that, an experienced developers at Mozilla sent me a list of ten questions he'd really like empirical software engineering researchers to answer.  They're interesting in their own right, but I think they also reveal a lot about what practitioners want from researchers in general; comments would be very welcome.
<ol>
	<li>Vi vs. Emacs vs. graphica editors/IDEs: which makes me more productive?</li>
	<li>Should language developers spend their time on tools, syntax, library, or something else (like speed)? What makes the most difference to their users?</li>
	<li>Do unit tests save more time in debugging than they take to write/run/keep updated?</li>
	<li>Do distribution version control systems offer any advantages over centralized version control systems? (As a sub-question, Git or Mercurial: which helps me make fewer mistakes/shows me the info I need faster?)</li>
	<li>What are the best debugging techniques?</li>
	<li>Is it really twice as hard to debug as it is to write the code in the first place?</li>
	<li>What are the differences (bug count, code complexity, size, etc.), if any, between community-driven open source projects and corporate-controlled open source projects?</li>
	<li>If 10,000-line projects don't benefit from architecture, but 100,000-line projects do, what do you do when your project slowly grows from the first size to the second?</li>
	<li>When does it make sense to reinvent the wheel vs. use an existing library?</li>
	<li>Are conferences worth the money? How much do they help junior/intermediate/senior programmers?</li>
</ol>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>407</wp:post_id>
		<wp:post_date>2012-08-22 09:58:56</wp:post_date>
		<wp:post_date_gmt>2012-08-22 16:58:56</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>ten-questions-for-empirical-researchers</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="general"><![CDATA[General]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>1726</wp:comment_id>
			<wp:comment_author><![CDATA[Ryan Eccles]]></wp:comment_author>
			<wp:comment_author_email>ryan.eccles@gmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>67.183.85.185</wp:comment_author_IP>
			<wp:comment_date>2012-09-08 09:56:50</wp:comment_date>
			<wp:comment_date_gmt>2012-09-08 16:56:50</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[I have just started a new job recently, so many of these questions are fresh in my mind:

What is the best method of training new employee's about an existing codebase? Should they jump in and fix bugs? Should they have architecture lessons? Should they just be allowed to look a the code and meander at their own pace? If it's a combination of things how should they be structured? Would pair programming help here? 

For project planning, how long can I expect a new employee to be come proficient? How many bugs can I expect from a new employee using various on boarding techniques? How does individual differences play into the on boarding process? What is the effect on my entire team's productivity?

I would love empirical evidence on these questions.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1347123410.5626";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>1668</wp:comment_id>
			<wp:comment_author><![CDATA[Reg]]></wp:comment_author>
			<wp:comment_author_email>pulaskite@yahoo.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>173.218.207.187</wp:comment_author_IP>
			<wp:comment_date>2012-08-27 06:39:54</wp:comment_date>
			<wp:comment_date_gmt>2012-08-27 13:39:54</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[I'd like to offer this technique in response to #5.  It's specifically oriented to scientific routines dominated by mathematical operations.  Not sure it's "best", but I've found it helpful.

On entry to a function, test for an environment variable which matches the name of the function.  If the environment variable is set, use the string supplied as the file name, open the file and write all the input arguments to disk.

In a conditionally compiled main() in the source file, read the format written by the function on entry and then call the function and write out the arguments returned by the function.

This allows me to collect data from a bug by having the user set the environment variable, repeat the task, give me the file and unset the environment variable.  I can then run the suspect routine under the debugger w/o being burdened by all the  overhead of running the program.  In systems where  a lot of metadata must be supplied before calling a procedure this is a large improvement in efficiency.  It also removes any doubt about the data supplied to the function while debugging being correct.  In complex program UIs it is all too easy to fail to exactly match the options selected by the user.

This also doubles as a unit test and a mechanism for developing a regression test suite that targets problems actually encountered rather than someone's guess of what to test.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1346074794.9364";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>1764</wp:comment_id>
			<wp:comment_author><![CDATA[Sheila]]></wp:comment_author>
			<wp:comment_author_email>shekay@pobox.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>98.212.43.148</wp:comment_author_IP>
			<wp:comment_date>2012-09-18 06:58:44</wp:comment_date>
			<wp:comment_date_gmt>2012-09-18 13:58:44</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[What is the value of writing easily maintainable code versus getting something out there as soon as possible in order to make money? Am I just being dogmatic in thinking clean code is valuable?]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:14:"1347976724.312";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>1656</wp:comment_id>
			<wp:comment_author><![CDATA[Lorin Hochstein]]></wp:comment_author>
			<wp:comment_author_email>lorinh@gmail.com</wp:comment_author_email>
			<wp:comment_author_url>http://lorinhochstein.org</wp:comment_author_url>
			<wp:comment_author_IP>71.191.167.202</wp:comment_author_IP>
			<wp:comment_date>2012-08-23 19:38:39</wp:comment_date>
			<wp:comment_date_gmt>2012-08-24 02:38:39</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Dare we compare (with the perspective of an SE researcher)? http://blog.prof.so/2012/05/top-10-software-engineering-challenges.html]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1345775919.1525";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>1762</wp:comment_id>
			<wp:comment_author><![CDATA[Sheila]]></wp:comment_author>
			<wp:comment_author_email>shekay@pobox.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>98.212.43.148</wp:comment_author_IP>
			<wp:comment_date>2012-09-18 06:48:20</wp:comment_date>
			<wp:comment_date_gmt>2012-09-18 13:48:20</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[A meeting at work yesterday has me coming back to this blog post to ask this and related questions. How valuable is the documentation we create? Should we spend more or less time on it? What is the best type of documentation? diagrams, text, inline comments, traceability matrices?]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>1726</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:14:"1347976100.608";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>1763</wp:comment_id>
			<wp:comment_author><![CDATA[Sheila]]></wp:comment_author>
			<wp:comment_author_email>shekay@pobox.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>98.212.43.148</wp:comment_author_IP>
			<wp:comment_date>2012-09-18 06:55:09</wp:comment_date>
			<wp:comment_date_gmt>2012-09-18 13:55:09</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[When, if ever, is it time to rewrite a system? I've heard it's one of the classic mistakes, but I remain skeptical.

When is it better to reroute around bad code in the hopes of strangling it out versus refactoring?

When is it better to reroute around bad code when adding new features versus refactoring and adding new features in order to promote reuse?

How often do researchers approach companies with large code bases to study these things in the real world? We have consultants who come in to get paid for purportedly improving processes. I'd rather see academics come in who will publish and share results.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1347976509.3356";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>1695</wp:comment_id>
			<wp:comment_author><![CDATA[Blake Winton]]></wp:comment_author>
			<wp:comment_author_email>bwinton@latte.ca</wp:comment_author_email>
			<wp:comment_author_url>http://weblog.latte.ca/blake/</wp:comment_author_url>
			<wp:comment_author_IP>75.119.238.9</wp:comment_author_IP>
			<wp:comment_date>2012-09-01 12:43:48</wp:comment_date>
			<wp:comment_date_gmt>2012-09-01 19:43:48</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Reg: Your comment seems to be missing the point.  I have my list of debugging techniques which I think help me, but neither of us have any data (by which I don't mean anecdotes!) as to whether those things actually help or not, much less whether they help enough to offset the amount of time it takes to implement them.  :)]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>1668</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1346528628.8885";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>1696</wp:comment_id>
			<wp:comment_author><![CDATA[Reg]]></wp:comment_author>
			<wp:comment_author_email>pulaskite@yahoo.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>173.218.207.187</wp:comment_author_IP>
			<wp:comment_date>2012-09-01 15:17:58</wp:comment_date>
			<wp:comment_date_gmt>2012-09-01 22:17:58</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[I did not make an assertion that what I suggested was best.  It's something I developed for my own convenience which I have never seen presented or used.  I only mentioned it for that reason.

Most of the effort (i.e cost) in debugging is in isolating the fault. One of the hardest things to get is an accurate bug report from a naive user.  What I described accomplishes both with little effort.  You cannot fix a bug until you have isolated an example of input that causes it and the routine in which it appears.

"Best" is a nonsensical metric.  One can determine by measurement that A is "better" than B or C.  But even that requires defining criteria for "better".  I like shortest mean time to isolate the error, but others may have different criteria.  Finding the "best" is unbounded and easily altered by a change of criteria.

As for the value of unit tests and keeping them up to date.  I fielded a large technical application suite which in the first year had fewer than a dozen user submitted bug reports.  The number went down from there over time.  That package was in use for 18+ years before it was retired.  For probably half that time the package received no active support.  It simply worked.  That package was also instrumented to report a wide variety of usage information, so bug reports could be measured against program usage (very helpful when being pestered for an enhancement to a program only one person uses twice a year). All was possible because we implemented a modest suite of unit tests which were run and verified any time we compiled the package or a part of it.  Any time a bug was found, an example that triggered the bug was added to the test suite to ensure that it stayed fixed.

I wrote a 15,000+ line library for that package that had NO failures in over 8 years of deployment.  It was a moderately complex mix of lex, yacc &amp; C and I took considerable care over the unit tests to make certain that they were comprehensive. The one failure I know of was when SunOS started incorrectly setting errno after a successful call to getcwd().  I'd been gone for 5 years when that came up, but the friend who fixed it, told me about it over lunch one day.

I am a big fan of empirical measurements.  Unfortunately, confidentiality restrictions (I've been exclusively contract for 20 years) and mergers have made the ones I've made vanish.  I suspect that's true for others as well.  There are probably quite a few measurements that live now only in anecdotal form.  Les Hatton presented empirical data based on mean time to repair on the maintainability of C vs C++ which upset quite a few.  But it was hard data.  Not anecdote.  And because it was a pair of C &amp; C++ static analysis programs, the maintainers were of necessity quite expert with the languages.

I primarily do scientific programming.  Science doesn't typically change.  New techniques are implemented, but bugs tend to be edge conditions and numerical instabilities that went unnoticed in the original coding.  So the code tends to have much longer life than UI code where fashion has sway.  That makes good unit tests and the technique I outlined more cost effective for scientific codes.

In the context of UI programming I rather doubt that what I suggested would be of any use at all.  Not every tool is a hammer; just as not every fastener is a nail.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1346537878.6283";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>1649</wp:comment_id>
			<wp:comment_author><![CDATA[Phil Miller]]></wp:comment_author>
			<wp:comment_author_email>mille121@illinois.edu</wp:comment_author_email>
			<wp:comment_author_url>http://charm.cs.illinois.edu</wp:comment_author_url>
			<wp:comment_author_IP>24.12.229.145</wp:comment_author_IP>
			<wp:comment_date>2012-08-22 18:14:27</wp:comment_date>
			<wp:comment_date_gmt>2012-08-23 01:14:27</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[For #4, I recently read a paper that addresses exactly that, and the answer is pretty much yes. The big advantage is not the distributed-ness itself, but rather that Git and Mercurial have competent support for merging branches, where the centralized tools largely did not and still do not.

The paper was named something like "coherent and isolated development on branches", but I can't seem to find it using those keywords. Someone else might be able to, though.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1345684467.6742";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>1650</wp:comment_id>
			<wp:comment_author><![CDATA[Phil Miller]]></wp:comment_author>
			<wp:comment_author_email>mille121@illinois.edu</wp:comment_author_email>
			<wp:comment_author_url>http://charm.cs.illinois.edu</wp:comment_author_url>
			<wp:comment_author_IP>24.12.229.145</wp:comment_author_IP>
			<wp:comment_date>2012-08-22 20:45:01</wp:comment_date>
			<wp:comment_date_gmt>2012-08-23 03:45:01</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[http://research.microsoft.com/apps/pubs/default.aspx?id=157290
"Cohesive and Isolated Development with Branches". Earl T. Barr, Christian Bird, Peter C. Rigby, Abram Hindle, Daniel M. German, and Premkumar Devanbu. April 2012. Proceedings of the International Conference on Fundamental Approaches to Software Engineering. Springer.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>1649</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1345693502.0546";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>1652</wp:comment_id>
			<wp:comment_author><![CDATA[Graham]]></wp:comment_author>
			<wp:comment_author_email>graham@iamleeg.com</wp:comment_author_email>
			<wp:comment_author_url>http://blog.securemacprogramming.com</wp:comment_author_url>
			<wp:comment_author_IP>188.222.85.63</wp:comment_author_IP>
			<wp:comment_date>2012-08-23 01:08:21</wp:comment_date>
			<wp:comment_date_gmt>2012-08-23 08:08:21</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Questions 1-5 strike me as being particular facets of a bigger question: "does any usability research go into developer tools? Are newer tools necessarily making me better?" I would _love_ to see that research. It seems like developers love to tout UX for consumer-facing products but forget it for their own tools: is that actually true?

I know that NetBeans used to conduct (and occasionally publish) UX research into their IDE. I've also seen a couple of papers on CodeBubbles (http://portal.acm.org/citation.cfm?id=1806799.1806866&amp;coll=DL&amp;dl=GUIDE&amp;CFID=102598996&amp;CFTOKEN=76714809, http://portal.acm.org/citation.cfm?id=2337223.2337432&amp;coll=DL&amp;dl=GUIDE&amp;CFID=102598996&amp;CFTOKEN=76714809) though none that contains what I'd call "science", i.e. a hypothesis "this IDE is no [X]er at [Y] than this other IDE" with a significant rejection.

As a programmer I'm someone who could, time and inclination permitting, contribute toward a better programming environment. But until someone gives me more than an opinion or flamewar describing what that better environment is, there's no way to know whether I'm doing so.

All of the other questions are also interesting with the exception of 8, which holds two axioms I don't automatically accept. Regarding 7, there's a problem with measurement of "bug count" that also comes up a lot in the security field relating to vulnerabilities. What are you counting? Probably _reported_ bugs. Can I map that trivially onto _existing_ bugs or even _detected_ bugs? What if a project had loads of bugs reported, but they were all fixed. Is that a buggy project or a not buggy project?

I've realised that I might just be blathering when I say that question 9 leads me into deeper thoughts too :-). Let me spin it another way. There are plenty of libraries that exist despite prior existence of libraries that provide equivalent functionality at (question 7 aside) similar levels of quality. Some of these were written because the programmer wanted to have a go at writing it.

Leave those aside, focus on these: the ones that were built because the earlier versions weren't compatible with the programmer's runtime environment, compiler (and language), or favourite paradigm. Were they a good idea? Did they benefit the programmer, the "community", the industry at large? Would it have been a better use of effort to increase reusability of existing code: e.g. bringing easier bindings between C++ and Java, or a compiler to let LISP run in the Parrot VM; or was it better to just build a new HTTP client library in the other environment?

[to give some context, I consider myself a primary literature-savvy practitioner. I worked in academia until 2006 when I became a commercial-sector software engineer.]]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1345709301.5237";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1345720216.8731";s:7:"message";s:47:"gvwilson changed the comment status to approved";s:5:"event";s:15:"status-approved";s:4:"user";s:8:"gvwilson";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
		<title>Using topic modelling to understand requirements</title>
		<link>http://www.neverworkintheory.org/?p=412</link>
		<pubDate>Thu, 23 Aug 2012 23:05:10 +0000</pubDate>
		<dc:creator>neil</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=412</guid>
		<description></description>
		<content:encoded><![CDATA[<p><a href="http://softwareprocess.es">Abram Hindle</a> and <a href="http://thomas-zimmermann.com">Thomas Zimmerman</a>, "<a href="http://softwareprocess.es/a/hindle-abram-relating-requirements-WEB-EDITION.pdf">Do Topics Extracted from Requirements Make Sense to Managers and Developers?</a>", <em>International Conference on Software Maintenance</em>, 2012.</p>

<p>Disclosure: Abram and I have collaborated on a somewhat related paper</em>.

<blockquote>
  Large organizations like Microsoft tend to rely on formal requirements documentation in order to specify and design the software products that they develop. These documents are meant to be tightly coupled with the actual implementation of the features they describe. In this paper we evaluate the value of high-level topic-based requirements traceability in the version control system, using Latent Dirichlet Allocation (LDA). We evaluate LDA topics on practitioners and check if the topics and trends extracted matches the perception that Program Managers and Developers have about the effort put into addressing certain topics. We found that effort extracted from version control that was relevant to a topic often matched the perception of the managers and developers of what occurred at the time. Furthermore we found evidence that many of the identified topics made sense to practitioners and matched their perception of what occurred. But for some topics, we found that practitioners had difficulty interpreting and labelling them. In summary, we investigate the high-level traceability of requirements topics to version control commits via topic analysis and validate with the actual stakeholders the relevance of these topics extracted from requirements.
</blockquote>

<p>A holy grail of software research is to (automatically) relate the business value of the software feature to the code implementing that feature, known as <a href="http://en.wikipedia.org/wiki/Requirements_traceability"><em>requirements traceability</em></a>. All sorts of benefits are posited to result from this, including the ability to tell whether your customer's needs are met. </p>

<p>One approach to this is to use an information retrieval technique called <a href="http://en.wikipedia.org/wiki/Topic_model">topic modelling</a>. Topic modelling generates word distributions for a set of documents, like requirements specifications. One of the problems with topic modelling is that the topics are presented as lists of seemingly unrelated words, and the content of these topics must be captured with a descriptive label. In this paper the authors assess whether developers at Microsoft find the topics easy to label and understand.</p>

<p>What they discovered was that the study participants agreed with the proposed linkages between requirements topics and commits, but that the topics were difficult to label without being customized to the individual developer. Program managers seemed to find the topics more comprehensible, possibly because they deal with a wider array of features in their work. Further use of topic modelling in this area seems to require labelling by domain experts before being widely applicable to the traceability problem. </p>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>412</wp:post_id>
		<wp:post_date>2012-08-23 16:05:10</wp:post_date>
		<wp:post_date_gmt>2012-08-23 23:05:10</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>using-topic-modelling-to-understand-requirements</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="organizational-studies"><![CDATA[Organizational Studies]]></category>
		<category domain="category" nicename="quantitative-studies"><![CDATA[Quantitative Studies]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[3]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Shaping the Next Generation (or, the exam defines the course defines the discipline)</title>
		<link>http://www.neverworkintheory.org/?p=422</link>
		<pubDate>Sat, 01 Sep 2012 19:32:27 +0000</pubDate>
		<dc:creator>gvwilson</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=422</guid>
		<description></description>
		<content:encoded><![CDATA[As we <a href="/?p=407">reported</a> a few days ago, one of our contributors, <a href="http://www.third-bit.com">Greg Wilson</a>, gave a keynote at the <a href="http://msrcanada.org/msrvision2020/">MSR Vision 2020</a> workshop in Kingston on August 20. In that, he explored why there's still a gulf between software engineering researchers and the people who actually build software for a living (see the <a href="http://www.slideshare.net/gvwilson/two-solitudes">slides</a> or the <a href="http://www.reddit.com/r/programming/comments/yw9ra/greg_wilsons_brilliant_slides_about_the/">discussion on Reddit</a> for details). He also said that:
<ol>
	<li>there's no easy way to close that gap, because most of the people in industry that researchers want to collaborate with have never encountered empirical software engineering studies, and therefore don't understand their scope or value; so</li>
	<li>researchers—many of whom are professors—should pivot the software engineering classes they teach to focus on how to analyze real-world data, and what past analyses have told us, so that the next generation of developers <em>will</em> understand (and listen, and want to collaborate).</li>
</ol>
To make this more concrete, Greg asked the workshop participants to make up some assignments and exam questions for such a course. Some of the suggestions are listed below; we would welcome other ideas as well (please post them as comments). We'd also like to know who'd be interested in trying to teach such a course at their institution, and what you think the prerequisites would have to be: statistics, obviously, but would a database course that introduced students to SQL be necessary? What about a natural language processing course? Or something else we haven't thought of?

<strong>Group 1</strong>

<dl><dt>Give two examples of success stories in studies of the social aspects of software engineering.</dt><dd>
<ol>
	<li>Reorganization based on social structures</li>
	<li>Identifying the "big players" in a software project</li>
</ol>
</dd><dt>What are three sources of social interaction in software projects?</dt><dd>
<ol>
	<li>Email</li>
	<li>IRC</li>
	<li>bug comments</li>
	<li>source code comments</li>
</ol>
</dd><dt>Name three challenges in preprocessing emails.</dt><dd>
<ol>
	<li>signatures</li>
	<li>code snippets</li>
	<li>stack traces</li>
	<li>fake/multiple email addresses</li>
	<li>identifying email headers and inline replies</li>
	<li>typos</li>
	<li>chat acronyms</li>
	<li>non-native speakers</li>
	<li>use of multiple languages</li>
</ol>
</dd></dl><strong>Group 2</strong>
<ol>
	<li>You are given a dataset A of OSS projects and a subset of it B. Evaluate whether a hypothesis H can be rejected on A and B. Design the question in such a way that H is significant (at 0.05 level) at A and not B. Discuss the discrepancy.</li>
	<li>Given a dataset and a specific question, perhaps from exisitng MSR papers, discuss which data mining approach is best suited for that question.</li>
	<li>Given a specific question (e.g., bug finding) what repositories should you use to solve it? Illustrate it with Bugzilla. How do you adapt this to Jira?</li>
	<li>Given that two variables A and B correlate, can you say "A causes B"? Why or why not?</li>
	<li>Repeat an existing analysis from an MSR paper. Do you get the same results? Vary a number of variables. How different are the results?</li>
</ol>
<strong>Group 3</strong>
<ul>
	<li><strong>Statistics</strong>
<ol>
	<li>What is wrong with this claim: "Files with a large number of committers/authors have more defects/bugs, so we conclude that more authors cause more bugs, and we recommended that the number of commiters be reduced."</li>
	<li>A tool is 99% accurate in detecting defective lines of code. Should developers use the tool? Why or why not?</li>
	<li>What are the internal validity issues and external validity issues with this method? "Researcher X finds that a lack of modularity leads to more defects in Windows, and Y is going to apply that predict defects in Eclipse."</li>
	<li>Design a study to see whether people who go to lunch together have fewer build defects in their software.</li>
	<li>Which would product fewer false positives: 90% recall and 10% precision, or 10% precision and 90% recall?</li>
</ol>
</li>
	<li><strong>Data</strong>
<ol>
	<li>Given a table of bug reports with severity, etc. and another table of users with qualifications, etc., determine whether experience and bug report frequency are correlated, and if so, how strongly.</li>
	<li>Define: evolutionary coupling, tokenizing, word nets, stemming, n-gram, entropy.</li>
	<li>List 10 sources of data that could be mined to estimate the risks to a software projects, and describe the limitations of each.</li>
</ol>
</li>
	<li><strong>Interpretation and Actionability</strong>
<ol>
	<li>Your boss has asked you to generate documentation for a legacy system that doesn't have any. What approach(es) would you use to automatically generate some useful documentation for each class and method?</li>
	<li>Given a set of version control logs, how would you tell which commits were bug fixes (vs. adding new features)?</li>
	<li>What technique(s) would you use to correlate email messages from a mailing list archive with related version control commits?</li>
</ol>
</li>
	<li><strong>Ethics</strong>
<ol>
	<li>Given a data set (mailing list archive, bug reports, and version control log), anonymize it so that it can be shared without risk.</li>
	<li>Is it ethical to do an experiment to find out whether one race or gender produces more bugs than another? Justify your answer. How about graduates of one university vs. another?</li>
</ol>
</li>
</ul>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>422</wp:post_id>
		<wp:post_date>2012-09-01 12:32:27</wp:post_date>
		<wp:post_date_gmt>2012-09-01 19:32:27</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>shaping-the-next-generation-or-the-exam-defines-the-course</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="education"><![CDATA[Education]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>1784</wp:comment_id>
			<wp:comment_author><![CDATA[Leif Singer]]></wp:comment_author>
			<wp:comment_author_email>leif.singer@inf.uni-hannover.de</wp:comment_author_email>
			<wp:comment_author_url>http://leif.me</wp:comment_author_url>
			<wp:comment_author_IP>130.75.33.215</wp:comment_author_IP>
			<wp:comment_date>2012-09-27 02:40:06</wp:comment_date>
			<wp:comment_date_gmt>2012-09-27 09:40:06</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[The "Statistics One" course currently running on Coursera [https://www.coursera.org/course/stats1] seems interesting and relevant!]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>1724</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1348738807.1251";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>2005</wp:comment_id>
			<wp:comment_author><![CDATA[Jay Q Hacker]]></wp:comment_author>
			<wp:comment_author_email>nobody@nowhere.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>66.175.126.29</wp:comment_author_IP>
			<wp:comment_date>2012-11-02 09:56:52</wp:comment_date>
			<wp:comment_date_gmt>2012-11-02 16:56:52</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[I'm pretty sure both options from Group 3, Statistics #5 as stated would produce (predict?) the same number of false positives.  :)]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1351875412.6121";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>1724</wp:comment_id>
			<wp:comment_author><![CDATA[Kim Gräsman]]></wp:comment_author>
			<wp:comment_author_email>kim@mvps.org</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>85.224.68.22</wp:comment_author_IP>
			<wp:comment_date>2012-09-08 01:42:25</wp:comment_date>
			<wp:comment_date_gmt>2012-09-08 08:42:25</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[I've taken a recent interest in statistics to make sure I'm using relevant numbers when making claims based on my own measurements. The Group 3 questions strike me as very interesting, because they highlight problems with using data without understanding statistics. Since I don't feel like I do understand statistics enough to answer these questions, do you have a book recommendation for a complete novice to understand these issues better? I assume some of this is covered by correlation vs causation, so maybe it goes beyond statistics into scientific method?

Thanks,
- Kim]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1347093746.1012";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>1908</wp:comment_id>
			<wp:comment_author><![CDATA[Kim Gräsman]]></wp:comment_author>
			<wp:comment_author_email>kim@mvps.org</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>81.91.3.3</wp:comment_author_IP>
			<wp:comment_date>2012-10-03 22:33:22</wp:comment_date>
			<wp:comment_date_gmt>2012-10-04 05:33:22</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Thank you! I've been through some of Khan Academy's statistics material, and I like it, but I find it focuses too much on the mechanics.

I also read Downey's Think Stats, also a nice introduction, but I found it hard to transfer techniques and ideas to my own problems.

I guess I'm looking for a subject centered around using data responsibly -- very much like the Group 3 questions -- should that be covered by a good statistics course, or is it a different subject altogether?]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>1785</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1349328802.5264";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>1785</wp:comment_id>
			<wp:comment_author><![CDATA[Greg Wilson]]></wp:comment_author>
			<wp:comment_author_email>gvwilson@third-bit.com</wp:comment_author_email>
			<wp:comment_author_url>http://third-bit.com</wp:comment_author_url>
			<wp:comment_author_IP>209.226.201.228</wp:comment_author_IP>
			<wp:comment_date>2012-09-27 04:37:04</wp:comment_date>
			<wp:comment_date_gmt>2012-09-27 11:37:04</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Is it better than Udacity's stats course? http://www.angrymath.com/2012/09/udacity-statistics-101.html]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>1784</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:14:"1348745824.851";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>1717</wp:comment_id>
			<wp:comment_author><![CDATA[Graham]]></wp:comment_author>
			<wp:comment_author_email>graham@iamleeg.com</wp:comment_author_email>
			<wp:comment_author_url>http://blog.securemacprogramming.com</wp:comment_author_url>
			<wp:comment_author_IP>188.222.85.63</wp:comment_author_IP>
			<wp:comment_date>2012-09-06 00:57:03</wp:comment_date>
			<wp:comment_date_gmt>2012-09-06 07:57:03</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Another potential Group 1 question could be something like (I'm using lots of weasel words because I don't think I know what I'm talking about) "discuss an example of how [the internet, social networking] has caused a change in the ethnography of a group of people. Is it reasonable to extrapolate these conclusions to the rest of the internet-using population? What problems, if any, are there with such extrapolation?" On such a note, it'd be interesting to see a study into the changes of social interaction (if any) brought about by a software project changing from centralised to distributed version control, or the other way around.

I welcome the emphasis on statistics in the sample questions you provide, not just because it helps people understand how to interpret results from studies which is important in itself. It's also welcome because it's a skill that (anecdotally) is becoming more important in some applications but that seems underrepresented. I recently attended a presentation by a new group in a large company that was tasked with discovering opportunities for mining their "big data" and selling the results. Apparently data is the new "black gold". Anyway, I asked them which of the dozen or so employees on the team was their statistician. They didn't have one.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1346918224.1399";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
		<title>An experiment about static and dynamic type systems</title>
		<link>http://www.neverworkintheory.org/?p=432</link>
		<pubDate>Thu, 25 Oct 2012 20:51:14 +0000</pubDate>
		<dc:creator>ChristophTreude</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=432</guid>
		<description></description>
		<content:encoded><![CDATA[<a href="http://www.dawis.wiwi.uni-due.de/team/stefan-hanenberg/" target="_blank">Stefan Hanenberg</a>. "<strong><a href="http://www.cs.washington.edu/education/courses/cse590n/10au/hanenberg-oopsla2010.pdf" target="_blank">An experiment about static and dynamic type systems: doubts about the positive impact of static type systems on development time</a></strong>". <em>OOPSLA 2010.</em>
<blockquote>Although static type systems are an essential part in teaching and research in software engineering and computer science, there is hardly any knowledge about what the impact of static type systems on the development time or the resulting quality for a piece of software is. On the one hand there are authors that state that static type systems decrease an application's complexity and hence its development time (which means that the quality must be improved since developers have more time left in their projects). On the other hand there are authors that argue that static type systems increase development time (and hence decrease the code quality) since they restrict developers to express themselves in a desired way. This paper presents an empirical study with 49 subjects that studies the impact of a static type system for the development of a parser over 27 hours working time. In the experiments the existence of the static type system has neither a positive nor a negative impact on an application's development time (under the conditions of the experiment).</blockquote>
How many experiments in software engineering research are you aware of where the researcher developed a new programming language and corresponding IDE just for the experiment? Well, Stefan Hanenberg did exactly that, and the results are remarkable. The goal of his experiment was to measure the impact of static vs. dynamic type systems on development time and software quality. While there is a lot of conventional wisdom around the use of static or dynamic type systems (e.g., static type systems capture many recurring programming errors and make systems easier to maintain, dynamic type systems make life easier by not posing unnecessary restrictions), there is hardly any hard evidence to support these claims, and for a practitioner, it is unclear which arguments can be trusted.

Unlike what has been done in previous work, Hanenberg decided not to use existing programming languages and IDEs in his experiment because he worried that subjects’ familiarity with the tooling would influence the results, in particular if his subjects knew only the dynamic or only the static version used in the study. Therefore, he developed a new object-oriented programming language "Purity" (with some similarities to Smalltalk, Ruby and Java) and a corresponding IDE (class browser, test browser and console). Actually, he developed two versions of Purity: one with static types, the other one with a dynamic type system. The two versions were identical in all other aspects.

His experimental setup followed a between-subject design (i.e., each subject was only used once). He recruited 49 students, divided them into two groups, and taught each group one of the Purity versions (the dynamic type version was taught for 16 hours and the static type version was taught for 18 hours). All subjects were then given exactly 27 hours to implement a scanner and a parser for a given grammar. Hanenberg measured two outcomes: development time and quality. Development time was measured based on log entries and test cases in order to determine the exact point in time when subjects fulfilled all the test cases for a minimal scanner, and the quality of the parser was measured through 400 test cases that represented valid and invalids words in the grammar.

The main result from Hanenberg’s study is that -- under the conditions of his experiment -- the existence of a static type system did not have a positive impact on development time or quality. In fact, the subjects who used the dynamic type version of Purity were significantly faster in developing a scanner, but there was no statistically significant difference with respect to quality of the final product.

In addition to conducting and describing a well-planned and well-executed experiment, Hanenberg does a thorough job explaining and justifying his choice of methods, both for data collection and data analysis. But he also discusses the limitations of his work in great depth -- in particular that it is impossible to draw general conclusions from one experiment. However, what a single experiment such as Hanenberg’s can do is cast doubts on the role of static type systems in software engineering, and his work opens up lots of venues for future work on which programming languages work better than others, and why.]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>432</wp:post_id>
		<wp:post_date>2012-10-25 13:51:14</wp:post_date>
		<wp:post_date_gmt>2012-10-25 20:51:14</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>an-experiment-about-static-and-dynamic-type-systems</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="controlled-experiments"><![CDATA[Controlled Experiments]]></category>
		<category domain="category" nicename="programming-languages"><![CDATA[Programming Languages]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[27]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>1978</wp:comment_id>
			<wp:comment_author><![CDATA[Jorge Aranda]]></wp:comment_author>
			<wp:comment_author_email>jorge@neverworkintheory.org</wp:comment_author_email>
			<wp:comment_author_url>http://www.neverworkintheory.org/</wp:comment_author_url>
			<wp:comment_author_IP>184.71.9.82</wp:comment_author_IP>
			<wp:comment_date>2012-10-30 10:07:03</wp:comment_date>
			<wp:comment_date_gmt>2012-10-30 17:07:03</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Mike, a careful read of the paper will show that this blog post reflects its tone. The paper argues, strongly, that static type systems receive a lot of emphasis, and that "it is important to determine whether such an investment is reasonable". Within the narrow constraints it sets, it did not find evidence to support that investment. Christoph Treude's post reflects that line of presentation.

Here at NWIT we always encourage readers to take what they read with a very large grain of salt. Research in software development is quite imperfect---partly because it has needed to grow out of a non-empirical research tradition, and partly because it's just pretty hard to study the phenomena that are actually interesting. No single study is likely to settle a question like the one this paper addresses, but it does bring us closer.

And while we love controversy, we love civility just as much. Please remember there are people at the other end of the line.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>1975</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1351616823.7231";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:5:"jorge";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>1975</wp:comment_id>
			<wp:comment_author><![CDATA[Mike Marynowski]]></wp:comment_author>
			<wp:comment_author_email>mikem@singulink.com</wp:comment_author_email>
			<wp:comment_author_url>http://www.singulink.com</wp:comment_author_url>
			<wp:comment_author_IP>24.52.223.67</wp:comment_author_IP>
			<wp:comment_date>2012-10-30 06:21:40</wp:comment_date>
			<wp:comment_date_gmt>2012-10-30 13:21:40</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[If the blog cared about being all proper science-y instead of attracting flame bait, perhaps they would have summarized the study a little more scientifically :) Isn't it a little odd to expect people to post comments in in a "fair/neutral/balanced" science-oriented way when this blog post is an abomination to all of that?]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>1972</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1351603301.2787";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>2035</wp:comment_id>
			<wp:comment_author><![CDATA[gby]]></wp:comment_author>
			<wp:comment_author_email>no@no.no</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>83.27.51.79</wp:comment_author_IP>
			<wp:comment_date>2012-11-05 10:37:11</wp:comment_date>
			<wp:comment_date_gmt>2012-11-05 18:37:11</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Whenever I have a chance to jump back from dynamic JavaScript to static C# i fill like I'm in heaven. I hope sanity prevails and most people will not fall for this new dynamic typing fashion...]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1352140631.4568";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>1932</wp:comment_id>
			<wp:comment_author><![CDATA[Franklin Chen]]></wp:comment_author>
			<wp:comment_author_email>franklinchen@franklinchen.com</wp:comment_author_email>
			<wp:comment_author_url>http://franklinchen.com/</wp:comment_author_url>
			<wp:comment_author_IP>70.20.125.14</wp:comment_author_IP>
			<wp:comment_date>2012-10-25 16:49:39</wp:comment_date>
			<wp:comment_date_gmt>2012-10-25 23:49:39</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[I scanned the paper for the one thing I wanted to know about the study: what kind of "static type system" was being used for comparison?

"The static type system of the statically typed Purity is non-generic and nominal and can be compared to the type system of Java up to version 1.4 (without primitive types)."

I saw this sentence and immediately lost interest. What a straw man.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:14:"1351208979.129";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>2027</wp:comment_id>
			<wp:comment_author><![CDATA[Stefan Hanenberg]]></wp:comment_author>
			<wp:comment_author_email>stefan.hanenberg@icb.uni-due.de</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>132.252.61.55</wp:comment_author_IP>
			<wp:comment_date>2012-11-05 01:08:12</wp:comment_date>
			<wp:comment_date_gmt>2012-11-05 09:08:12</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[(*sorry for the long comment*)

As the author of the study, I much enjoyed the discussion here. And I really like the criticim of the study, because in fact this is what studies are about: giving the opportunity to criticize by giving the chance to replicate an experiment or perform a similar one - which might lead to different results (or maybe not). 

I would like to give comments about two mentioned things in the discussion: (1) generalizability, (2) tool support, (3) what to learn from the experiment

(1) Generalizability
====================
Are the experiment's results generalizable? Certainly not! It uses an artificial environment, language, etc. 

But does not meant that the experiment is meaningless? Certainly not! 

The motivation for such kind of experiments is to find out whether some "common believes" you frequently find in literature as well as in discussions can be "measured somehow". An interesting thing is, that even in literature it is unclear what exactly this benefit finally is (or should be) - literature about type system typically emphasizes technical details but not what the expected benefit is and how it could be measured (interesting!). Because of that, the idea of this experiment was to find out whether a static type system - independent of any other influencing factors - leads to measurable differences (in comparison to dynamic type systems).

(2) Tooling
===========
It might be that languages with static type systems permit better tool support (refactoring browsers, code completion, etc.) -- well, or maybe not. In fact this is a research question on its own. 

If we want to make such a study, we must compare things that are comparable. If we for example use the Java Eclipse IDE and compare it directly with for example the Groovy Eclipse IDE, then we will probably find out that the Java support is much better (measured "somehow"). Is this an argument for Java? I doubt it. I would say, this is rather the result of hundreds of man years spent on the Eclipse IDE for Java compared to probably few man month spent on the Groovy IDE. Hence, when arguing "tool support for statically typed languages is better", we should take into account that much more effort is spent on these tools. For example, IDEs for dynamic languages could make heavily use of inference in order to give better tool support -- this would require some effort and typically this effort is not spent.

(3) What can be learned?
========================
Does the experiment give a definitive answer to the discussion about static vs. dynamic types? No. (Would anyone seriously assume that 40 years research in type systems would be evaluated in one single experiment?)

The experiment only gives some hints - and shows that the answer to this question might be much more complicated than we expect. My personal opinion is, that the final answer will be of the kind "in circumstances of kind A, a type system of kind T will lead to X in comparison to a dynamic type system of kind D".

The experiment gives a first proposal how "benefit" could be measured: development time and number of fulfilled test cases (in the meantime, all experiments I performed just concentrate on development time for some reasons - I skip it here, because this message is already too long). And the experiment gives a first hint, that the result of such experiment is not that trivial as we expect. 

From that perspective, I see the benefit of the experiment in the following way: it gives doubts that the often articulated belief about the benefit of static type systems holds that easily. 

So far, the experiment is just the beginning (well, we are working in it). But I would like to welcome everyone to participate in the discussion by performing an experiment.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1352106493.2131";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>2042</wp:comment_id>
			<wp:comment_author><![CDATA[Grzegorz Adam Hankiewicz]]></wp:comment_author>
			<wp:comment_author_email>gradha@elhaso.com</wp:comment_author_email>
			<wp:comment_author_url>http://elhaso.com/</wp:comment_author_url>
			<wp:comment_author_IP>79.153.213.41</wp:comment_author_IP>
			<wp:comment_date>2012-11-07 01:53:29</wp:comment_date>
			<wp:comment_date_gmt>2012-11-07 09:53:29</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Thank you for your work.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>2027</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1352282009.7951";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>1951</wp:comment_id>
			<wp:comment_author><![CDATA[Pedro Furlanetto]]></wp:comment_author>
			<wp:comment_author_email>pedrofurla@gmail.com</wp:comment_author_email>
			<wp:comment_author_url>http://pedrofurla.github.com</wp:comment_author_url>
			<wp:comment_author_IP>189.60.101.27</wp:comment_author_IP>
			<wp:comment_date>2012-10-28 17:09:29</wp:comment_date>
			<wp:comment_date_gmt>2012-10-29 00:09:29</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Here is the article link http://pleiad.dcc.uchile.cl/papers/2012/mayerAl-oopsla2012.pdf.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>1946</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1351469369.8966";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>1954</wp:comment_id>
			<wp:comment_author><![CDATA[Mike Marynowski]]></wp:comment_author>
			<wp:comment_author_email>mikem@singulink.com</wp:comment_author_email>
			<wp:comment_author_url>http://www.singulink.com</wp:comment_author_url>
			<wp:comment_author_IP>24.52.223.67</wp:comment_author_IP>
			<wp:comment_date>2012-10-29 06:18:30</wp:comment_date>
			<wp:comment_date_gmt>2012-10-29 13:18:30</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[The awesomeness of static languages comes down to literally one thing: intellisense. I can't even begin to count how many times an hour I use intellisense to show me method documentation or a list of overloads with parameter descriptions. Referencing external docs for that all the time would be exhausting.

As far as I can tell from the paper, the IDE did not have the equivalent functionality of intellisense. If it did, I can GUARANTEE, especially as everyone was new to the language, that the static group would have blown the dynamic group out of the water in all metrics.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1351516711.2308";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>2029</wp:comment_id>
			<wp:comment_author><![CDATA[Nicholas Perry]]></wp:comment_author>
			<wp:comment_author_email>ape.inago@gmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>199.21.137.81</wp:comment_author_IP>
			<wp:comment_date>2012-11-05 06:19:31</wp:comment_date>
			<wp:comment_date_gmt>2012-11-05 14:19:31</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Perl 6 is implementing static definitions pragma to specifically to avoid the runtime cost of needing to assume that a type can be redefined at any moment. It backports to 5, there are significant speedups simply because of the amount of ram they don't' have to waste keeping track of everything.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>1964</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1352125171.7186";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>1974</wp:comment_id>
			<wp:comment_author><![CDATA[Mike Marynowski]]></wp:comment_author>
			<wp:comment_author_email>mikem@singulink.com</wp:comment_author_email>
			<wp:comment_author_url>http://www.singulink.com</wp:comment_author_url>
			<wp:comment_author_IP>24.52.223.67</wp:comment_author_IP>
			<wp:comment_date>2012-10-30 06:07:58</wp:comment_date>
			<wp:comment_date_gmt>2012-10-30 13:07:58</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Okay, I agree. I didn't fully understand the nature of the blog when I commented, so if I had a chance to rewrite them, it would go something like this:

While this might provide a good foundation for further research, I think this paper alone should be taken with a grain of salt in the static vs dynamic language debate. It didn't actually provide most of the productivity benefits available to any modern statically typed language to its participants and then went on to measure productivity. There are other problems, such as the scope of the task, which limit its applicability as well.

This blog post, however, paraphrases the research incorrectly: "the existence of a static type system did not have a positive impact on development time or quality" - that's not what it says in the paper, right in the abstract. The author of the blog post conveniently left out the part about it not having a negative impact either so that he could continue with the rest of that paragraph while still making sense. The results of the study actually show that both are within standard deviation of each other, meaning you cannot conclude which was faster. The subject pool was rather limited and students abilities were clearly all over the map - some implemented it in 15 hours, some in 2...so to draw any conclusions from these numbers is premature at best, and the paper acknowledges that it doesn't show one being better than the other, yet this blog jumps to conclusions.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>1972</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1351602479.2851";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>1973</wp:comment_id>
			<wp:comment_author><![CDATA[Mike Marynowski]]></wp:comment_author>
			<wp:comment_author_email>mikem@singulink.com</wp:comment_author_email>
			<wp:comment_author_url>http://www.singulink.com</wp:comment_author_url>
			<wp:comment_author_IP>24.52.223.67</wp:comment_author_IP>
			<wp:comment_date>2012-10-30 05:45:29</wp:comment_date>
			<wp:comment_date_gmt>2012-10-30 12:45:29</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[To backup which claims? I can show you performance numbers of typed vs untyped JS arrays if you like.

Logical assertions don't need data, they follow the laws of logic. Do you need data to prove that a lamp is not a table?

I'm allowed to criticize the usefulness of a study without numbers to the contrary by pointing out how it isn't relevant to the conditions of "real world" usage of the subject of the test.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>1965</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1351601130.6584";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>1972</wp:comment_id>
			<wp:comment_author><![CDATA[Daniel Sobral]]></wp:comment_author>
			<wp:comment_author_email>dcsobral@gmail.com</wp:comment_author_email>
			<wp:comment_author_url>http://dcsobral.blogspot.com/</wp:comment_author_url>
			<wp:comment_author_IP>189.9.0.12</wp:comment_author_IP>
			<wp:comment_date>2012-10-30 04:56:13</wp:comment_date>
			<wp:comment_date_gmt>2012-10-30 11:56:13</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Clearly, most people commenting here are new to the blog.

So, I'll repeat what others said: what you think is outside the scope of this blog. This blog is concerned only with what has been shown with controlled and reproducible experiments.

The experiment in question is specifically concerned with the difference between a language with annotated static types that produce errors at compile time versus the same language without static types or type annotations, developed on the same IDE, where the developers are not experienced professionals and have no previous knowledge of the language.

The experiment *does* show results for these constraints, and the setup is clear enough that people ought to be able to reproduce it and see if the results hold up or not.

It also offers a *baseline* against which one can experiment other variations. Would an improved IDE make a difference? Would static types without type annotations make a difference? Would dynamic types with type annotation make a difference? Would different programming tasks make a difference? Would longer tasks make a difference? Would a different selection of subjects make a difference?

While many people have offered opinions on the questions above, they have failed to realize that this paper they are looking down on provides a base upon which studies can be made to *show* the answer.

That is science. Opinions are not.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1351598174.8267";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>1971</wp:comment_id>
			<wp:comment_author><![CDATA[sanjin]]></wp:comment_author>
			<wp:comment_author_email>bhsephiroth@gmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>217.75.199.100</wp:comment_author_IP>
			<wp:comment_date>2012-10-30 02:28:47</wp:comment_date>
			<wp:comment_date_gmt>2012-10-30 09:28:47</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[IMHO static can't win over dynamic in small projects and shouldn't. The only thing that i find missing is organic expansion of the projects over 2-3 months+ where the true maintainability comes to shine. It becomes very difficult to maintain a dynamic type growing projects, as some have mentioned above, because it too often ends up as less structured than static types.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1351589327.5188";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>1969</wp:comment_id>
			<wp:comment_author><![CDATA[John Smith]]></wp:comment_author>
			<wp:comment_author_email>jsmith@gmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>24.108.130.44</wp:comment_author_IP>
			<wp:comment_date>2012-10-29 23:18:51</wp:comment_date>
			<wp:comment_date_gmt>2012-10-30 06:18:51</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Your last paragraph is my point: You don't have data to backup your claims.  It's not about what you think is logic.  That isn't research.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>1965</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1351577931.9409";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>1968</wp:comment_id>
			<wp:comment_author><![CDATA[Anonymous Coward]]></wp:comment_author>
			<wp:comment_author_email>a_flj_@hotmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>79.114.90.115</wp:comment_author_IP>
			<wp:comment_date>2012-10-29 19:16:08</wp:comment_date>
			<wp:comment_date_gmt>2012-10-30 02:16:08</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[From a productivity POV alone, I think the usefulness and importance of static typing is greatly compensated in dynamically typed languages if you thoroughly use unit tests.

Not even the best compiler can do as many checks and tests on your code as unit tests can do. If you have no unit tests, you need to rely on the compiler for catching many trivial errors early on. If you do have unit tests, you'll catch all of these and then some, even with a language with no strong typing.

Since unit tests have become much more mainstream than it was maybe ten or twenty years ago, I think the importance of static typing has decreased correspondingly. There are, however, characteristics of languages with static typing which make them more appropriate for certain types of applications.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1351563368.8707";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>1965</wp:comment_id>
			<wp:comment_author><![CDATA[Mike Marynowski]]></wp:comment_author>
			<wp:comment_author_email>mikem@singulink.com</wp:comment_author_email>
			<wp:comment_author_url>http://www.singulink.com</wp:comment_author_url>
			<wp:comment_author_IP>24.52.223.67</wp:comment_author_IP>
			<wp:comment_date>2012-10-29 11:47:15</wp:comment_date>
			<wp:comment_date_gmt>2012-10-29 18:47:15</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[What are you talking about, show you what data? I'm agreeing with the study under the conditions of the test. 

Do you want me to show you that static typing can be more performant? That's easy: read up on why they added statically typed arrays to the JavaScript spec, the most prolific dynamically typed language currently in existence. Browsers that put optimizations in for the type can be quite a bit faster (i.e. latest version of chrome).

Discoverability is just a matter of logic - there are obviously more opportunities for the IDE to provide code completion and related enhancements, given that it always knows what type you are working with.

Productivity with IDE support is a function of how well the IDE uses the type information it has to assist you. C# under Visual Studio + Resharper is bloody incredible, and I'm not really sure if there is a close second, but I haven't found it yet.

I don't have numbers...I'm saying we need numbers that compare the best dynamic development environment to the best static environment, not this useless comparison.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>1964</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:14:"1351536435.441";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>1964</wp:comment_id>
			<wp:comment_author><![CDATA[John Smith]]></wp:comment_author>
			<wp:comment_author_email>jsmith@gmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>142.104.68.94</wp:comment_author_IP>
			<wp:comment_date>2012-10-29 09:45:19</wp:comment_date>
			<wp:comment_date_gmt>2012-10-29 16:45:19</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Talk is cheap. Show me the data.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>1963</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:14:"1351529119.869";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>1963</wp:comment_id>
			<wp:comment_author><![CDATA[Mike Marynowski]]></wp:comment_author>
			<wp:comment_author_email>mikem@singulink.com</wp:comment_author_email>
			<wp:comment_author_url>http://www.singulink.com</wp:comment_author_url>
			<wp:comment_author_IP>24.52.223.67</wp:comment_author_IP>
			<wp:comment_date>2012-10-29 07:15:03</wp:comment_date>
			<wp:comment_date_gmt>2012-10-29 14:15:03</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[I agree, but I think my point was that this study is fairly pointless in the way it was conducted anyway. I fully agree - a dynamic language is much more productive without an advanced IDE. I don't know anyone who would disagree with that, so it is proving a moot point.

The advantages of static languages are: opportunities for better performance optimization and productivity/discoverability/static type safety, with appropariate IDE support. All he effectively measured was static type safety. Obviously dynamic will win out under the circumstances.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>1962</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1351520104.3018";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>1956</wp:comment_id>
			<wp:comment_author><![CDATA[Peter Hickman]]></wp:comment_author>
			<wp:comment_author_email>peterhickman386@googlemail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>82.152.150.75</wp:comment_author_IP>
			<wp:comment_date>2012-10-29 06:44:48</wp:comment_date>
			<wp:comment_date_gmt>2012-10-29 13:44:48</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Your guarantee just got voided. Dynamic languages like Ruby also have code completion (AKA 'intellisense') Rubymine will do this for you out of the box. Actually Smalltalk had this decades ago.

Also I distrust a language that cannot be developed in without such tools, it only begets lazy programmers.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>1954</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1351518288.5832";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>1958</wp:comment_id>
			<wp:comment_author><![CDATA[Ryan]]></wp:comment_author>
			<wp:comment_author_email>sdfs@sdsd.net</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>86.145.97.79</wp:comment_author_IP>
			<wp:comment_date>2012-10-29 06:49:06</wp:comment_date>
			<wp:comment_date_gmt>2012-10-29 13:49:06</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[*just fine.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>1954</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1351518546.6666";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>1959</wp:comment_id>
			<wp:comment_author><![CDATA[Mike Marynowski]]></wp:comment_author>
			<wp:comment_author_email>mikem@singulink.com</wp:comment_author_email>
			<wp:comment_author_url>http://www.singulink.com</wp:comment_author_url>
			<wp:comment_author_IP>24.52.223.67</wp:comment_author_IP>
			<wp:comment_date>2012-10-29 06:56:37</wp:comment_date>
			<wp:comment_date_gmt>2012-10-29 13:56:37</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Yes, I've used dynamic languages with code completion, but they don't nearly provide the same level of support. For example:

function x(y, z)
{
   // stuff
}

You can't possibly get member completion on y and z unless you have a context of something calling it. And the only way you know what type is being passed in is by following a chain of calls until you come to some kind of constant, which may never happen if you are developing a library (as opposed to an actual application).

@Ryan Yes, I'm a moron. Congrats for being a tool on the internet, you must be really badass in real life.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>1954</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1351518998.1173";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>1960</wp:comment_id>
			<wp:comment_author><![CDATA[Mike Marynowski]]></wp:comment_author>
			<wp:comment_author_email>mikem@singulink.com</wp:comment_author_email>
			<wp:comment_author_url>http://www.singulink.com</wp:comment_author_url>
			<wp:comment_author_IP>24.52.223.67</wp:comment_author_IP>
			<wp:comment_date>2012-10-29 06:58:44</wp:comment_date>
			<wp:comment_date_gmt>2012-10-29 13:58:44</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[And by constant I mean something that implies what type of object is being passed in or what members it has...so not really a constant.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>1959</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1351519124.9004";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>1961</wp:comment_id>
			<wp:comment_author><![CDATA[Mike Marynowski]]></wp:comment_author>
			<wp:comment_author_email>mikem@singulink.com</wp:comment_author_email>
			<wp:comment_author_url>http://www.singulink.com</wp:comment_author_url>
			<wp:comment_author_IP>24.52.223.67</wp:comment_author_IP>
			<wp:comment_date>2012-10-29 07:01:02</wp:comment_date>
			<wp:comment_date_gmt>2012-10-29 14:01:02</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[I would distrust a language that cannot be developed without such tools as well. It's not that you cannot, you just wouldn't want to given how big a productivity boost it provides. We might as well all go back to notepad if you don't like using tools that enhance productivity.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>1956</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1351519262.5958";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>1962</wp:comment_id>
			<wp:comment_author><![CDATA[Carl Friedrich Bolz]]></wp:comment_author>
			<wp:comment_author_email>cfbolz@gmx.de</wp:comment_author_email>
			<wp:comment_author_url>http://cfbolz.de</wp:comment_author_url>
			<wp:comment_author_IP>74.92.218.113</wp:comment_author_IP>
			<wp:comment_date>2012-10-29 07:09:00</wp:comment_date>
			<wp:comment_date_gmt>2012-10-29 14:09:00</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Oh come on. This discussion is futile, and misses the point of both the described research as well as this blog. Personal opinions, anecdotes (and name-calling) get us nowhere. To answer the question of how much code completion and other advanced IDE technology helps in development, a careful study is needed. Maybe we can instead discuss what such a study could look like.

That's also a wider point about the described research. The people doing it are neutral in the whole static/dynamic divide and just go out and try hard to measure stuff fairly. Of course that means everybody hates them equally, which is just silly.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1351519740.5198";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>1948</wp:comment_id>
			<wp:comment_author><![CDATA[Daniel Sobral]]></wp:comment_author>
			<wp:comment_author_email>dcsobral@gmail.com</wp:comment_author_email>
			<wp:comment_author_url>http://dcsobral.blogspot.com/</wp:comment_author_url>
			<wp:comment_author_IP>186.214.153.150</wp:comment_author_IP>
			<wp:comment_date>2012-10-27 17:15:24</wp:comment_date>
			<wp:comment_date_gmt>2012-10-28 00:15:24</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[@Carl

Thanks for pointing out that follow up study! That one is pretty solid, and though I'm not particularly interested in static type systems with annotations, it's definitely relevant.

I'm very much looking forward to the future work as discussed in by the end of the paper.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>1946</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1351383324.5501";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>1946</wp:comment_id>
			<wp:comment_author><![CDATA[Carl Friedrich Bolz]]></wp:comment_author>
			<wp:comment_author_email>cfbolz@gmx.de</wp:comment_author_email>
			<wp:comment_author_url>http://cfbolz.de</wp:comment_author_url>
			<wp:comment_author_IP>74.92.218.113</wp:comment_author_IP>
			<wp:comment_date>2012-10-27 11:04:38</wp:comment_date>
			<wp:comment_date_gmt>2012-10-27 18:04:38</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[The answer to an imperfect study should not be to be unhappy about it, but to go and do better studies. This annoys me greatly in many of the commentary on Stefan Hanenberg's work. Yes, his studies may have flaws (or not), but at least he's doing them, and he's definitely putting a lot of thoughts into the work.

BTW: There is a follow-up paper in this year's OOPSLA: http://dl.acm.org/citation.cfm?id=2384666]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1351361078.5341";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>1943</wp:comment_id>
			<wp:comment_author><![CDATA[John Smith]]></wp:comment_author>
			<wp:comment_author_email>jsmith@gmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>209.121.225.159</wp:comment_author_IP>
			<wp:comment_date>2012-10-26 21:08:08</wp:comment_date>
			<wp:comment_date_gmt>2012-10-27 04:08:08</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[I wonder if people commenting here actually read the paper.  Besides Daniel Sobar, it doesn't seem so.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1351310888.9846";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>1942</wp:comment_id>
			<wp:comment_author><![CDATA[Wyatt]]></wp:comment_author>
			<wp:comment_author_email>wyatt.epp@gmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>99.100.48.211</wp:comment_author_IP>
			<wp:comment_date>2012-10-26 18:36:05</wp:comment_date>
			<wp:comment_date_gmt>2012-10-27 01:36:05</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[In addition to the above, my intuition re:static types in working with D has been that they don't show their true worth until you start doing more complex things. My classic example in this area is to consider the case of coordinate transforms in a simple 2d game engine. You want to optimise by rendering only the local area, so you need to translate x and y across different spaces. But what we found is it's very, very absurdly easy to accidentally swap an x for a y. So now you have a class of insidious bug that you can only find via a time-costly manual audit or you can use your type system to enforce the directionality and the compiler catches it immediately.

The above is something that has actually happened.  Unfortunately, the first time, we _didn't_ have a nice type system. The time cost really was considerable (especially considering our deadline). 

Trivial exercises are necessarily limited in weight by their very nature.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1351301765.3315";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>1937</wp:comment_id>
			<wp:comment_author><![CDATA[Daniel Sobral]]></wp:comment_author>
			<wp:comment_author_email>dcsobral@gmail.com</wp:comment_author_email>
			<wp:comment_author_url>http://dcsobral.blogspot.com/</wp:comment_author_url>
			<wp:comment_author_IP>189.9.0.12</wp:comment_author_IP>
			<wp:comment_date>2012-10-26 06:53:06</wp:comment_date>
			<wp:comment_date_gmt>2012-10-26 13:53:06</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[The paper does not list as a threat to validity the design of the language: it has all of the problems associated with static typing, without any of the benefits.

First, it conflates static typing with type declaration. Since he designed the language, he should have taken care to make sure the code produced in the static and dynamic versions would be essentially the same. Instead, we see that type declaration is mandatory.

Even worse is the fact that he went for no generics, forcing the sole collection to rely on type reflection at run time and type casts -- that is, it forces dynamic typing techniques, but without its benefits.

The type errors are only shown when executing code, which is really more like dynamic typing. The lack of a separate compile process, which can be executed separately from running tests, seriously hampers the *only* static typing benefit granted to the subjects of his experiment.

Finally, most static typing benefits accrue from superior tooling and static analysis, none of which was provided.

Reading what I wrote above, it looks like I'm a static typing apologist, and that is just not the case. That I had so much to criticize on how he implemented his static typing, and no comment to make on the dynamic typing, makes it very clear to me how defective his experiment was.

But, despite all that, the one thing that really bothers me is that these things were not identified as threats to validity, which makes follow up studies controlling for them less likely than otherwise.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1351259587.4824";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>1935</wp:comment_id>
			<wp:comment_author><![CDATA[Marcin Olak]]></wp:comment_author>
			<wp:comment_author_email>marcin.olak@gmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>74.125.57.105</wp:comment_author_IP>
			<wp:comment_date>2012-10-26 02:14:24</wp:comment_date>
			<wp:comment_date_gmt>2012-10-26 09:14:24</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[+1 friendzis: It would be interesting to see how much effort would it take for a second group of developers to take a solution and correct it.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1351242864.7795";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>1934</wp:comment_id>
			<wp:comment_author><![CDATA[friendzis]]></wp:comment_author>
			<wp:comment_author_email>friendzis@gmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>193.219.66.113</wp:comment_author_IP>
			<wp:comment_date>2012-10-25 23:26:09</wp:comment_date>
			<wp:comment_date_gmt>2012-10-26 06:26:09</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[I think that the greatest debate in such study would be the core definition of "code quality". Personally, I think that, speaking of code, "high quality" and "well designed" are somewhat synonyms and barely distinguishable. Therefore, code quality should be measured in how easy it is: a) for another coder to step in or to completely take over the code; b) to fork and modify the project. To the contrary, as far as I understood from this article, Hanenberg measured code quality in number of test cases passed, what, in my opinion, measures not the quality of the code, but *correctness* - performance (answer-wise) of the code.
Sometimes a spaghetti code might have more edge cases covered than quality code (passes more test cases), but quite often has much the same usability as an executable itself, i.e. it is completely unmaintainable. High quality code is always faster (therefore cheaper) to maintain and/or debug.
All in all, code quality can only be measured in two steps. The second step would be for another larger group of coders to get the first code and measure the time required to modify the code in some way. That would be something closer to code quality.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1351232769.5993";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>2133</wp:comment_id>
			<wp:comment_author><![CDATA[Matt Davies]]></wp:comment_author>
			<wp:comment_author_email>mattie.davies@gmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>216.98.57.37</wp:comment_author_IP>
			<wp:comment_date>2012-11-22 07:59:58</wp:comment_date>
			<wp:comment_date_gmt>2012-11-22 15:59:58</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Actually, the opposite is true for me.  I started to use Lisp and Objective-C to do most of my programming, and when I go back to C++ I shudder.  The cost of experimenting with your code is high due to the fact that you have to maintain your code and make sure all the types match up.  I spend just as much time battling with the compiler as I do writing code.  I am many times more productive writing code in Lisp/Scheme and Objective-C than I am in C++.

Although I would admit C# is a much nicer environment to program in than C++.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>2035</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1353599998.7285";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>4683</wp:comment_id>
			<wp:comment_author><![CDATA[Stephan Schmidt]]></wp:comment_author>
			<wp:comment_author_email>stephan.schmidt@gmail.com</wp:comment_author_email>
			<wp:comment_author_url>http://codemonkeyism.com</wp:comment_author_url>
			<wp:comment_author_IP>87.185.164.224</wp:comment_author_IP>
			<wp:comment_date>2013-01-03 12:45:26</wp:comment_date>
			<wp:comment_date_gmt>2013-01-03 20:45:26</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Very good experiment, there are so few facts in software development. Though not a lot of people believe static type languages are faster for small project greenfield development. Nevertheless good facts one can build on. 

The interesting thing though would be: Are static languages better (faster to develop, less bugs, easier code understanding) in &gt;10k LOC brownfield projects a.) with new project members b.) old project members.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";d:1357245926.946609020233154296875;s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
		<title>How do Software Architects Consider Non-functional Requirements: An Exploratory Study</title>
		<link>http://www.neverworkintheory.org/?p=439</link>
		<pubDate>Wed, 07 Nov 2012 00:06:19 +0000</pubDate>
		<dc:creator>neil</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=439</guid>
		<description></description>
		<content:encoded><![CDATA[David Ameller, Claudia Ayala, Jordi Cabot, and Xavier Franch, <a href="http://upcommons.upc.edu/e-prints/bitstream/2117/15716/1/da-ca-jc-xf-report%20essi.pdf">How do Software Architects Consider Non-functional Requirements: An Exploratory Study</a>, RE 2012, Chicago.



<blockquote>
  Dealing with non-functional requirements (NFRs) has posed a challenge onto software engineers for many years. Over the years, many methods and techniques have been proposed to improve their elicitation, documentation, and validation. Knowing more about the state of the practice on these topics may benefit both practitioners’ and researchers’ daily work. A few empirical studies have been conducted in the past, but none under the perspective of software architects, in spite of the great influence that NFRs have on daily architects’ practices. This paper presents some of the findings of an empirical study based on 13 interviews with software architects. It addresses questions such as: who decides the NFRs, what types of NFRs matter to architects, how are NFRs documented, and how are NFRs validated. The results are contextualized with existing previous work.


</blockquote>

In this work, Ameller et al. consider the contention that NFRs ought to be driving concerns for software architects. They conducted a study with Spanish software architects in a variety of domains to understand how they thought of NFRs. Their first finding was that no one held a formal "architect" role, although that was what their work entailed. The job position was based on skills and knowledge rather than training. Their second finding was that NFRs were not of primary importance, which contradicts other research findings. Instead, they found it was more important to consider project-wide constraints like licencing and overall cost. This suggests some interesting directions for new research in the role architecture plays in the software development process.



A related blog post with more detail can be found <a href="http://modeling-languages.com/how-do-software-architects-deal-with-non-functional-requirements/">here</a>.


]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>439</wp:post_id>
		<wp:post_date>2012-11-06 16:06:19</wp:post_date>
		<wp:post_date_gmt>2012-11-07 00:06:19</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>439</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="architecture"><![CDATA[architecture]]></category>
		<category domain="post_tag" nicename="nfr"><![CDATA[NFR]]></category>
		<category domain="category" nicename="qualitative-studies"><![CDATA[Qualitative Studies]]></category>
		<category domain="category" nicename="reproducibility"><![CDATA[Reproducibility]]></category>
		<category domain="category" nicename="uncategorized"><![CDATA[Uncategorized]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[3]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Developing Project Guidance Through Code History Mining</title>
		<link>http://www.neverworkintheory.org/?p=445</link>
		<pubDate>Mon, 19 Nov 2012 18:04:50 +0000</pubDate>
		<dc:creator>gvwilson</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=445</guid>
		<description></description>
		<content:encoded><![CDATA[Many people have noted the wide gulf between the people who study software development and the people who do it. One person trying to close that gap is Michael Feathers, who is running a one-day workshop in London on Wednesday, January 16 titled "<a href="http://codehistorymining.eventbrite.co.uk/">Developing Project Guidance Through Code History Mining</a>". Feathers is the author of the landmark book <em><a href="http://www.amazon.com/Working-Effectively-Legacy-Michael-Feathers/dp/0131177052/">Working Effectively With Legacy Code</a></em>, and is actively seeking to build ties with people who have similar interests.



Our recommendation: two thumbs up.


]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>445</wp:post_id>
		<wp:post_date>2012-11-19 10:04:50</wp:post_date>
		<wp:post_date_gmt>2012-11-19 18:04:50</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>developing-project-guidance-through-code-history-mining</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="announcements"><![CDATA[Announcements]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Two Solitudes Illustrated</title>
		<link>http://www.neverworkintheory.org/?p=448</link>
		<pubDate>Thu, 06 Dec 2012 19:08:32 +0000</pubDate>
		<dc:creator>gvwilson</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=448</guid>
		<description></description>
		<content:encoded><![CDATA[<a href="http://cuevano.ca/">Jorge Aranda</a> and I submitted a short opinion piece to <a href="http://cacm.acm.org/">Communications of the ACM</a> in February 2012 that discussed some of the reasons people in industry and academia don’t talk to each other as much as they should. Ten months later, it has ironically turned into an illustration of one of the reasons: it was six months before we received any feedback at all, and we’ve now waited four months for any further word. In that time, Jorge has left academia and I’ve taken a job with Mozilla, so we have decided to withdraw the manuscript and publish it on <a href="http://third-bit.com/blog/archives/4552.html">my personal blog</a>. We hope you find it interesting, and we would welcome comments.


]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>448</wp:post_id>
		<wp:post_date>2012-12-06 11:08:32</wp:post_date>
		<wp:post_date_gmt>2012-12-06 19:08:32</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>two-solitudes-illustrated</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="announcements"><![CDATA[Announcements]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Empirical Evidence for the Value of Version Control?</title>
		<link>http://www.neverworkintheory.org/?p=451</link>
		<pubDate>Wed, 12 Dec 2012 20:07:07 +0000</pubDate>
		<dc:creator>gvwilson</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=451</guid>
		<description></description>
		<content:encoded><![CDATA[We received this by email:



<blockquote>
I use version control for my software, and I encourage others to do so, but I have no experimental evidence to base that decision. I pulled out my old copy of <cite>Code Complete</cite> (it's a first edition), and the only reference it makes is to "Moore 1992", which is a private communication that says that Microsoft considers their internal use of version control to be a competitive advantage.


The common practices I know of are:


<ol>
  <li>no version control</li>
  <li>every once in a while make a backup, either as a tar/zip file or copy everything into a new directory</li>
  <li>use filesystem versioning, like what was on a VAX, or Time Machine on a Mac, or Dropbox for a distributed multi-version file system</li>
  <li>- use a version control system; though this in turn can vary from SCCS and RCS to Fossil and Veracity</li>
</ol>
In addition, there's a difference between the needs of a single developer vs. a small team, vs. a large, distributed team.


Is there published experimental evidence showing that a version control system is more useful than, say, developing using Dropbox? I tried looking for the relevant papers but I don't know how to search that field and I couldn't find anything.


</blockquote>

It's a good question&mdash;does anyone have an answer?


]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>451</wp:post_id>
		<wp:post_date>2012-12-12 12:07:07</wp:post_date>
		<wp:post_date_gmt>2012-12-12 20:07:07</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>empirical-evidence-for-the-value-of-version-control</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="questions"><![CDATA[Questions]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>2244</wp:comment_id>
			<wp:comment_author><![CDATA[Andrew Dalke]]></wp:comment_author>
			<wp:comment_author_email>dalke@dalkescientific.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>83.252.39.192</wp:comment_author_IP>
			<wp:comment_date>2012-12-12 14:55:37</wp:comment_date>
			<wp:comment_date_gmt>2012-12-12 22:55:37</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[My copy of "Making Software" is 2 meters behind me. :) I'm a single person developer who doesn't use CI, TDD, or pair-programming, so it reads like you're suggesting that version control isn't that useful for a non-agile group. My intuition suggests otherwise.

You correctly mention that the tools fit together, but I quickly found several CI tools which trigger automatically on file system changes. Wouldn't that be more effective feedback than waiting for a manually started version control system event? In fact, it sounds like a single developer might be more effective with an automatic versioning file system with notifications than with a version control system operated manually.

Could you think of an experiment along those lines. Use pair-programming, TDD, unit tests, and CI for a problem, with two different groups. One has a versioned file system that saves every changed file and CI hooked into those events. Teach them how to extract a snapshot from a point in history. The other uses a version control system, where the CI is connected to commit events, and where the people get some training in how to use the version control system.

That's the setup. I haven't come up with a reasonable experiment where the different pairs would need to access an older version of the software.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1355352937.9886";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>2427</wp:comment_id>
			<wp:comment_author><![CDATA[gvwilson]]></wp:comment_author>
			<wp:comment_author_email>gvwilson@third-bit.com</wp:comment_author_email>
			<wp:comment_author_url>http://third-bit.com/</wp:comment_author_url>
			<wp:comment_author_IP>99.231.121.18</wp:comment_author_IP>
			<wp:comment_date>2012-12-14 15:44:17</wp:comment_date>
			<wp:comment_date_gmt>2012-12-14 23:44:17</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[I believe there is a great deal of empirical evidence for many claims: it's just not well known. See http://www.amazon.com/Making-Software-Really-Works-Believe/dp/0596808321/ for a recent summary.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>2426</wp:comment_parent>
			<wp:comment_user_id>2</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";d:1355528657.8511641025543212890625;s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:8:"gvwilson";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>2426</wp:comment_id>
			<wp:comment_author><![CDATA[Derek Jones]]></wp:comment_author>
			<wp:comment_author_email>derek@knosof.co.uk</wp:comment_author_email>
			<wp:comment_author_url>http://shape-of-code.coding-guidelines.com</wp:comment_author_url>
			<wp:comment_author_IP>81.110.24.197</wp:comment_author_IP>
			<wp:comment_date>2012-12-14 15:35:42</wp:comment_date>
			<wp:comment_date_gmt>2012-12-14 23:35:42</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[There is almost no empirical evidence for nearly all the claims made in Software Engineering.  I am collecting empirical data and analysing it for my book on this topic http://shape-of-code.coding-guidelines.com/2012/06/22/background-to-my-book-project-empirical-software-engineering-with-r/, so please let me know if you have anything interesting.

There is an analysis of "Break even ratios for development investment decisions" here:
http://shape-of-code.coding-guidelines.com/2012/10/23/break-even-ratios-for-development-investment-decisions/
what we need is data on how frequently developers need to roll back changes to contrast with how often the same thing could not have been achieved using regular backups.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";d:1355528192.9587199687957763671875;s:7:"message";s:44:"jorge changed the comment status to approved";s:5:"event";s:15:"status-approved";s:4:"user";s:5:"jorge";}]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";d:1355528142.2177178859710693359375;s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>2245</wp:comment_id>
			<wp:comment_author><![CDATA[Andrew Dalke]]></wp:comment_author>
			<wp:comment_author_email>dalke@dalkescientific.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>83.252.39.192</wp:comment_author_IP>
			<wp:comment_date>2012-12-12 15:08:45</wp:comment_date>
			<wp:comment_date_gmt>2012-12-12 23:08:45</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[The VAX/VMS system made backups of all old files, in the form "a;1", "a;2", a;3", etc. The normal listing only showed "a", but you could ask it for all versions. I don't know how the Mac gives shell access to the history, but if it's like the VMS approach then "diff a;1 a;3" would give fine-grained information about single files. (Ignore that ';' means something to the unix shell.)

What it doesn't give are user annotations for the changes, and coordination of the change of multiple files. So, approximately like the SCCS and RCS days. There's the obvious downside that experimental code which proved bad is also in the history. Under VMS you would do 'rm a;3' if you didn't want to keep that version around. At that point it's gone forever.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>2242</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1355353725.4907";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>2240</wp:comment_id>
			<wp:comment_author><![CDATA[Roman Zenka]]></wp:comment_author>
			<wp:comment_author_email>zenka.roman@mayo.edu</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>129.176.151.24</wp:comment_author_IP>
			<wp:comment_date>2012-12-12 14:34:41</wp:comment_date>
			<wp:comment_date_gmt>2012-12-12 22:34:41</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[I use commits to trigger a continuous integration build. I could do this with DropBox, but I would need to manually invoke it after every change that I consider complete and releasable.

I maintain multiple versions of a particular software package in different environments. I can backport changes from one version (developmental, bleeding edge), to another one (stable, tested, only needs most urgent hotfixes). I could not do this without a version control system at all.

So it is not that it saves me time 'backing up' my work. It makes certain tasks possible, because change is managed in well-organized and described chunks. There is no way how to do this automatically, you need to commit with a well-written message.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1355351681.6293";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>2241</wp:comment_id>
			<wp:comment_author><![CDATA[Julius Davies]]></wp:comment_author>
			<wp:comment_author_email>juliusdavies@gmail.com</wp:comment_author_email>
			<wp:comment_author_url>http://juliusdavies.ca</wp:comment_author_url>
			<wp:comment_author_IP>174.6.83.50</wp:comment_author_IP>
			<wp:comment_date>2012-12-12 14:40:20</wp:comment_date>
			<wp:comment_date_gmt>2012-12-12 22:40:20</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Exactly!  Who needs empiricial evidence when a proof already provides the result!]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>2237</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1355352020.1992";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>2242</wp:comment_id>
			<wp:comment_author><![CDATA[Matt Doar]]></wp:comment_author>
			<wp:comment_author_email>mdoar@pobox.com</wp:comment_author_email>
			<wp:comment_author_url>http://www.pobox.com/~doar</wp:comment_author_url>
			<wp:comment_author_IP>98.207.153.152</wp:comment_author_IP>
			<wp:comment_date>2012-12-12 14:40:43</wp:comment_date>
			<wp:comment_date_gmt>2012-12-12 22:40:43</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[I don't have evidence but I would examine the advantages of fine-grain information about single files.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>2238</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1355352043.5098";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>2243</wp:comment_id>
			<wp:comment_author><![CDATA[Matt Doar]]></wp:comment_author>
			<wp:comment_author_email>mdoar@pobox.com</wp:comment_author_email>
			<wp:comment_author_url>http://www.pobox.com/~doar</wp:comment_author_url>
			<wp:comment_author_IP>98.207.153.152</wp:comment_author_IP>
			<wp:comment_date>2012-12-12 14:44:16</wp:comment_date>
			<wp:comment_date_gmt>2012-12-12 22:44:16</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[The question is really about comparing #3 and #4.  That's harder but I like the reference to integration in William Payne's response below.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>2241</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1355352256.4829";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>2247</wp:comment_id>
			<wp:comment_author><![CDATA[Andrew Dalke]]></wp:comment_author>
			<wp:comment_author_email>dalke@dalkescientific.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>83.252.39.192</wp:comment_author_IP>
			<wp:comment_date>2012-12-12 15:35:16</wp:comment_date>
			<wp:comment_date_gmt>2012-12-12 23:35:16</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Some CI tools use OS-dependent file system events to trigger a test. Couldn't you use the same triggers?

I agree that version control is useful, but people did multiple architecture, multiple version deployments without version control systems. The original SCCS paper makes that clear, because it outlines the same problems you listed now, in order to highlight the mistakes people sometimes made when doing it manually. People used multiple directories, kept notes, did more work, and made more mistakes. I conjecture that at least some of those mistakes can be minimized with a versioning file system. But what you do now is not impossible without an automatic version control system.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>2240</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1355355316.5648";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>2239</wp:comment_id>
			<wp:comment_author><![CDATA[William Payne]]></wp:comment_author>
			<wp:comment_author_email>wtpayne@gmail.com</wp:comment_author_email>
			<wp:comment_author_url>http://about.me/william.payne</wp:comment_author_url>
			<wp:comment_author_IP>94.174.239.225</wp:comment_author_IP>
			<wp:comment_date>2012-12-12 14:07:35</wp:comment_date>
			<wp:comment_date_gmt>2012-12-12 22:07:35</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[The best source of empirical research on software development that I have come across is this book: http://www.amazon.com/Making-Software-Really-Works-Believe/dp/0596808321.

Unfortunately, it does not have a chapter specifically on version control, so this may not be the answer that you are looking for.

It is worth bearing in mind that the greatest benefit from version control is not to be found in the ability to go back to previous revisions, but rather in the ability to detect changes and to trigger various scripts and automation, with a specific, identified version as input. As such, it forms the foundation for techniques such as continuous integration, greatly eases test driven development, and really makes the whole "agile" approach practicable.

As a result, when evaluating the benefits of version control, do not do so in isolation, but rather as a component in a system of development processes and tools - the value of which is a nonlinear (neither additive nor multiplicative) function of the component parts.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1355350055.3477";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>2237</wp:comment_id>
			<wp:comment_author><![CDATA[Matt Doar]]></wp:comment_author>
			<wp:comment_author_email>mdoar@pobox.com</wp:comment_author_email>
			<wp:comment_author_url>http://www.pobox.com/~doar</wp:comment_author_url>
			<wp:comment_author_IP>98.207.153.152</wp:comment_author_IP>
			<wp:comment_date>2012-12-12 12:49:11</wp:comment_date>
			<wp:comment_date_gmt>2012-12-12 20:49:11</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[I don't. I just start listing all the time that can be wasted if a project is not using version control. And maybe point out that it's not that hard to use.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1355345351.6575";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>2238</wp:comment_id>
			<wp:comment_author><![CDATA[Andrew Dalke]]></wp:comment_author>
			<wp:comment_author_email>dalke@dalkescientific.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>83.252.39.192</wp:comment_author_IP>
			<wp:comment_date>2012-12-12 13:53:05</wp:comment_date>
			<wp:comment_date_gmt>2012-12-12 21:53:05</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[That's a comparison with method #1. What time is wasted compared to using a versioning file system (method #3), where backups are automatic and so require no time to learn nor new habits?]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1355349185.9826";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>2246</wp:comment_id>
			<wp:comment_author><![CDATA[Tavish Armstrong]]></wp:comment_author>
			<wp:comment_author_email>tavisharmstrong@gmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>69.165.136.65</wp:comment_author_IP>
			<wp:comment_date>2012-12-12 15:18:33</wp:comment_date>
			<wp:comment_date_gmt>2012-12-12 23:18:33</wp:comment_date_gmt>
			<wp:comment_content><![CDATA["The best source of empirical research on software development that I have come across is this book..."

You might want to take a look at who wrote this blog post :-)]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>2239</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:14:"1355354313.559";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>2249</wp:comment_id>
			<wp:comment_author><![CDATA[Matt Doar]]></wp:comment_author>
			<wp:comment_author_email>mdoar@pobox.com</wp:comment_author_email>
			<wp:comment_author_url>http://www.pobox.com/~doar</wp:comment_author_url>
			<wp:comment_author_IP>98.207.153.152</wp:comment_author_IP>
			<wp:comment_date>2012-12-12 15:57:13</wp:comment_date>
			<wp:comment_date_gmt>2012-12-12 23:57:13</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Not impossible, just tedious and hence error-prone. Makes me wonder what it is that we currently do by hand and our children will shiver at.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>2247</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1355356633.1624";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>2248</wp:comment_id>
			<wp:comment_author><![CDATA[Tavish Armstrong]]></wp:comment_author>
			<wp:comment_author_email>tavisharmstrong@gmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>69.165.136.65</wp:comment_author_IP>
			<wp:comment_date>2012-12-12 15:53:14</wp:comment_date>
			<wp:comment_date_gmt>2012-12-12 23:53:14</wp:comment_date_gmt>
			<wp:comment_content><![CDATA["Wouldn’t that be more effective feedback than waiting for a manually started version control system event?" I think the main benefit of the commit trigger is that a human has identified it as a sensible time to test the code. (Though I suppose you could have it watch the Changelog.txt or something. At which point, are you technically using a version control system?)



I wish I had the foggiest idea of how to design experiments, even if it was just for thought exercises...

In your above experiment, I'd be curious to know:

1) What *kinds* of problems do people actually run into? What kinds of problems don't appear in one or the other. Some problems are unique to VCSs -- how often do they crop up?
2) Do people using git throw their laptops out the window at a higher rate? (More seriously: are VCS users *happier* about the experience?)

"I haven’t come up with a reasonable experiment where the different pairs would need to access an older version of the software."

"git bisect" is a pretty neat tool for finding when a bug was introduced. Are these kinds of tasks possible without a VCS? Harder? I'd be curious to know if bug regressions happened more often...]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>2244</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1355356394.9163";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>2250</wp:comment_id>
			<wp:comment_author><![CDATA[Matt Doar]]></wp:comment_author>
			<wp:comment_author_email>mdoar@pobox.com</wp:comment_author_email>
			<wp:comment_author_url>http://www.pobox.com/~doar</wp:comment_author_url>
			<wp:comment_author_IP>98.207.153.152</wp:comment_author_IP>
			<wp:comment_date>2012-12-12 15:58:54</wp:comment_date>
			<wp:comment_date_gmt>2012-12-12 23:58:54</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[The use of bisect with version control is at least a decade old, definitely pre-git.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>2248</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1355356734.1954";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>2251</wp:comment_id>
			<wp:comment_author><![CDATA[Tavish Armstrong]]></wp:comment_author>
			<wp:comment_author_email>tavisharmstrong@gmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>69.165.136.65</wp:comment_author_IP>
			<wp:comment_date>2012-12-12 16:05:37</wp:comment_date>
			<wp:comment_date_gmt>2012-12-13 00:05:37</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Ah, not surprised to hear it. Is there a general term for it, or is it always called "bisect"? The specific tool isn't what I'm wondering about in any case.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>2250</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1355357137.3514";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>2252</wp:comment_id>
			<wp:comment_author><![CDATA[Matt Doar]]></wp:comment_author>
			<wp:comment_author_email>mdoar@pobox.com</wp:comment_author_email>
			<wp:comment_author_url>http://www.pobox.com/~doar</wp:comment_author_url>
			<wp:comment_author_IP>98.207.153.152</wp:comment_author_IP>
			<wp:comment_date>2012-12-12 16:08:21</wp:comment_date>
			<wp:comment_date_gmt>2012-12-13 00:08:21</wp:comment_date_gmt>
			<wp:comment_content><![CDATA["bisect" is a common term now, "binary chop" (http://c2.com/cgi/wiki?BinaryChop) is an older one]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>2251</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1355357301.2048";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>2260</wp:comment_id>
			<wp:comment_author><![CDATA[Andrew Dalke]]></wp:comment_author>
			<wp:comment_author_email>dalke@dalkescientific.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>83.252.39.192</wp:comment_author_IP>
			<wp:comment_date>2012-12-13 04:54:03</wp:comment_date>
			<wp:comment_date_gmt>2012-12-13 12:54:03</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[If your versioned filesystem had a way to get a view of the directory tree snapshots for different points in time then it would be easy to implement a bisect method.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>2248</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1355403244.1884";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>2283</wp:comment_id>
			<wp:comment_author><![CDATA[RedG]]></wp:comment_author>
			<wp:comment_author_email>ronzaga@gmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>206.223.185.2</wp:comment_author_IP>
			<wp:comment_date>2012-12-13 11:37:15</wp:comment_date>
			<wp:comment_date_gmt>2012-12-13 19:37:15</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Really?! Don't bother trying to sell it. Just lay low and look for a new job.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:15:"1355427435.8548";s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>2404</wp:comment_id>
			<wp:comment_author><![CDATA[Markus]]></wp:comment_author>
			<wp:comment_author_email>mail@markus-ullmann.de</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>87.142.144.204</wp:comment_author_IP>
			<wp:comment_date>2012-12-14 10:10:07</wp:comment_date>
			<wp:comment_date_gmt>2012-12-14 18:10:07</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Version control systems force people to sync their local changes with other people regulary. If a bug is detected, it is easier to check when and why it was implemented in the first case (thinking of contradicting requirements). Any other possibility that would allow this would work just as well.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>2243</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";d:1355508607.3585860729217529296875;s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>2499</wp:comment_id>
			<wp:comment_author><![CDATA[Derek Jones]]></wp:comment_author>
			<wp:comment_author_email>derek@knosof.co.uk</wp:comment_author_email>
			<wp:comment_author_url>http://shape-of-code.coding-guidelines.com/</wp:comment_author_url>
			<wp:comment_author_IP>81.110.24.197</wp:comment_author_IP>
			<wp:comment_date>2012-12-15 05:49:55</wp:comment_date>
			<wp:comment_date_gmt>2012-12-15 13:49:55</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[That book has a Whos who in empirical software engineering list of contributors and I think many of them would agree that the available data is very thin ion the ground.  Tim Menzies' is doing a good jon of collecting what's available in the Promise repository.  I have written about how I think empirical software engineering is five years old:
http://shape-of-code.coding-guidelines.com/2011/03/31/empirical-software-engineering-is-five-years-old/

The data that is starting to become available is showing that many existing theories are not correct, something that is probably inevitable in any new discipline.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>2427</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";d:1355579396.1524150371551513671875;s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>4287</wp:comment_id>
			<wp:comment_author><![CDATA[Roman Zenka]]></wp:comment_author>
			<wp:comment_author_email>zenka.roman@mayo.edu</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>97.91.80.95</wp:comment_author_IP>
			<wp:comment_date>2012-12-30 16:48:10</wp:comment_date>
			<wp:comment_date_gmt>2012-12-31 00:48:10</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Actually, anything I do with a computer is not impossible without the computer. :) The key here is that there exists a concept of 'named unit of change'. I use the SCM to maintain these units. The people who use multiple directories have to keep notes or store all this information in their brains, but that does not mean they are not using a VCS. They are just using a manual (and very error-prone) one.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>2247</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";d:1356914890.20728588104248046875;s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>2707</wp:comment_id>
			<wp:comment_author><![CDATA[Nobody]]></wp:comment_author>
			<wp:comment_author_email>gzankevich@gmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>46.65.57.188</wp:comment_author_IP>
			<wp:comment_date>2012-12-17 01:06:54</wp:comment_date>
			<wp:comment_date_gmt>2012-12-17 09:06:54</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[The blindlingly obvious difference between #3 and #4 is that #3 has no facilities for merging. Given that one of the primary concerns of revision control systems is collaboration, I do not think that the question is valid for any half competent software developer.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>2243</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";d:1355735214.815167903900146484375;s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>2714</wp:comment_id>
			<wp:comment_author><![CDATA[akemonies]]></wp:comment_author>
			<wp:comment_author_email>Makesmniesonline@gmail.com</wp:comment_author_email>
			<wp:comment_author_url>http://Makemoniesonilne.com</wp:comment_author_url>
			<wp:comment_author_IP>96.50.32.105</wp:comment_author_IP>
			<wp:comment_date>2012-12-17 02:03:48</wp:comment_date>
			<wp:comment_date_gmt>2012-12-17 10:03:48</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Allows me to easily work from 3 separate computers without having to download a big ass zip file each time]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";d:1355738628.389225006103515625;s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>2716</wp:comment_id>
			<wp:comment_author><![CDATA[wer]]></wp:comment_author>
			<wp:comment_author_email>wer@ertc.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>80.169.157.170</wp:comment_author_IP>
			<wp:comment_date>2012-12-17 02:33:05</wp:comment_date>
			<wp:comment_date_gmt>2012-12-17 10:33:05</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[There have been no controlled studies on effectiveness of parachutes:

http://www.bmj.com/content/327/7429/1459

and yet we use them, only based on unscientific anecdotal reference!]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";d:1355740386.3654019832611083984375;s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>2719</wp:comment_id>
			<wp:comment_author><![CDATA[Bas]]></wp:comment_author>
			<wp:comment_author_email>seb.moeys@gmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>62.195.10.14</wp:comment_author_IP>
			<wp:comment_date>2012-12-17 03:07:12</wp:comment_date>
			<wp:comment_date_gmt>2012-12-17 11:07:12</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[I've been only using it for a year, and it's been very useful also for solo work:
- external help can be easily added at any moment in time
- more important: separating projects, features, issues and branches makes coding way more easy on the mind. It's nice to know that code is documented and stored somewhere, and can be taken on at any moment in time. Just leaving code out there makes me feel like it decays once the details in my head start fading.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";d:1355742432.58290004730224609375;s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>2720</wp:comment_id>
			<wp:comment_author><![CDATA[Gilney Santana]]></wp:comment_author>
			<wp:comment_author_email>Gilneysantana@gmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>187.90.8.159</wp:comment_author_IP>
			<wp:comment_date>2012-12-17 03:24:49</wp:comment_date>
			<wp:comment_date_gmt>2012-12-17 11:24:49</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[This is kind of a axioma to me... Didnt need research to support it...]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";d:1355743489.397798061370849609375;s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>2723</wp:comment_id>
			<wp:comment_author><![CDATA[Greg Wilson]]></wp:comment_author>
			<wp:comment_author_email>gvwilson@third-bit.com</wp:comment_author_email>
			<wp:comment_author_url>http://third-bit.com</wp:comment_author_url>
			<wp:comment_author_IP>99.231.121.18</wp:comment_author_IP>
			<wp:comment_date>2012-12-17 04:27:04</wp:comment_date>
			<wp:comment_date_gmt>2012-12-17 12:27:04</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[All of the "it's obvious" statements made here about version control have also been made (frequently) by defenders of test-driven development, and yet there, where studies *have* been done, the answer has been that TDD isn't effective --- see Erdogmus et al' meta-analysis in "Making Software".  Like most people in this conversation, I wouldn't work on a project without version control, but the original question was, have any studies been done, or has any data been collected to show how much of a difference it makes, and the answer, I think, is "no".]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";d:1355747224.827848911285400390625;s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>2732</wp:comment_id>
			<wp:comment_author><![CDATA[Nico de Poel]]></wp:comment_author>
			<wp:comment_author_email>ndepoel@gmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>81.30.42.111</wp:comment_author_IP>
			<wp:comment_date>2012-12-17 06:01:22</wp:comment_date>
			<wp:comment_date_gmt>2012-12-17 14:01:22</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[It's slightly depressing that this still needs to be explained to people, but here we go. A version control system is a tool that allows developers to easily:

1) Collaborate on a common codebase without having to carry USB sticks around the office or send files through e-mail. Granted, this could be done with Dropbox, but you don't get any file locking or merging capabilities.

2) Backup every incremental version of the codebase and restore old versions with minimal effort. Dropbox also allows you to restore old revisions, but AFAIK they don't guarantee how long those revisions will remain available, and restoring files and directories is a lot more cumbersome than with your average VCS.

3) Do concurrent development on different branches (e.g. development, bugfixing and experimental) and merge them back together. Technically you could "fork" a codebase in Dropbox by copying everything to a separate folder, but good luck merging branches back together.

4) Freeze and tag the codebase for a specific release. This allows you to quickly go back to the exact state of the codebase for that release in case it needs to be debugged. You could do this with Dropbox by copying, zipping and storing the codebase on release, but with a VCS tool it's a one-click operation.

5) Review changes made to the code through the use of diff tools. Dropbox does not allow you to do this out of the box, unless you like to manually download the separate revisions and invoke a diff tool on them. VCS tools have diff-ing integrated as a core feature.

6) Track changes made to a single line of code to a specific check-in and/or person. This helps understand how bugs got introduced into the codebase and why certain changes were made. Again, Dropbox does not do any of this.

On any non-trivial software project, all of the above points will be important sooner or later. Even if you work on a solo project and release only from the main development branch, the remaining points still make version control an invaluable tool.

And sure, you can do most of these things with Dropbox, but Dropbox was not made with this job in mind and as a result will be a very clunky solution if you need to perform any non-trivial operations on your codebase. It's basically a case of using the right tool for the job. Version Control Systems were made for doing version control, so if you need to do version control, please use a Version Control System.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";d:1355752883.6153070926666259765625;s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>2734</wp:comment_id>
			<wp:comment_author><![CDATA[Greg Wilson]]></wp:comment_author>
			<wp:comment_author_email>gvwilson@third-bit.com</wp:comment_author_email>
			<wp:comment_author_url>http://third-bit.com</wp:comment_author_url>
			<wp:comment_author_IP>66.207.208.98</wp:comment_author_IP>
			<wp:comment_date>2012-12-17 06:27:06</wp:comment_date>
			<wp:comment_date_gmt>2012-12-17 14:27:06</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Nico,
Thank you for your post, but everyone in this conversation knows what version control does (and I believe that everyone also agrees that it's beneficial).  The question is, what data do we have to show that, and following from that, how big are the benefits?  One poster said that there aren't any studies showing that parachutes are beneficial to people jumping out of planes, but we could certainly compile statistics on people who've jumped with and without 'chutes, look at mortality rates, and draw conclusions --- has anyone already compiled similar statistics for use (and non-use) of version control, and if so, where's the data?]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>2732</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";d:1355754426.3920528888702392578125;s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>2735</wp:comment_id>
			<wp:comment_author><![CDATA[Robert Cowham]]></wp:comment_author>
			<wp:comment_author_email>robert@vaccaperna.co.uk</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>195.7.255.103</wp:comment_author_IP>
			<wp:comment_date>2012-12-17 06:53:41</wp:comment_date>
			<wp:comment_date_gmt>2012-12-17 14:53:41</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Having introduced version control to various projects over the years ranging from single developer projects to much larger multi-user ones (admittedly some years ago - fortunately!), version control introduces a level of control that makes a difference, even on single user systems.

While versioned file systems are useful, the ability to mark a version and/or baseline your intended logical version no is useful - as long as you apply just a little rigour in your usage (e.g. avoid "fixed bug" style comments where no mention is made of which one!). So even if I had 50 versions of a file in a dropbox type auto maintained history, I am likely to be interested in the 10 or 20 that I "labelled" explicitly via check in comments.

Known baselines are wonderful things, and the lack of them often causes large amounts of time to be wasted, and usually at the most inopportune moment (Murphy's Law applies).

I don't think I have seen the introduction of version control regretted in any of the places I have worked (though that doesn't mean to say all tools are created equal!).

Mind you, I still don't always use it for every temporary exploration myself, even though I should know better ('cos I usually regret it if I don't!):

http://www.robertcowham.com/blog/172/hansel-and-gretels-lessons-for-safe-exploration-the-breadcrumbs-of-version-control/]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";d:1355756022.51857089996337890625;s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>2736</wp:comment_id>
			<wp:comment_author><![CDATA[Greg Wilson]]></wp:comment_author>
			<wp:comment_author_email>gvwilson@third-bit.com</wp:comment_author_email>
			<wp:comment_author_url>http://third-bit.com</wp:comment_author_url>
			<wp:comment_author_IP>66.207.208.98</wp:comment_author_IP>
			<wp:comment_date>2012-12-17 06:58:46</wp:comment_date>
			<wp:comment_date_gmt>2012-12-17 14:58:46</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Hi Robert,
Thanks for your comment, but as per http://www.neverworkintheory.org/?p=451#comment-2734, what we're after is data that demonstrates the benefits.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>2735</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";d:1355756326.485764026641845703125;s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>2748</wp:comment_id>
			<wp:comment_author><![CDATA[Matt Doar]]></wp:comment_author>
			<wp:comment_author_email>mdoar@pobox.com</wp:comment_author_email>
			<wp:comment_author_url>http://www.pobox.com/~doar</wp:comment_author_url>
			<wp:comment_author_IP>98.207.153.152</wp:comment_author_IP>
			<wp:comment_date>2012-12-17 09:57:14</wp:comment_date>
			<wp:comment_date_gmt>2012-12-17 17:57:14</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Merging is certainly made easier by a proper version control system. But diff and patch have been around forever and used manually (and painfully) for all that time.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>2707</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";d:1355767035.090579986572265625;s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>2783</wp:comment_id>
			<wp:comment_author><![CDATA[Reg]]></wp:comment_author>
			<wp:comment_author_email>pulaskite@yahoo.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>173.218.207.187</wp:comment_author_IP>
			<wp:comment_date>2012-12-17 15:31:17</wp:comment_date>
			<wp:comment_date_gmt>2012-12-17 23:31:17</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[This is a redux of "best software engineering practices". 

Describe how you would measure the benefits and costs.  Until you can state a viable means of measurement, it's a meaningless question.  Comparing a single variable among a large number affecting the outcome doesn't really provide meaningful information.  Just an anecdote decorated with numbers.

In general, the benefit or lack thereof is entirely dependent upon how tools are used.  An incompetent mechanic with the lots of tools can't fix anything.  A skilled mechanic with very few can fix almost everything.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";d:1355787077.4355640411376953125;s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>2879</wp:comment_id>
			<wp:comment_author><![CDATA[Next time you ask for proof of the benefits of software modeling I will&#8230;. | Modeling Languages]]></wp:comment_author>
			<wp:comment_author_email></wp:comment_author_email>
			<wp:comment_author_url>http://modeling-languages.com/next-time-you-ask-for-proof-of-the-benefits-of-software-modeling-i-will/</wp:comment_author_url>
			<wp:comment_author_IP>64.50.165.102</wp:comment_author_IP>
			<wp:comment_date>2012-12-18 07:06:42</wp:comment_date>
			<wp:comment_date_gmt>2012-12-18 15:06:42</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[[...] Until now, I used to point to the (true, few) scientific empirical studies on the effectiveness of software modeling (see Michel Chaudron&#8217;s work as an example) but now I have an even better link to give you: &#8220;Empirical Evidence of the Value of Version Control&#8221;. [...]]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type>pingback</wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";d:1355843202.67156505584716796875;s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>2901</wp:comment_id>
			<wp:comment_author><![CDATA[A.G.McDowell]]></wp:comment_author>
			<wp:comment_author_email>andrew-mcdowell@o2.co.uk</wp:comment_author_email>
			<wp:comment_author_url>http://www.mcdowella.demon.co.uk</wp:comment_author_url>
			<wp:comment_author_IP>94.195.253.182</wp:comment_author_IP>
			<wp:comment_date>2012-12-18 11:23:31</wp:comment_date>
			<wp:comment_date_gmt>2012-12-18 19:23:31</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[With multiple developers, version control (we use SVN via tortoise-SVN) provides better traceability than the non-version control systems quoted, especially when any file is being edited by more than one person. OTOH for my development for fun/practice on my home machine, I installed git, worked out an easy simple workflow for lone working, and then didn't bother to actually use it in practice. On my own, I use a main area and and a backup area copied to when I am happy with changes I have made.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";d:1355858611.4548380374908447265625;s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>2907</wp:comment_id>
			<wp:comment_author><![CDATA[Greg Wilson]]></wp:comment_author>
			<wp:comment_author_email>gvwilson@third-bit.com</wp:comment_author_email>
			<wp:comment_author_url>http://third-bit.com</wp:comment_author_url>
			<wp:comment_author_IP>99.231.121.18</wp:comment_author_IP>
			<wp:comment_date>2012-12-18 12:17:53</wp:comment_date>
			<wp:comment_date_gmt>2012-12-18 20:17:53</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Hi,
Thanks for your comment, but as per http://www.neverworkintheory.org/?p=451#comment-2734, what we’re after is data that demonstrates the benefits.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>2901</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";d:1355861874.0029699802398681640625;s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>3384</wp:comment_id>
			<wp:comment_author><![CDATA[Peter]]></wp:comment_author>
			<wp:comment_author_email>pedasmith@yahoo.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>50.46.151.175</wp:comment_author_IP>
			<wp:comment_date>2012-12-22 08:01:22</wp:comment_date>
			<wp:comment_date_gmt>2012-12-22 16:01:22</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[A key point about VAX/VMS  (now OpenVMS, and really, it's an attribute of the RMS file system) file extensions: you don't get much useful control over the file extension number, and the OS will automatically delete versions older than 'n' -- where 'n' was set (IIRC) to a pretty small number (less than 10).

In short: it was a very useful system for the "whoops I messed up" problems, but provided no particular facilities for non-short-term help.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>2245</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";d:1356192083.25627899169921875;s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>4266</wp:comment_id>
			<wp:comment_author><![CDATA[Why We Need Evidence - It Will Never Work in Theory]]></wp:comment_author>
			<wp:comment_author_email></wp:comment_author_email>
			<wp:comment_author_url>http://www.neverworkintheory.org/?p=457</wp:comment_author_url>
			<wp:comment_author_IP>64.90.54.151</wp:comment_author_IP>
			<wp:comment_date>2012-12-30 13:19:22</wp:comment_date>
			<wp:comment_date_gmt>2012-12-30 21:19:22</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[[...] Peter on Empirical Evidence for the Value of Version Control? [...]]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type>pingback</wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";d:1356902362.90725803375244140625;s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
		<title>Why We Need Evidence</title>
		<link>http://www.neverworkintheory.org/?p=457</link>
		<pubDate>Sun, 30 Dec 2012 21:19:16 +0000</pubDate>
		<dc:creator>gvwilson</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=457</guid>
		<description></description>
		<content:encoded><![CDATA[<p>Our previous post, "<a href="http://www.neverworkintheory.org/?p=451">Empirical Evidence for the Value of Version Control</a>", generated a lot of comments. Many sought to explain <em>why</em> version control is helpful, but that's not what we were looking for: we were looking for empirical evidence that it is. To see why we need it, take a look at <a href="http://modeling-languages.com/next-time-you-ask-for-proof-of-the-benefits-of-software-modeling-i-will/">this response</a> from Jordi Cabot [1]. In it, he says:</p>

<blockquote>
Quite regularly, I get questions about what empirical evidence supports my "belief" that models are good... Until now, I used to point to the (true, few) scientific empirical studies on the effectiveness of software modeling...but now I have an even anser to give you: “Empirical Evidence of the Value of Version Control”.
No, I haven't lost my mind. The point of this link is to show you that there's no proof that version control is better for software development, and yet, I don't think any of you would argue against it.
Same for modeling and model-driven engineering. It would be great to have more proof but the absence of proof alone should not be used against it unless you want to start also abandoning other unproven things like version control.
</blockquote>

<p>He's right: if we're willing to accept that version control is valuable, without proof, then we can hardly require advocates of modeling to prove their case.  Or advocates of functional programming, or literate programming, or <a href="http://en.wikipedia.org/wiki/Hungarian_notation">Hungarian notation</a>. Heck, if we don't require proof for <em>our</em> claims, then we're honor-bound to accept that Perl is "intuitive" because its grammar has as many special cases and contradictions as the grammars of natural languages, aren't we? Or that learning <a href="http://en.wikipedia.org/wiki/Befunge">Befunge</a> makes you a better programmer (seriously, I've heard that claim too).</p>

<p>At some point, the statement, "If we don't need to prove the value of version control, we don't need to prove the value of X" becomes absurd. However, everyone's threshold of absurdity is different. I personally <em>don't</em> think that modeling adds value for most developers in most situations&mdash;I think that if it did, or if its benefits really were as significant as its advocates claim, more developers would have adopted it by now&mdash;but <em>I don't <u>know</u></em>. What I do know is, if we can't demonstrate the value of something that most of us believe in, like version control, what chance do we have of telling whether other practices, like modeling and test-driven development, are worth adopting (or rather, when they're worth adopting and by whom, since I doubt there's a one-size-fits-all answer)?</p>

<p>So here are my requests:</p>

<ol>
<li>Tell us what kind of study would convince you that using Befunge <em>didn't</em> make programmers more productive.</li>
<li>Then tell us what kind of study would convince you that version control didn't either.</li>
</ol>

<p>If your answer to the second question is is, "Nothing ever could," then version control is an article of faith for you, and there's no point arguing further [2]. If your answer to the second is different from your answer to the first, please tell us why.</p>

<p>[1] Full disclosure: Jordi and I co-authored <a href="http://www.drdobbs.com/tools/tools-for-teams-a-survey-of-web-based-so/220301068">a study of web-based software project portals</a>. And either way, we hope you have a happy and productive 2013.</p>

<p>[2] This request is inspired by Karl Popper's notion of <a href="http://en.wikipedia.org/wiki/Falsificationism">falsifiability</a>: a claim is only scientific if there is some way to prove it wrong.</p>
]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>457</wp:post_id>
		<wp:post_date>2012-12-30 13:19:16</wp:post_date>
		<wp:post_date_gmt>2012-12-30 21:19:16</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>why-we-need-evidence</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="questions"><![CDATA[Questions]]></category>
		<category domain="category" nicename="uncategorized"><![CDATA[Uncategorized]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wpas_done_all</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>4289</wp:comment_id>
			<wp:comment_author><![CDATA[Zack]]></wp:comment_author>
			<wp:comment_author_email>zackw@panix.com</wp:comment_author_email>
			<wp:comment_author_url>http://www.owlfolio.org/</wp:comment_author_url>
			<wp:comment_author_IP>76.247.182.73</wp:comment_author_IP>
			<wp:comment_date>2012-12-30 17:47:23</wp:comment_date>
			<wp:comment_date_gmt>2012-12-31 01:47:23</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[I have spent nearly my entire computer-industry career working on large, complicated software (10MLOC range) with multi-decade revision histories.  Based on that experience, I hypothesize that version control makes it easier to fix bugs because it reveals how the code got to be the way it is.  Specifically, if you're looking at some code that seems wrong, you dig into revision history and find all the <i>other</i> code that was changed at the same time.  That often reveals what the person who made the suspicious code the way it is thought they were doing.

So, here's a concrete experiment that should test the value of version control.  Take one of those 10MLOC, multi-decade revision history projects.  Pick a couple dozen known, reproducible, but not yet diagnosed bugs in that project.  Have someone who regularly works on that project screen them and make sure they all should be roughly the same difficulty to analyze and fix.  Then randomly divide the bugs into two groups and assign them to separate teams of programmers without prior experience on the project.  One team gets access to the VCS as it is normally used.  The other team can only look at the source code to the most recently released version of the program.  Both teams are allowed to look at the project's bug tracking system.  Measure how long it takes each team to come up with candidate fixes for each bug.  Then, give all the fixes back to the person who screened the bugs and have them review all of them for errors.  If VCSes are worthwhile, the team with access to the VCS should be able to work faster and should make fewer errors.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";d:1356918443.1273479461669921875;s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>4286</wp:comment_id>
			<wp:comment_author><![CDATA[Laurent Bossavit]]></wp:comment_author>
			<wp:comment_author_email>laurent.tc@bossavit.com</wp:comment_author_email>
			<wp:comment_author_url>http://leanpub.com/leprechauns</wp:comment_author_url>
			<wp:comment_author_IP>81.64.199.1</wp:comment_author_IP>
			<wp:comment_date>2012-12-30 16:22:39</wp:comment_date>
			<wp:comment_date_gmt>2012-12-31 00:22:39</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[There are many kinds of evidence; not all of it comes in the Gold Standard of medical research, placebo-controlled randomized and double-blind trial experiments. "Everyone is using it" can be valid evidence, even in the absence of Gold Standard experiments.

(Here's an article which hints at a reason why: http://www.bmj.com/content/327/7429/1459)

More to the point, the role of evidence-based research on software development is NOT to seek positive or negative evidence for arbitrary coarse-grained claims such as "TDD is better than model-driven" or "version control makes you more productive" or "Befunge makes you less productive".

Research isn't about proving arbitrary claims right or wrong, it is about identifying reliable regularities in our experience and inferring cause-effect relations in the world. It's as much about asking the right questions as it is about getting the answers right.

We don't really care about Befunge, but we may care about investigating the role of some PL features, such as a mechanism for procedural abstraction, in determining how easily, in general, a programmer will carry out a given task.

It's useful to know that programming languages are only a minor source of the reliable regularities we observe when we look at the practice of software development (the scope of "software engineering"). The greater source of regularities is going to be the people who practice it, and so for instance relating "procedural abstraction" to already-known psychological mechanisms such as "chunking" will jump-start any effort at experimental design quite effectively.

So, observing that Befunge doesn't have procedural abstraction, and observing that chunking helps humans at many kinds of cognitive tasks, is evidence suggestive that humans will suck at writing Befunge programs. It's not too hard to find corroborating evidence, such as the number of Befunge samples on RosettaCode.

We can do the same for version control. We break it down into component features: providing a history of past modifications to a program; providing diffs between revisions of a program; providing a reliable mechanism for distribution of code changes within a team; providing a mechanism for the detection of conflicting changes; etc.

Then we turn to the major source of regularities - the programmers writing the code - and we examine hypotheses on why these features may help or hinder. Programmers have limited memory; programmers make mistakes when copying groups of files or intra-file change sets "manually"; programmers working separately may make inconsistent changes to the same part of a program; etc.

There isn't one question here, to be settled by one study, but many questions to be investigated in many small experiments.

These many small experiments may not bolster the "obvious" fact that version control helps programmers, and that's not the point. What these many experiments might do is provide us with vital clues as to how these various concepts play together, and (maybe) lead us on a faster path to improved version control tools. (Faster, I mean, than the current way of industry-wide trial-and-error with a series of products whose features were based on designers' personal prejudices. But that's a "maybe" - it's also possible that a market ecosystem selects the best features faster than systematic research would.)

I for one would love to find out how (and how much) programmers *actually use* the versioning features of version control tools. I wouldn't be hugely surprised to find that programmers only rarely look at past versions of their code. (If programmers really trusted to version control to keep old code around, there wouldn't be so much "let me comment this out" instead of outright deletions.) You could study this unobtrusively by instrumenting existing version control setups.

On the other hand, it's clear that the "reliably distribute my changes to other people on the team" feature is a major win over the alternatives, such as editing a shared network folder (which, however, I know for a fact some people actually do instead of using VC). Network shares sort of work, but fall short at handling a few key events which are a big deal to programmers. Again, I have vague hunches around this topic, but an actual study would be interesting; although here it's harder to think what to observe and how.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";d:1356913359.8986051082611083984375;s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>4285</wp:comment_id>
			<wp:comment_author><![CDATA[Luis Pedro Coelho]]></wp:comment_author>
			<wp:comment_author_email>luis@luispedro.org</wp:comment_author_email>
			<wp:comment_author_url>http://luispedro.org</wp:comment_author_url>
			<wp:comment_author_IP>83.99.17.48</wp:comment_author_IP>
			<wp:comment_date>2012-12-30 16:17:40</wp:comment_date>
			<wp:comment_date_gmt>2012-12-31 00:17:40</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[1. Sure, but it's the best we have in 99% of our decisions. Note that I added "rough empiricism," but which I meant things like surveys, observational studies, case studies, &amp;c

Yes, this can lead to many mistakes, but almost all scientific progress pre-1950s or so was done in this mode and we did get somewhere.

It also gets us homeopathy.

2. Most of those public health studies are awful. Low N, lots of cofounders, &amp;c. If N is high, they're most often observational, which just makes it more like econometrics (although econometrics has higher standards than public health, sadly; it's also easier). I would call many of those "rough empiricism" at best. Which is why we have so little knowledge of the effects of diet/exercise.

There is more consensus on exercise, which is actually much more negative than is typically thought. I guess this supports your view: we thought exercise was great, because we saw that no physical activity is very harmful so we assumed that a lot of physical activity is good (this is a fallacy). Then we studied it and it's actually not that great (once you get past a fairly low threshold, there is little effect; once you overdo it, you get into negative effects).

But try to read up on which diet plan is best to lose weight on and it's not even close to a consensus. You'll get no help from the scientific literature (don't read the conclusions in the abstracts, which tend to over interpret the data, read the data tables with a critical eye and come away underwhelmed with conviction). Finding out which diet plan is best would actually be a public good worth 500 million dollars or even 10 times more (100 times more?), but I don't expect it will be done in the next few decades.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>4281</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";d:1356913060.845344066619873046875;s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>4282</wp:comment_id>
			<wp:comment_author><![CDATA[gvwilson]]></wp:comment_author>
			<wp:comment_author_email>gvwilson@third-bit.com</wp:comment_author_email>
			<wp:comment_author_url>http://third-bit.com/</wp:comment_author_url>
			<wp:comment_author_IP>99.231.121.18</wp:comment_author_IP>
			<wp:comment_date>2012-12-30 15:41:40</wp:comment_date>
			<wp:comment_date_gmt>2012-12-30 23:41:40</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[@Marcos And yet we can and do study the benefits (or lack thereof) of test-driven development and pair programming, and we do it quantitatively...]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>4277</wp:comment_parent>
			<wp:comment_user_id>2</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";d:1356910900.4068279266357421875;s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:8:"gvwilson";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>4283</wp:comment_id>
			<wp:comment_author><![CDATA[Luis Pedro Coelho]]></wp:comment_author>
			<wp:comment_author_email>luis@luispedro.org</wp:comment_author_email>
			<wp:comment_author_url>http://luispedro.org</wp:comment_author_url>
			<wp:comment_author_IP>83.99.17.48</wp:comment_author_IP>
			<wp:comment_date>2012-12-30 15:42:03</wp:comment_date>
			<wp:comment_date_gmt>2012-12-30 23:42:03</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[@marcos,

99% of our decisions do not have double-blind studies behind them. It doesn't mean that it's all faith/superstition. This is the Nirvana fallacy: perfect certainty is impossible, therefore all knowledge is impossible.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";d:1356910923.332726001739501953125;s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>4281</wp:comment_id>
			<wp:comment_author><![CDATA[gvwilson]]></wp:comment_author>
			<wp:comment_author_email>gvwilson@third-bit.com</wp:comment_author_email>
			<wp:comment_author_url>http://third-bit.com/</wp:comment_author_url>
			<wp:comment_author_IP>99.231.121.18</wp:comment_author_IP>
			<wp:comment_date>2012-12-30 15:39:40</wp:comment_date>
			<wp:comment_date_gmt>2012-12-30 23:39:40</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[1. Personal experience has, over the years, convinced a lot of people to believe in things that turned out not to be true.

2. I agree that playing with monetary policy would make for expensive experiments, but we routinely study the effects of diet or exercise on long-term health: it isn't cheap or easy, but the benefits outweigh the costs.

3. I hope everyone realizes that I actually *do* believe that version control is beneficial (wouldn't work on a project that didn't use it). What I'm really trying to do is find out what people will accept as proof, or conversely, what they would accept as *disproof* of something most people believe in.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>4272</wp:comment_parent>
			<wp:comment_user_id>2</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";d:1356910780.20361804962158203125;s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:8:"gvwilson";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>4277</wp:comment_id>
			<wp:comment_author><![CDATA[marcos]]></wp:comment_author>
			<wp:comment_author_email>MAURELIO1234@GMAIL.COM</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>85.169.93.153</wp:comment_author_IP>
			<wp:comment_date>2012-12-30 15:04:43</wp:comment_date>
			<wp:comment_date_gmt>2012-12-30 23:04:43</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[@Luis,

What's the difference between "faith/superstition" and "personal experience, reasoning and rough empirism"?

Ahh, "faith/superstition" is a "personal experience,reasoning and empirism" that differs from mine ;)


@gvwilson,

I think the problem here is trying to find "proofs" for things that live in the real world. You can't, because proofs exist only in the ideal mathematical world. If you talk about evidence, well, every single project that used VCS and that complete successfully is an evidence for that.

Yes, there are no proofs that VCS work, but there's no point in looking for one in the first place!]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";d:1356908683.7174599170684814453125;s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>4539</wp:comment_id>
			<wp:comment_author><![CDATA[Sheila]]></wp:comment_author>
			<wp:comment_author_email>shekay@pobox.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>198.175.55.5</wp:comment_author_IP>
			<wp:comment_date>2013-01-02 08:36:36</wp:comment_date>
			<wp:comment_date_gmt>2013-01-02 16:36:36</wp:comment_date_gmt>
			<wp:comment_content><![CDATA["Tell us what kind of study would convince you that using Befunge didn’t make programmers more productive."

This depends on the claim. I can see at least two.

1. Learning Befunge and doing a project in it will make someone a better programmer afterwards. 

2. A programmer will be more productive if the programmer uses Begunge for a project than if the programmer had used another language.


You could treat claim 1 similarly to claims made for teaching methods and curricula. When I was a student we had a class in programming languages, and we did projects in each type of language. Prolog, ml, Smalltalk. Someone decided that class would be a cs requirement. How?

For claim 2, you pick metrics that define productivity on a project, you try and pick teams of people with equivalent experience. It would be more fair to pick a project that fits use of that type of language and also to pick a similar language. I'm not sure what I would do for Befunge, but for a different area, I might want to see Erlang versus Stackless for a dispatch system.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";d:1357144596.736670017242431640625;s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>4444</wp:comment_id>
			<wp:comment_author><![CDATA[Luca Minudel]]></wp:comment_author>
			<wp:comment_author_email>mymailgateway-blogcomments@yahoo.it</wp:comment_author_email>
			<wp:comment_author_url>http://blogs.ugidotnet.org/luKa/</wp:comment_author_url>
			<wp:comment_author_IP>213.89.225.3</wp:comment_author_IP>
			<wp:comment_date>2013-01-01 07:33:33</wp:comment_date>
			<wp:comment_date_gmt>2013-01-01 15:33:33</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[In my opinion having an empirical evidence that Version Control make programmers more productive would be useful.
Because that would help me to base my professional decisions on proven facts as well as sound experience instead of faith, myths, cults, superstitions, ideology or current trends/fashion. Would be useful also if it reveals why and reveals new insights about it.


I wonder if "Version Control make programmers more productive" is an enough specific question to be proved or disproved.
And if the answer can change substantially in different real contexts and circumstances (i.e. if the characteristic of the version control tool available to the team match the needs of the specific project or not;  if the programmers in the team actually use vc properly for the project needs or if instead they misuse/overuse some tool's feature; if the vc is used to enable other practices like for example delta-debugging on code versions, continuous integration, continuous delivery, or if not;  etc.)


On the other side many important advancements in Computer Science originates from conjectures that are not totally proved even today (i.e. the the Church–Turing conjecture, P ≠ NP problem, or the Brewer's conjecture). Can a repertoire of criteria to assess the usefulness of Version Control for a team in their current specific context and circumstances be more useful and practical then a general theory?


I also wonder  where is the boundary between solid experience and faith (or myths, cults, superstitions, ideology, current trends/fashion) ?  Programmers in professional software production have to deal every day with many unknowns, uncertainties and risks, and some of those will remain unknowns also for science for the remaining part of their professional life.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";d:1357054414.3361499309539794921875;s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>4391</wp:comment_id>
			<wp:comment_author><![CDATA[Lorin Hochstein]]></wp:comment_author>
			<wp:comment_author_email>lorinh@gmail.com</wp:comment_author_email>
			<wp:comment_author_url>http://lorinhochstein.org</wp:comment_author_url>
			<wp:comment_author_IP>173.79.103.100</wp:comment_author_IP>
			<wp:comment_date>2012-12-31 17:40:22</wp:comment_date>
			<wp:comment_date_gmt>2013-01-01 01:40:22</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[I think it's important to keep in mind that the goals of scientists and engineers are different, so the type of research they do is also different. Scientists want to understand the nature of reality, engineers want to know things like "Will X work? Is it better to do Y or Z?" and science has not yet advanced to the point where we can figure out the right answer from first principles.

This difference is covered in detail in "What Engineers Know and How They Know It" by Vincenti. One example is a set of empirical engineering studies that looked at different propeller shapes. From a cause-effect perspective, the studies were useless, the kind of study that no physicist would ever find value in. But, from the point of view of engineers who were building airplanes, it was useful, because they had to pick a propeller shape to build an airplane.

Ultimately, software developers need to make decisions about technologies. Yes, empirical studies that provide decision support for those narrow choices will be of no interest in twenty years, but those developers need to make these types of decisions today, and I think there's a role in doing these types of studies to help them.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>4286</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";d:1357004422.5060789585113525390625;s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>4516</wp:comment_id>
			<wp:comment_author><![CDATA[Mike Woodhouse]]></wp:comment_author>
			<wp:comment_author_email>mikewoodhouse@gmail.com</wp:comment_author_email>
			<wp:comment_author_url>http://grumpyop.wordpress.com</wp:comment_author_url>
			<wp:comment_author_IP>160.83.42.137</wp:comment_author_IP>
			<wp:comment_date>2013-01-02 03:24:06</wp:comment_date>
			<wp:comment_date_gmt>2013-01-02 11:24:06</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Is programmer productivity necessarily the major value that we're hoping to increase by using version control?

Could examining some minimal case allow a kind of "proof by induction"? 

Posit a single back-up (a zip file, maybe) of a single source code file developed by a single developer on one computer. Can that ever have value? What if that source file gets deleted irretrievably? Unzipping the backup ought to be an improvement on rewriting from memory for all but the most trivial cases.

Or have I completely missed the point?]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";d:1357125846.59599399566650390625;s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>4504</wp:comment_id>
			<wp:comment_author><![CDATA[Konrad Hinsen]]></wp:comment_author>
			<wp:comment_author_email>konrad.hinsen@fastmail.net</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>82.66.102.10</wp:comment_author_IP>
			<wp:comment_date>2013-01-02 00:24:43</wp:comment_date>
			<wp:comment_date_gmt>2013-01-02 08:24:43</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Good anecdotes are worth more than tons of sloppy research studies. Premature quantification is the root of much evil.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>4372</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";d:1357115083.8372399806976318359375;s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>4503</wp:comment_id>
			<wp:comment_author><![CDATA[Konrad Hinsen]]></wp:comment_author>
			<wp:comment_author_email>konrad.hinsen@fastmail.net</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>82.66.102.10</wp:comment_author_IP>
			<wp:comment_date>2013-01-02 00:23:11</wp:comment_date>
			<wp:comment_date_gmt>2013-01-02 08:23:11</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[First of all, I agree with every word of Luis' comments, which saves me a lot of typing :-)

The two arguments I tend to give to convince people to try out version control for their own work are

1) Almost everyone who writes substantial amounts of text that evolve (program code, scientific articles, theses, ...) sooner or later invents their own versioning scheme, based on more or less sophisticated file naming schemes and personal notes.

2) Everyone I know who ever tried version control is still using it. Most of these people find ever more applications for version control.

While both arguments are based on anecdotical evidence, it wouldn't be difficult or expensive to back them up by poll-based evidence or something similar.

These arguments may not convince managers, who care about things like productivity or software quality that no one knows how to quantify, but I am not trying to convince managers anyway.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";d:1357114991.629971981048583984375;s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>4581</wp:comment_id>
			<wp:comment_author><![CDATA[Irwin Kwan]]></wp:comment_author>
			<wp:comment_author_email>ihkwan@gmail.com</wp:comment_author_email>
			<wp:comment_author_url>http://irwinhkwan.wordpress.com</wp:comment_author_url>
			<wp:comment_author_IP>128.193.8.40</wp:comment_author_IP>
			<wp:comment_date>2013-01-02 17:45:05</wp:comment_date>
			<wp:comment_date_gmt>2013-01-03 01:45:05</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[I enjoyed Laurent's response, as well as Lorin's reply, as they both highlight why scientific research and software engineering are such at odds with each other.

The "theory" (which is really more like practice than theory) of why version control works is in the sum of its many parts - as Laurent mentioned, it is the ability to revert back multiple versions, the ability to distribute changes, the ability to merge and resolve conflicting portions with automated support, and so forth. They map to characteristics of humans that we know and that we have discovered. Each principal component of a version control system is designed to appeal in some way to human limits of cognition.

It would be possible to design an experiment that identifies the difference in task completion time between merging file changes manually if two people edit the same file at the same time, and automatically if two people edit the same file at the same time. However, I believe that the result of this experiment is obvious.

Likewise, one could devise an experiment to illustrate the difference in reliability (with respect to changes lost) if multiple people manage files manually, perhaps using a single-locking broadcast mechanism over email (i.e. "I am locking the foo.c file" ... "I am unlocking the foo.c file"), versus a system that supported single-locking broadcasting automatically (it would not allow you to lock a file if someone else had locked it). Again, the result of this experiment is pretty obvious.

The number of "obvious" principled results, when broken down with respect to version control add up quickly, whereas the broken down principles for using Befunge do not add up as quickly and as readily. With VCS, we can say that "automatic merging is faster than manual merging" with reasonable confidence. With Befunge, we cannot say that "Quad-directional text is easier for humans to read than bi-directional text". There is no design principles for the language that appear to encourage productivity or quality.

This "reductionist" approach might be one reason why scientists and engineers are therefore at some odds. The scientists, out of necessity (and cost limitations), try to reduce as much as possible because it is extremely difficult to gather enough samples if your phenomena is too large (you begin to lose the ability to control confounds). Engineers cannot afford to do this for the most part, since they have an actual job, and therefore simply ask, "Does this work for me?"

Finally, while it would be nice to get hard proof that VCS does work, I don't think any funding agency would fund such research, and even if you did secure funding for it, I can't imagine any software engineering conference treating a paper whose research contribution is "Developers with version control were able to build higher-quality software, faster, than developers without version control" seriously.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>4286</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";d:1357177505.04881000518798828125;s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>4780</wp:comment_id>
			<wp:comment_author><![CDATA[Tavish Armstrong]]></wp:comment_author>
			<wp:comment_author_email>tavisharmstrong@gmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>99.237.113.58</wp:comment_author_IP>
			<wp:comment_date>2013-01-04 13:13:07</wp:comment_date>
			<wp:comment_date_gmt>2013-01-04 21:13:07</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Would anybody here contribute to a wiki of "crowd-designed" research studies if it existed?]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";d:1357333987.55883502960205078125;s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>4933</wp:comment_id>
			<wp:comment_author><![CDATA[Graham Lee]]></wp:comment_author>
			<wp:comment_author_email>graham@iamleeg.com</wp:comment_author_email>
			<wp:comment_author_url>http://twitter.com/secboffin</wp:comment_author_url>
			<wp:comment_author_IP>86.29.188.175</wp:comment_author_IP>
			<wp:comment_date>2013-01-06 02:57:09</wp:comment_date>
			<wp:comment_date_gmt>2013-01-06 10:57:09</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[My first problem with formulating the questions you described was this: I'm not sure we have a specific, agreed, measurable definition of what "programmer productivity" is. My academic background is in Physics, there all of the quantities one might measure are defined as are the units in which they're expressed. So if I say "the speed of light will be faster in one arm of the interferometer", we don't have to have a philosophical argument about what I mean by "speed".

However, if I try to go for a negative definition of productivity, by claiming that some things are not contributions, the I believe can construct the questions needed.

Hypothesis: programmers using version control spend no less time integrating the work of their peers into a body of code than those who aren't using version control.

Hypothesis: programmers using version control make the same rate of version-related mistakes in each build (failing to include expected changes, including unwanted changes, regressing previously-included changes) as those who do not use version control.

Because I know it'll cone up in replies despite being off-topic: yes, experiments designed to test those hypotheses will potentially have threats to their validity. The non-VCS programmers should be as comfortable with their workflow as the with-VCS programmers, and working on problems of similar complexity. Other factors-choice of language, IDE, management and so on-need to be controlled, too.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";d:1357469829.2679688930511474609375;s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>5078</wp:comment_id>
			<wp:comment_author><![CDATA[Benjamin Meyer]]></wp:comment_author>
			<wp:comment_author_email>ben@meyerhome.net</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>4.79.245.132</wp:comment_author_IP>
			<wp:comment_date>2013-01-07 10:10:27</wp:comment_date>
			<wp:comment_date_gmt>2013-01-07 18:10:27</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[In fact your experiment has already been done in the wild probably by many companies.  At lease one example is while working at Trolltech we released each version of Qt with source code.  External developers only had access to the source code for specific releases while internal developers had access to the whole revision control system.  Customers would report bugs and while they could specify that it was introduced in version X they didn't know the commit.  Sometimes they would have a patch and as for data you could compare the number of times the patch was accepted outright v.s. replaced with a patch written in house.

(From my experience the would often submit a patch that they believe solves the problem, but when looking up the original change in the revision control system the change could have been bigger than just that one spot and the patch actually introduces a bug by only change that one spot and not all of it.  Also the commit message can provided information about why the original change was made giving context which the external user does not have which ultimately would result in both a better patch and less time working on it.)

Overall I like your experiment, one of the problems with revision control is how it encompass various capabilities. For the above there is I would expect existing companies that could be plugged into a study today.  Another areas that could be broken out would be Code review.  Give someone a patch + access to the whole revision control or give someone a tarball with a description of the change and see how well code reviews can occur.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>4289</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";d:1357582227.8238089084625244140625;s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>6016</wp:comment_id>
			<wp:comment_author><![CDATA[Geert Bollen]]></wp:comment_author>
			<wp:comment_author_email>neverworkintheory@geert.firstreef.net</wp:comment_author_email>
			<wp:comment_author_url>http://about.me/geertbollen</wp:comment_author_url>
			<wp:comment_author_IP>78.146.60.152</wp:comment_author_IP>
			<wp:comment_date>2013-03-22 05:47:15</wp:comment_date>
			<wp:comment_date_gmt>2013-03-22 12:47:15</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[I come to this conversation late, but there is a class of coarse-grained research questions for which I would consider evidence extremely useful to software practitioners. It is this: "Does Xyz have an effect in the first place?"

Adoption or even long-term survival in the market is an unreliable proxy for this question given human psychology.

But with reliable (negative) evidence, I could at a stroke ignore all advocates of Xyz and their claims in my quest to discover practices that might be helpful in my context. Would that be useful? You bet it would!

It might even stop the software field chasing its tail quite as much as it does today. Only trouble is, generating negative results isn't a terribly popular occupation.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>4286</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";d:1363956435.9725799560546875;s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>5645</wp:comment_id>
			<wp:comment_author><![CDATA[Reg]]></wp:comment_author>
			<wp:comment_author_email>pulaskite@yahoo.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>173.218.207.187</wp:comment_author_IP>
			<wp:comment_date>2013-01-12 16:25:44</wp:comment_date>
			<wp:comment_date_gmt>2013-01-13 00:25:44</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Can you point to empirical studies of the value of correct spelling, grammar and punctuation?  Perhaps Dr. Johnson made a mistake by creating the first English language dictionary and standardizing spelling.  The texting generation certainly doesn't seem to think that it matters for anyone other than loosers.

How about comments and variable naming?  Are i, ii, iii, j, jj, jjj etc reasonable choices for variable names?

Version control is really just communication.  Rather like a lab notebook.

The value depends entirely upon the abilities of the writer and the reader. To "objectively" measure it, you have to assess the participants.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";d:1358036744.892654895782470703125;s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>4272</wp:comment_id>
			<wp:comment_author><![CDATA[Luis Pedro Coelho]]></wp:comment_author>
			<wp:comment_author_email>luis@luispedro.org</wp:comment_author_email>
			<wp:comment_author_url>http://luispedro.org</wp:comment_author_url>
			<wp:comment_author_IP>83.99.17.48</wp:comment_author_IP>
			<wp:comment_date>2012-12-30 14:25:35</wp:comment_date>
			<wp:comment_date_gmt>2012-12-30 22:25:35</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[There is a difference between falsifiable in theory and in practice. In theory, many things are actually really easy to prove or disprove.

Does monetary policy matter for economic growth? Just randomize monetary decisions for a number of countries, 100 or so, and measure growth in a period of 5 to 10 years. I don't think, however, that even the British Empire at its peak would get away with this, even if Queen Victoria was so inclined. Instead, we are left with econometrics.

Take 200 programming teams, assign them the same task, have half use automatic version control and force the others to use the code_backup_2012_12_23.zip system or anything else homegrown (including just "this is the current code, we save no other version"). Two or three years later, measure bugs and functionality. That would be hard data either way. Now, your task is to get the 500 million dollars that it would take to do this project :)

*

At the end of this post is a false dichotomy. There is something between faith/superstition and scientifically proven, which is personal experience, reasoning, and rough empiricism.

I've never met anyone who, having used version control for a while (past the point where it was new), had to do without and said "Oh, I feel so much more productive". Could be that we are all wrong in preferring git to manual code backups; could be because, nowadays, if you work in any shop that doesn't use version control, people will laugh at you; sure. But it doesn't mean that the value of the collective personal experience is zero and this is the same as homeopathy (many people swear by it).

It's also perfectly valid to say "even if automatic version control doesn't make me more productive, I really prefer using it, so I'll continue to do so" :)]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";d:1356906335.616653919219970703125;s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>4365</wp:comment_id>
			<wp:comment_author><![CDATA[Arieh Bibliowicz]]></wp:comment_author>
			<wp:comment_author_email>vainolo@gmail.com</wp:comment_author_email>
			<wp:comment_author_url>http://www.vainolo.com</wp:comment_author_url>
			<wp:comment_author_IP>132.68.1.192</wp:comment_author_IP>
			<wp:comment_date>2012-12-31 11:24:19</wp:comment_date>
			<wp:comment_date_gmt>2012-12-31 19:24:19</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[I found this recently published article: http://mansci.journal.informs.org/content/46/6/745.abstract (I hope you can access the full version). They sampled 43 projects in a "Fortune 100" company, trying to find a correlation between a number of CMM parameters and the quality of the software. Version control comes in the "tools" section. Quoting page 753: "In our analysis, we do not ﬁnd the usage of tools
playing a signiﬁcant role in explaining the quality or productivity. We discussed these results with the managers at our research site and learned that the usage of tools had mixed effects on the software projects. In some projects, version control and documentation tools were efﬁciently used and provided better control on the software management, thus increasing productivity and quality. In other projects, some design and reengineering tools led to higher
learning costs and quality problems as a result of code mismatch with the tools". Interesting.

On a personal note, I worked once in a project that used ClearCase as its VCS. It was the only time in my life where using a VCS reduced my productivity, since it took me hours to checkout a version, and I had to do it a lot.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";d:1356981859.12897491455078125;s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>4372</wp:comment_id>
			<wp:comment_author><![CDATA[Marco]]></wp:comment_author>
			<wp:comment_author_email>marco.gaddoni@gmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>151.42.46.61</wp:comment_author_IP>
			<wp:comment_date>2012-12-31 12:36:07</wp:comment_date>
			<wp:comment_date_gmt>2012-12-31 20:36:07</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[everybody can be right until it  tested;
we can do, and it is usefull, test in double blind 
with chirurgic operations (see http://en.wikipedia.org/wiki/Sham_surgery).
why base our decision on anedoctes ?]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";d:1356986167.6440899372100830078125;s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>5753</wp:comment_id>
			<wp:comment_author><![CDATA[Andrew McDowell]]></wp:comment_author>
			<wp:comment_author_email>andrew-mcdowell@o2.co.uk</wp:comment_author_email>
			<wp:comment_author_url>http://www.mcdowella.demon.co.uk</wp:comment_author_url>
			<wp:comment_author_IP>94.195.253.182</wp:comment_author_IP>
			<wp:comment_date>2013-02-03 06:09:43</wp:comment_date>
			<wp:comment_date_gmt>2013-02-03 14:09:43</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[I think version control is a particularly hard example to test because it is most valuable in recovering from rare accidents. I also think that it would be hard to convince people to stop requiring it because they would worry about those rare accidents. Possibly you could argue for its benefits by running experiments on how easy it was to recover from staged accidents and find out how often it was used in this way by looking in version control logs - much as you improve aircraft safety using a combination of test flights and black box analysis to learn as much as possible with as small a cost in lives as possible. On Friday I made a minor modification and found that the resulting script created a huge number of errors. Looking at the SVN log I saw that the errors were due to changes made by a member of staff not familiar with that script, and not in a position to test their changes easily. I reverted the changes, put in my changes, and later contacted that member of staff so that I could make and test the changes they needed. This was much easier than debugging the version they left in SVN.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";d:1359900583.5067389011383056640625;s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
		<title>MSR 2013 - Call for Papers</title>
		<link>http://www.neverworkintheory.org/?p=474</link>
		<pubDate>Tue, 29 Jan 2013 21:37:15 +0000</pubDate>
		<dc:creator>gvwilson</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=474</guid>
		<description></description>
		<content:encoded><![CDATA[<strong>10th Working Conference on Mining Software Repositories</strong>
May 18-19, 2013. San Francisco, CA, USA
<a href="http://2013.msrconf.org">http://2013.msrconf.org</a>

Co-located with the 35th ACM/IEEE International Conference on Software Engineering (ICSE 2013)
Sponsored by IEEE TCSE and ACM SIGSOFT

NEW IN 2013!
<ul>
	<li>Data papers for describing data sets curated by their authors and making them available to the research community</li>
	<li>Practice papers for experiences of applying mining repository algorithms in an industry/open source organization context</li>
	<li>Microsoft Surface tablet with Windows RT as prize for the best Mining Challenge, sponsored by Microsoft Research.</li>
</ul>
IMPORTANT DATES
<ul>
	<li>Research/Practice abstracts: Feb 8, 2013</li>
	<li>Research/Practice papers: Feb 15, 2013</li>
	<li>Data papers: Feb 15, 2013</li>
	<li>Challenge papers: Mar 04, 2013</li>
	<li>Author notification: Mar 15, 2013</li>
	<li>Camera-ready copy: Mar 29, 2013</li>
	<li>Conference: May 18-19, 2013</li>
</ul>
All submission deadlines are 11:59 PM (Pago Pago, American Samoa) on the dates indicated.

CALL FOR PAPERS

Software repositories such as source control systems, archived communications between project personnel, and defect tracking systems are used to help manage the progress of software projects. Software practitioners and researchers are recognizing the benefits of mining this information to support the maintenance of software systems, improve software design/reuse, and empirically validate novel ideas and techniques. Research is now proceeding to uncover the ways in which mining these repositories can help to understand software development and software evolution, to support predictions about software development, and to exploit this knowledge concretely in planning future development. The goal of this two-day working conference is to advance the science and practice of software engineering via the analysis of data stored in software repositories.

This year, we will solicit three tracks of papers: Research, Practice, and Data. As in previous MSR editions, there will be a Mining Challenge on Stack Overflow data and a special issue of best MSR papers in the Empirical Software Engineering journal.

Research papers: Research papers can be short papers (4 pages) and full papers (10 pages). Short research papers should discuss controversial issues in the field, or describe interesting or thought provoking ideas that are not yet fully developed. Accepted short papers will present their ideas in a short lightning talk. Full research papers are expected to describe new research results, and have a higher degree of technical rigor than short papers.

Practice papers: (New!) Practice papers should report experiences of applying mining repository algorithms in an industry/open source organization context. Practice papers aim at reporting positive or negative experiences of applying known algorithms, but adapting existing algorithms or proposing new algorithms for practical use would be plus. Practice papers also can be short papers (4 pages) and full papers (10 pages).

Data papers: (New!) We want to encourage researchers to share their data. Data papers should describe data sets curated by their authors and made available to others. They are expected to be at most 4 pages long and should address the following: description of the data, including its source; methodology used to gather it; description of the schema used to store it, and any limitations and/or challenges of this data set. The data should be made available at the time of submission of the paper for review, but will be considered confidential until publication of the paper. Further details about data papers are available on the conference website.

Mining challenge: In the Mining Challenge, we invite researchers to demonstrate the usefulness of their mining tools on preselected software repositories and summarize their findings in a challenge report (4 pages). Please visit our Challenge Web Site for details about the Mining Challenge. This year, the challenge is on the Stack Overflow data. We provide the dump for the Stack Overflow web service and you should use your brain, tools, computational power, and magic to uncover interesting findings related to it.

EMSE SPECIAL ISSUE

A selection of the best research papers will be invited for consideration in a special issue of the journal, Empirical Software Engineering (EMSE), edited by Springer.

TOPICS

Papers may address issues along the general themes, including but not limited to the following:
<ul>
	<li>Analysis of software ecosystems and mining of repositories across multiple projects</li>
	<li>Models for social and development processes that occur in large software projects</li>
	<li>Prediction of future software qualities via analysis of software repositories</li>
	<li>Models of software project evolution based on historical repository data</li>
	<li>Characterization, classification, and prediction of software defects based on analysis of software repositories</li>
	<li>Techniques to model reliability and defect occurrences</li>
	<li>Search-driven software development, including search techniques to assist developers in finding suitable components and code fragments for reuse, and software search engines</li>
	<li>Analysis of change patterns and trends to assist in future development</li>
	<li>Visualization techniques and models of mined data</li>
	<li>Techniques and tools for capturing new forms of data for storage in software repositories, such as effort data, fine-grained changes, and refactoring</li>
	<li>Characterization of bias in mining and guidelines to ensure quality results</li>
	<li>Privacy and ethics in mining software repositories</li>
	<li>Meta-models, exchange formats, and infrastructure tools to facilitate the sharing of extracted data and to encourage reuse and repeatability</li>
	<li>Empirical studies on extracting data from repositories of large long-lived and/or industrial projects</li>
	<li>Methods of integrating mined data from various historical sources</li>
	<li>Approaches, applications, and tools for software repository mining</li>
	<li>Mining software licensing and copyrights</li>
	<li>Mining execution traces and logs</li>
	<li>Analysis of natural language artifacts in software repositories</li>
</ul>
SUBMISSION

All papers must conform at time of submission to the ICSE/MSR 2013 Formatting Instructions and must not exceed the page limits (research/practice papers: 10 pages; short papers: 4 pages; data papers: 4 pages; challenge reports: 4 pages), including all text, references, appendices and figures. All submissions must be in English and in PDF format.

Papers submitted for consideration should not have been published elsewhere and should not be under review or submitted for review elsewhere for the duration of consideration. ACM plagiarism policies and procedures shall be followed for cases of double submission.

Papers must be submitted electronically through EasyChair using the following URL: <a href="http://easychair.org/conferences/?conf=msr2013">http://easychair.org/conferences/?conf=msr2013</a>

Upon notification of acceptance, all authors of accepted papers will be asked to complete an IEEE Copyright form and will receive further instructions for preparing their camera ready versions. At least one author of each paper is expected to present the results at the MSR 2013 conference. All accepted contributions will be published in the conference electronic proceedings.]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>474</wp:post_id>
		<wp:post_date>2013-01-29 13:37:15</wp:post_date>
		<wp:post_date_gmt>2013-01-29 21:37:15</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>msr-2013-call-for-papers</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="announcements"><![CDATA[Announcements]]></category>
		<category domain="category" nicename="mining"><![CDATA[Mining]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wpas_done_all</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Experimental Assessment of Software Metrics Using Automated Refactoring </title>
		<link>http://www.neverworkintheory.org/?p=488</link>
		<pubDate>Tue, 12 Feb 2013 17:33:08 +0000</pubDate>
		<dc:creator>FelienneHermans</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=488</guid>
		<description></description>
		<content:encoded><![CDATA[<em>Mel Ó Cinnéide, Laurence Tratt, Mark Harman, Steve Counsell, and Iman Hemati Moghadam, <strong><a href="http://tratt.net/laurie/research/pubs/papers/o_cinneide_tratt_harman_counsell__experimental_assessment_of_software_metrics_using_automated_refactoring.pdf">Experimental Assessment of Software Metrics Using Automated Refactoring</a></strong>, ESEM '12, Lund, Sweden.</em>

The impact and applicability of software metrics continues to be a subject of <a href="http://www.neverworkintheory.org/?p=58">debate</a>, especially since there are many metrics that measure similar properties, like cohesion. This raises the question of the extent to which these metrics agree or not.

The interesting idea that this paper proposes is to not only analyze the agreement and disagreement of metrics, but to also investigate how the metrics change on refactored versions of the same code. The authors do so by randomly applying automated refactorings to a code base and observing how these refactorings impact the metrics. By running these automated refactoring analysis, the authors want to distinguish between what they call <em>volatile</em> metrics, those that are easily impacted, and <em>inert</em> metrics that hardly change under refactoring. Furthermore, they want to know what metrics change in relation with one another, are the refactorings that cause one metric to increase, while another (supposedly measuring a similar property) decreases.

They applied their method to 300KLOC of Java code of 8 open source systems and investigated the following five metrics:
<ul>
	<li>Tight Class Cohesion(TCC)</li>
	<li>Lack of Cohesion between Methods (LCOM5)</li>
	<li>Class Cohesion (CC)</li>
	<li>Sensitive Class Cohesion (SCOM)</li>
	<li>Low-level Similarity Base Class Cohesion. (LSCC)</li>
</ul>
Their evaluation shows that LSCC, CC and LCOM5 are all highly volatile metrics: in 99% of the refactorings, these were either increased or decreased. The results, however, were different for the 8 systems under consideration. In one case, for example, all metrics turned out to be volatile. Even when normalizing for relative volatility, the variance remained high.

In a second evaluation, the relationship between two of the cohesion metrics, LSCC and TCC, is explored in more detail. Refatorings where one of those two metrics is lowered, while the other is increased are studied in more detail.

What makes this work so interesting, apart from the cool originality of applying automated refactoring in the context of metrics, is the fact that it changes our perception of metrics. Where we previously assumed that different metrics for cohesion were mainly a matter of taste (and hence debate), this papers finds that metrics can not only differ, but that they can be conflicting in many cases.]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>488</wp:post_id>
		<wp:post_date>2013-02-12 09:33:08</wp:post_date>
		<wp:post_date_gmt>2013-02-12 17:33:08</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>experimental-assessment-of-software-metrics-using-automated-refactoring</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="metrics"><![CDATA[Metrics]]></category>
		<category domain="category" nicename="refactoring"><![CDATA[Refactoring]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wpas_done_all</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>5788</wp:comment_id>
			<wp:comment_author><![CDATA[Willem van den Ende]]></wp:comment_author>
			<wp:comment_author_email>mail@willemvandenende.com</wp:comment_author_email>
			<wp:comment_author_url>http://me.andering.com</wp:comment_author_url>
			<wp:comment_author_IP>89.98.40.39</wp:comment_author_IP>
			<wp:comment_date>2013-02-12 12:42:23</wp:comment_date>
			<wp:comment_date_gmt>2013-02-12 20:42:23</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[do you mean the kind of metrics that are in tools like Sonar, and before that PMD? The problem I have with these metrics, is that they remind me most of the drunk man looking for his lost keys close to the lamp post, because that is where the light shines. The fact that we can measure things like cyclomatic complexities, LCOM and things like that because we can count lines of code and statements, does not mean they are the most effective way of seeing if a refactoring improves the design of existing code.
These days I'm looking more at things like: how fast can a team ship user visible improvements, how many defects are reported back per shipped feature (and what does it cost to fix), are developers happy to work on the code, can they communicate with their stakeholders in terms that are also present in the code (domain concepts etc.).]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";d:1360701743.1287629604339599609375;s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>5838</wp:comment_id>
			<wp:comment_author><![CDATA[Graham]]></wp:comment_author>
			<wp:comment_author_email>graham@iamleeg.com</wp:comment_author_email>
			<wp:comment_author_url>http://blog.securemacprogramming.com</wp:comment_author_url>
			<wp:comment_author_IP>188.222.85.63</wp:comment_author_IP>
			<wp:comment_date>2013-02-27 02:01:34</wp:comment_date>
			<wp:comment_date_gmt>2013-02-27 10:01:34</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[This reminds me of another paper, "Legacy Software Restructuring: Analyzing a Concrete Case" (http://arxiv.org/abs/1210.7138v1, also presented at CSMR 2011). They found that over a few major restructurings of the Eclipse platform, coupling did not always decrease, cohesion did not always increase, and the number of circular references between packages did not always go down.

I don't draw anything specific from either that work or the paper you cite here other than that we don't know that the metrics we use are _necessarily_ useful, either in telling us what we think they tell us about the system or in whether being told those things is itself helpful.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";d:1361959294.6173250675201416015625;s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>5786</wp:comment_id>
			<wp:comment_author><![CDATA[FelienneHermans]]></wp:comment_author>
			<wp:comment_author_email>felienne@gmail.com</wp:comment_author_email>
			<wp:comment_author_url>http://www.felienne.com/</wp:comment_author_url>
			<wp:comment_author_IP>95.99.188.242</wp:comment_author_IP>
			<wp:comment_date>2013-02-12 11:24:11</wp:comment_date>
			<wp:comment_date_gmt>2013-02-12 19:24:11</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Thanks for your comment. This paper does not advocate the use of cohesion metrics or metrics in general or takes the stand that these metrics are more important than goods names. 
It is simply the case that in many software projects metrics are used as an instrument and therefore is it worth to investigate whether they are conflicting or not, in a more serious way than 'anyone knows it'. I totally agree with you that not all software engineering research is useful, but a deeper understanding of the relationship between metrics that are used in practice does not seem like effort wasted to me.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>5785</wp:comment_parent>
			<wp:comment_user_id>28</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";d:1360697051.2091429233551025390625;s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:15:"FelienneHermans";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>5785</wp:comment_id>
			<wp:comment_author><![CDATA[Willem van den Ende]]></wp:comment_author>
			<wp:comment_author_email>mail@willemvandenende.com</wp:comment_author_email>
			<wp:comment_author_url>http://me.andering.com</wp:comment_author_url>
			<wp:comment_author_IP>89.98.40.39</wp:comment_author_IP>
			<wp:comment_date>2013-02-12 10:07:56</wp:comment_date>
			<wp:comment_date_gmt>2013-02-12 18:07:56</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Sounds truly unimpressive. Anyone who's applied metrics to actual codebases knows that many of our favorite metrics are conflicting and that some refactorings impact some more than others.
What is really stupifying is that the researchers apparently fail to understand that good naming (variables/methods/classes or whatever the important concepts in your language of choice are) trumps everything. 
Prior art can be found in Koza's book on genetic programming, where he does some automated refactorings on generated programs. The result is that the programs are slightly less un-understandable, but still pretty cryptic.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";d:1360692477.15871906280517578125;s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
		<title>Halving Fail Rates using Peer Instruction</title>
		<link>http://www.neverworkintheory.org/?p=503</link>
		<pubDate>Fri, 08 Mar 2013 15:46:25 +0000</pubDate>
		<dc:creator>gvwilson</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=503</guid>
		<description></description>
		<content:encoded><![CDATA[Leo Porter, Cynthia Bailey-Lee, and Beth Simon: "<a href="http://db.grinnell.edu/sigcse/sigcse2013/Program/viewAcceptedProposal.pdf?sessionType=paper&amp;sessionNumber=176">Halving Fail Rates using Peer Instruction: A Study of Four Computer Science Courses</a>". <em>Proc. SIGCSE 2013</em>.
<blockquote><em>Peer Instruction (PI) is a teaching method that supports student- centric classrooms, where students construct their own understanding through a structured approach featuring questions with peer discussions. PI has been shown to increase learning in STEM disciplines such as physics and biology. In this report we look at another indicator of student success – the rate at which students pass the course or, conversely, the rate at which they fail. Evaluating 10 years of instruction of 4 different courses spanning 16 PI course instances, we find that adoption of the PI methodology in the classroom reduces fail rates by a per-course average of 61% (20% reduced to 7%) compared to Standard Instruction (SI). Moreover, we also find statistically significant improvements within-instructor. For the same instructor teaching the same course, we find PI decreases the fail rate, on average, by 67% (from 23% to 8%) compared to SI. As an in-situ study, we discuss the various threats to the validity of this work and consider implications of wide-spread adoption of PI in computing programs.
</em></blockquote>
This paper, which has just been presented at SIGCSE 2013 in Denver, may be one of the most significant empirical results we've ever reported. As the abstract says, a specific teaching technique can cut the failure rate in introductory classes by more than half; it also increases self-reported learner satisfaction. To find out more, check out <a href="http://www.peerinstruction4cs.org/">http://www.peerinstruction4cs.org/</a>.]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>503</wp:post_id>
		<wp:post_date>2013-03-08 07:46:25</wp:post_date>
		<wp:post_date_gmt>2013-03-08 15:46:25</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>halving-fail-rates-using-peer-instruction</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="education"><![CDATA[Education]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wpas_done_all</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Comments on Firefox Available for Analysis</title>
		<link>http://www.neverworkintheory.org/?p=508</link>
		<pubDate>Sun, 24 Mar 2013 12:55:22 +0000</pubDate>
		<dc:creator>gvwilson</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=508</guid>
		<description></description>
		<content:encoded><![CDATA[A team of Mozilla developers ran a Reddit <a href="http://www.reddit.com/r/IAmA/comments/19x7up/we_are_the_firefox_user_experience_team_this_is/">"Ask Me Anything" on Firefox</a> two weeks ago. Several thousand comments were submitted, and Blake Winton has now sorted and classified them. It seems like it would be a useful data set for someone doing empirical software engineering research; if you'd like to have a look, please <a href="mailto:greg@mozillafoundation.org">get in touch</a>.]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>508</wp:post_id>
		<wp:post_date>2013-03-24 05:55:22</wp:post_date>
		<wp:post_date_gmt>2013-03-24 12:55:22</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>comments-on-firefox-available-for-analysis</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="announcements"><![CDATA[Announcements]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wpas_done_all</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>A Characteristic Study on Failures of Production Distributed Data-Parallel Programs</title>
		<link>http://www.neverworkintheory.org/?p=518</link>
		<pubDate>Tue, 16 Apr 2013 18:08:23 +0000</pubDate>
		<dc:creator>gvwilson</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=518</guid>
		<description></description>
		<content:encoded><![CDATA[Sihan Li, Hucheng Zhou, Haoxiang Lin, Tian Xiao, Haibo Lin, Wei Lin, and Tao Xie: "<a href="http://research.microsoft.com/apps/pubs/default.aspx?id=185279">A Characteristic Study on Failures of Production Distributed Data-Parallel Programs</a>". <em>Proc. ICSE 2013</em>.
<blockquote><em>SCOPE is adopted by thousands of developers from tens of different product teams in Microsoft Bing for daily web-scale data processing, including index building, search ranking, and advertisement display. A SCOPE job is composed of declarative SQL-like queries and imperative C# user-defined functions (UDFs), which are executed in pipeline by thousands of machines. There are tens of thousands of SCOPE jobs executed on Microsoft clusters per day, while some of them fail after a long execution time and thus waste tremendous resources. Reducing SCOPE failures would save significant resources.</em>

<em>This paper presents a comprehensive characteristic study on 200 SCOPE failures/fixes and 50 SCOPE failures with debugging statistics from Microsoft Bing, investigating not only major failure types, failure sources, and fixes, but also current debugging practice. Our major findings include (1) most of the failures (84.5%) are caused by defects in data processing rather than defects in code logic; (2) table-level failures (22.5%) are mainly caused by programmers' mistakes and frequent data-schema changes while row-level failures (62%) are mainly caused by exceptional data; (3) 93% of fixes do not change data processing logic; (4) there are 8% failures with root cause not at the failure-exposing stage, making current debugging practice insufficient in this case. Our study results provide valuable guidelines for future development of data-parallel programs. We believe that these guidelines are not limited to SCOPE, but can also be generalized to other similar data-parallel platforms.</em></blockquote>
This insightful little paper is a great example of how a small investment in studying how things actually work can beneficially impact where developers focus their effort. A similar fault analysis of (for example) the way novices do joins in SQL, or of how they get list comprehensions in Python wrong, would be very welcome. We look forward to seeing how the team at Microsoft incorporates these findings into the next version of SCOPE.]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>518</wp:post_id>
		<wp:post_date>2013-04-16 11:08:23</wp:post_date>
		<wp:post_date_gmt>2013-04-16 18:08:23</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>a-characteristic-study-on-failures-of-production-distributed-data-parallel-programs</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="qualitative-studies"><![CDATA[Qualitative Studies]]></category>
		<category domain="category" nicename="quantitative-studies"><![CDATA[Quantitative Studies]]></category>
		<category domain="category" nicename="tools"><![CDATA[Tools]]></category>
		<category domain="category" nicename="usability"><![CDATA[Usability]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wpas_done_all</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>First Impressions of MSR</title>
		<link>http://www.neverworkintheory.org/?p=525</link>
		<pubDate>Tue, 04 Jun 2013 16:12:53 +0000</pubDate>
		<dc:creator>gvwilson</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=525</guid>
		<description></description>
		<content:encoded><![CDATA[<em><a href="http://exple.tive.org/blarg/">Mike Hoye</a>, Mozilla's Engineering Community Manager, attended the <a href="http://2013.msrconf.org/">Mining Software Repositories</a> conference for the first time this year. Here are his impressions. </em>

The MSR program is at <a href="http://2013.msrconf.org/">http://2013.msrconf.org/</a> along with links, where possible, to the papers being discussed. Sadly, the IEEE is not in the information-sharing business, but many of the papers can be found linked from <a href="http://2013.msrconf.org/program.php">here</a>. Prof. Gail Murphy opened the talk with a pretty straightforward question: what is developer productivity? Her slides are <a href="https://speakerdeck.com/murphygc/software-development-productivity">here</a>, but they don't really convey how good a talk it was.

The one thing that we as an industry were repeatedly asked for, and this came up a lot—perhaps unsurprisingly, given that this is a group of people whose job is mining software repositories—was this:
<blockquote><em> You should have instrumentation and logging around your processes. </em></blockquote>
This isn't pure altruism on their part, of course, but it's not pure self-interest either. Over and over again, the papers being presented drove home the points that there are a surprising number of tool-assisted efficiencies hidden in your software's history, provided that history is around to be analyzed in the first place. Instrumentation grows up to become automation informed by logs that turn into history, and good tooling around a project's history can play an active role in building its future.

Dr. Murphy's talk got a lot more specific and a lot heavier, than that—read the slides, at the very least. But one point that I thought she went through a too fast was: what if it was simple? What if it was easy to drill into comprehensive lifecycle data, see trends, and reflect on my own place and role in those trends? I've got some theories about that, but I'll get back to them shortly.

So, right from the opening, there were results being presented that jumped out at me as being relevant to our work at Mozilla, particularly given our very much inbox-driven development and communication approach. For example, the <a href="http://dl.acm.org/citation.cfm?id=2487090">paper by Mukherjee and Garg</a> about triaging email notifications proposes:
<blockquote><em> …a machine learning based approach to predict whether a notification will prompt any action from its recipient. Such a prediction can help to suitably mark up notifications and to decide whether a notification needs to be sent out immediately or be bundled in a message digest. </em></blockquote>
This certainly seems like something we could use, as do the other two papers in that timeslot, describing different approaches to automatically triaging bugs. Later on in the day it was shown that the #1 factor affecting how long it takes a bug to be fixed is fast, accurate triage, so a tool-guided bug triage process seems like a pretty big win, particularly one that learns over the long term.

Over the course of the day, as we moved into the MSR-Mobile and Mining Challenge parts of the conference, even things that weren't directly on-point for Mozilla were still pretty compelling. Textual analysis of Stack Overflow and other help sites that highlights pain points for our community across our products and services is a great idea. Automated approaches to figuring out which parts of an API are brittle or hard to use, which parts of our documentation need help, what new features people are asking for…are we doing that? Not in depth, I don't think, and not to drive decision-making. The Mozilla Developer Network (MDN) is making some moves in that direction, but I think there's some opportunities there we're not taking advantage of.

Another thing that came to light during the Stack Overflow data analysis talks was that the activity from people who are awarded "marathon" badges—500 edits, 500 comments, that sort of thing—drops way off after they've received the badge. I'd like to dig into that a bit more, to try and understand the causal relationship there: is it that people just get the achievement and then stop, is it that people suddenly realize how much time they've spent on Stack Overflow and decide to maybe go outside instead? Still, that discovery should inform some of our badging efforts as we start to ramp up the OpenBadges efforts on Mozillians.

The Analysis Of Bug Reports section of the talk…just read the whole thing. I'd be doing it a disservice to summarize, but certainly in light of the well-documented problems porting defect-prediction methods across software projects (a noble endeavor with a <a href="http://thomas-zimmermann.com/publications/files/zimmermann-esecfse-2009.pdf">96% failure rate</a>, if you needed a windmill to tilt at this week) it was pretty great that so many of the papers presented here were built on Mozilla's historical data. Go team! (Incidentally, this is the part of the day that "accurate triage is the most important thing" comes from, courtesy of Mani et al.)

There's a lot more to say about this, but shortly after this the content of the talks went a little bit past my pay grade. I spent more than a few of them feeling like that <a href="http://www.youtube.com/watch?v=Ccoj5lhLmSQ">one guy in GoodBurger</a>: "Hmm, yeah… I know some of these words".

What I want to talk about most is building out tools with an eye towards future machine learning and tool-driven analysis. I've been a sysadmin by trade for a long time, and one of the most important things I've learned there is that if you're in a complex environment with a lot of moving parts, you absolutely must have comprehensive, centralized logging. It's at the core of virtually everything you need to accomplish, whether it's today's sev-1 incident response or next year's capacity planning, and without it you're flying deaf and blind. But if you've got it, you've got notifications, advance warnings, statistical analysis, fault prediction—dozens and maybe hundreds of options and opportunities open up on timescales from preemptive to strategic.

I think we should try to apply the same approach to development tools and developer machines. Disk space isn't super-expensive—not free, I know, but I'm talking about text here—so here's my one-point plan: if you're building a tool that reports back to stdout/stderr, whatever it is, build in an option to send that information (or a structured version of it) to syslog at the same time. If you're part of a team using those tools, centralize those logs. It seems like an odd thing to do—certainly I don't know of anyone else doing that—but while I don't know for sure, I'm willing to bet after a while, the information we'll be able to learn from those logs will surprise us. And even if we don't know what to do with it, the people at MSR who are keen to collaborate with us will.]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>525</wp:post_id>
		<wp:post_date>2013-06-04 09:12:53</wp:post_date>
		<wp:post_date_gmt>2013-06-04 16:12:53</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>first-impressions-of-msr</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="conferences"><![CDATA[Conferences]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wpas_done_all</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Does Bug Prediction Support Human Developers? Findings From a Google Case Study</title>
		<link>http://www.neverworkintheory.org/?p=531</link>
		<pubDate>Thu, 06 Jun 2013 17:38:22 +0000</pubDate>
		<dc:creator>Fayola Peters</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=531</guid>
		<description></description>
		<content:encoded><![CDATA[Chris Lewis, Zhongpeng Lin, Caitlin Sadowski, Xiaoyan Zhu, Rong Ou, and E. James Whitehead Jr.: "Does Bug Prediction Support Human Developers? Findings From a Google Case Study." <cite>ICSE'13</cite>, 2013, <a href="http://www.cflewis.com/publications/google.pdf?attredirects=3D0">http://www.cflewis.com/publications/google.pdf?attredirects=3D0</a>.
<blockquote><em>While many bug prediction algorithms have been developed by academia, they're often only tested and verified in the lab using automated means. We do not have a strong idea about whether such algorithms are useful to guide human developers. We deployed a bug prediction algorithm across Google, and found no identifiable change in developer behavior. Using our experience, we provide several characteristics that bug prediction algorithms need to meet in order to be accepted by human developers and truly change how developers evaluate their code. </em></blockquote>
This paper highlights the divide between the success of bug prediction algorithms in academia and the lack of their adoption in software engineering practice. Lewis et al. presented volunteer software developers at Google with the results of two state-of-the-art algorithms. The first, the award winning FIxCache which caches files that are predicted to be bug-prone (Lewis et al. used two versions of this algorithm, one biased to cache newer files and the other biased to cache older files) and the second is what they call the Rahman algorithm which uses "the number of closed bugs to rank files from most bug-prone to least bug-prone".

The highlight of this paper is the list of three must-have characteristics for a bug prediction algorithm to be adopted as part of the software development process:
<ol>
	<li>Actionable messages: The output of a bug prediction algorithm should be actionable.</li>
	<li>Obvious reasoning: When a bug prediction algorithm flags a file as bug prone, developers would like to know why to allay any fears that the flag is a false positive.</li>
	<li>Bias towards the new: Developers are more concerned with files that are currently causing problems.</li>
</ol>
These characteristics were born from conversations with Google developers which led Lewis et al. to create TWS (an optimized version of the Rahman algorithm). TWS addressed two of the three must-have characteristics (2 and 3 above). The results showed that developer behavior did not change significantly before and after TWS was deployed. Lewis et al. looked at this result as a failure of TWS which did not present developers with actionable messages.

This work opens a line of discussion as to the real success of bug prediction algorithms, who are their most likely users, and what they should offer beyond precision, recall and F-measures.]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>531</wp:post_id>
		<wp:post_date>2013-06-06 10:38:22</wp:post_date>
		<wp:post_date_gmt>2013-06-06 17:38:22</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>does-bug-prediction-support-human-developers-findings-from-a-google-case-study</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="case-studies"><![CDATA[Case Studies]]></category>
		<category domain="category" nicename="tools"><![CDATA[Tools]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[178]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wpas_done_all</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>6591</wp:comment_id>
			<wp:comment_author><![CDATA[It&#8217;s Not a Bug, It&#8217;s a Feature: How Misclassification Impacts Bug Prediction - It Will Never Work in Theory]]></wp:comment_author>
			<wp:comment_author_email></wp:comment_author_email>
			<wp:comment_author_url>http://www.neverworkintheory.org/?p=547</wp:comment_author_url>
			<wp:comment_author_IP>64.90.54.151</wp:comment_author_IP>
			<wp:comment_date>2013-07-01 06:03:19</wp:comment_date>
			<wp:comment_date_gmt>2013-07-01 13:03:19</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[[...] Reducing Human Effort and Improving Quality in Peer Code Reviews using Automatic Static Analysis and Reviewer Recommendation - It Will Never Work in Theory on Does Bug Prediction Support Human Developers? Findings From a Google Case Study [...]]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type>pingback</wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";d:1372683799.908206939697265625;s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>6566</wp:comment_id>
			<wp:comment_author><![CDATA[Reducing Human Effort and Improving Quality in Peer Code Reviews using Automatic Static Analysis and Reviewer Recommendation - It Will Never Work in Theory]]></wp:comment_author>
			<wp:comment_author_email></wp:comment_author_email>
			<wp:comment_author_url>http://www.neverworkintheory.org/?p=554</wp:comment_author_url>
			<wp:comment_author_IP>64.90.54.151</wp:comment_author_IP>
			<wp:comment_date>2013-06-25 10:53:21</wp:comment_date>
			<wp:comment_date_gmt>2013-06-25 17:53:21</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[[...] aspects in the code. However, for a tool like Review Bot to be useful, it must be used. A paper we reviewed a few days ago said that developers were unwilling to adopt an analysis tool. This [...]]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type>pingback</wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";d:1372182801.7200009822845458984375;s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
		<title>Automatic Patch Generation Learned from Human-Written Patches</title>
		<link>http://www.neverworkintheory.org/?p=533</link>
		<pubDate>Thu, 06 Jun 2013 17:39:39 +0000</pubDate>
		<dc:creator>Fayola Peters</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=533</guid>
		<description></description>
		<content:encoded><![CDATA[Dongsun Kim, Jaechang Nam, Jaewoo Song, and Sunghun Kim: "Automatic Patch Generation Learned from Human-Written Patches." <cite>ICSE'13</cite>, 2013, <a href="http://www.cse.ust.hk/~hunkim/papers/kim-icse2013.pdf">http://www.cse.ust.hk/~hunkim/papers/kim-icse2013.pdf</a>.
<blockquote><em>Patch generation is an essential software maintenance task because most software systems inevitably have bugs that need to be fixed. Unfortunately, human resources are often insufficient to fix all reported and known bugs. To address this issue, several automated patch generation techniques have been proposed. In particular, a genetic-programming-based patch generation technique, GenProg, proposed by Weimer et al., has shown promising results. However, these techniques can generate nonsensical patches due to the randomness of their mutation operations.
To address this limitation, we propose a novel patch generation approach, Pattern-based Automatic program Repair (PAR), using fix patterns learned from existing human-written patches. We manually inspected more than 60,000 human-written patches and found there are several common fix patterns. Our approach leverages these fix patterns to generate program patches automatically. We experimentally evaluated PAR on 119 real bugs. In addition, a user study involving 89 students and 164 developers confirmed that patches generated by our approach are more acceptable than those generated by GenProg. PAR successfully generated patches for 27 out of 119 bugs, while GenProg was successful for only 16 bugs.</em></blockquote>
Software products are released with known and unknown bugs. For example, this paper by Kim et al. mentions that Windows 2000 was released with over 60K known bugs. Why? Bug repairs are for the most part done manually and there are not enough resources to repair all of them. Automatic patch generation methods have been devise to reduce this manual effort.

To add to this field of research, Kim et al. integrate the human element with machine learning. They do this by manually reviewing human written patches to create fix-pattern templates used to then generate "candidate" patches. The purpose in doing this was to solve the issue of what they consider to be "nonsensical patches" produced by GenProg (<a href="https://www.cs.virginia.edu/~weimer/p/weimer-icse2012-genprog-preprint.pdf">https://www.cs.virginia.edu/~weimer/p/weimer-icse2012-genprog-preprint.pdf</a>). GenProg's approach to automated patch generation is based on genetic programming used to search the vast space of possible program repairs.

Two interesting aspects of the Kim et al. paper are that the patches generated from one project are used successfully on other projects and the fix-pattern templates once created can be use repeatedly. However, one element not measured in this paper is the monetary cost of fixing each bug (measured in GenProg), considering the bounties offered for bug fixes by some companies, it would be interesting to see such a result included in future automatic patch generation methods.]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>533</wp:post_id>
		<wp:post_date>2013-06-06 10:39:39</wp:post_date>
		<wp:post_date_gmt>2013-06-06 17:39:39</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>automatic-patch-generation-learned-from-human-written-patches</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="code-generation"><![CDATA[Code Generation]]></category>
		<category domain="category" nicename="tools"><![CDATA[Tools]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[178]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wpas_done_all</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>6444</wp:comment_id>
			<wp:comment_author><![CDATA[Rodrigo]]></wp:comment_author>
			<wp:comment_author_email>rodrigorgs@gmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>200.128.60.107</wp:comment_author_IP>
			<wp:comment_date>2013-06-06 10:57:54</wp:comment_date>
			<wp:comment_date_gmt>2013-06-06 17:57:54</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Very interesting approach. My concern however, is how often the generated patches are just workarounds instead of fixes.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";d:1370541474.64027309417724609375;s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>6446</wp:comment_id>
			<wp:comment_author><![CDATA[Daniel Sobral]]></wp:comment_author>
			<wp:comment_author_email>dcsobral@gmail.com</wp:comment_author_email>
			<wp:comment_author_url>http://dcsobral.blogspot.com/</wp:comment_author_url>
			<wp:comment_author_IP>186.214.168.163</wp:comment_author_IP>
			<wp:comment_date>2013-06-06 16:28:28</wp:comment_date>
			<wp:comment_date_gmt>2013-06-06 23:28:28</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[About 25% on an academic study? It sounds promising to me. I'd like to know if PAR produced patches for _all_ bugs, or if there were bugs for which PAR decided it didn't know how to fix. Ultimately, it might be cheaper to let software propose a patch, code review it, and then either accept the proposed patch or work on one on your own.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";d:1370561308.7786910533905029296875;s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
		<title>UML in Practice</title>
		<link>http://www.neverworkintheory.org/?p=542</link>
		<pubDate>Thu, 13 Jun 2013 17:43:36 +0000</pubDate>
		<dc:creator>gvwilson</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=542</guid>
		<description></description>
		<content:encoded><![CDATA[Marian Petre: "UML in practice" <cite>ICSE'13</cite>, 2013. <a href="http://oro.open.ac.uk/35805/">http://oro.open.ac.uk/35805/</a>.
<blockquote><em>UML has been described by some as "the lingua franca of software engineering". Evidence from industry does not necessarily support such endorsements. How exactly is UML being used in industry — if it is? This paper presents a corpus of interviews with 50 professional software engineers in 50 companies and identifies 5 patterns of UML use.</em></blockquote>
The abstract for this distinguished paper doesn't do it justice. Over two years, the author interviewed over 50 developers from a broad cross-section of industries and countries. She found their use fell into five broad categories:
<table>
<tbody>
<tr>
<td>Category</td>
<td>Number</td>
</tr>
<tr>
<td>no UML</td>
<td align="center">35</td>
</tr>
<tr>
<td>selective</td>
<td align="center">11</td>
</tr>
<tr>
<td>automated code generation</td>
<td align="center">3</td>
</tr>
<tr>
<td>retrofit</td>
<td align="center">1</td>
</tr>
<tr>
<td>wholehearted</td>
<td align="center">0</td>
</tr>
</tbody>
</table>
Among the reasons given for not using it were:
<ul>
	<li>Lack of context: UML deals with architecture, rather than with the whole system.</li>
	<li>The overheads of understanding the notation.</li>
	<li>Issues of synchronization and consistency.</li>
</ul>
Perhaps the most interesting category is the second: those people who selectively use some elements of UML, but not the whole notation. Some of the partial uses identified were:
<ul>
	<li>UML as a 'thought tool'</li>
	<li>communicating with stakeholders</li>
	<li>collaborative dialogs</li>
	<li>adaptation (i.e., using a homegrown variant of the "real" notation), and</li>
	<li>selective traction (i.e., using it just as long as is useful, then moving on)</li>
</ul>
while the parts used were:
<table>
<tbody>
<tr>
<td>Diagram</td>
<td>Number</td>
</tr>
<tr>
<td>Class diagrams</td>
<td align="center">7</td>
</tr>
<tr>
<td>Sequence diagrams</td>
<td align="center">6</td>
</tr>
<tr>
<td>Activity diagrams</td>
<td align="center">6</td>
</tr>
<tr>
<td>State machine diagrams</td>
<td align="center">3</td>
</tr>
<tr>
<td>Use case diagrams</td>
<td align="center">1</td>
</tr>
</tbody>
</table>
But there is much more in this paper than merely statistics. One of Petre's many insightful comments is:
<blockquote><em>Responses concerning UML use tend to be polarized, between design use and implementation use... Despite the notional accommodation of the whole process, informants tend to use UML either in early design, or in implementation, rarely both (even when informants' roles include the whole process).</em></blockquote>
There are two ways to react to this work. The first is to read it as an indictment: after 20 years, UML is still mostly not used and not valued. The second, and more hopeful, is as a concrete step toward improving it. Parts of UML <em>are</em> used; the more we learn about which ones, where, why, and how, the better our chances of building something better.]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>542</wp:post_id>
		<wp:post_date>2013-06-13 10:43:36</wp:post_date>
		<wp:post_date_gmt>2013-06-13 17:43:36</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>uml-in-practice-2</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="case-studies"><![CDATA[Case Studies]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wpas_done_all</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>6523</wp:comment_id>
			<wp:comment_author><![CDATA[Adriano Comai]]></wp:comment_author>
			<wp:comment_author_email>adriano-liste@fastwebnet.it</wp:comment_author_email>
			<wp:comment_author_url>http://www.analisi-disegno.com</wp:comment_author_url>
			<wp:comment_author_IP>93.38.72.9</wp:comment_author_IP>
			<wp:comment_date>2013-06-16 01:44:44</wp:comment_date>
			<wp:comment_date_gmt>2013-06-16 08:44:44</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[I'm sorry this is wrong. 

UML is actually used for DB Design, and for modeling user interactions. The point is that there are specific UML profiles to do it: the DB design profile is used since several years in most modeling tools, and many tools use communication diagrams for modeling user interactions - however a new UML profile, IFML, is now being published by OMG to improve this specific activity.

To get a better view of what UML is and of what it can be used for, this set of videos (in Italian, with English subtitles) may be useful: http://www.youtube.com/watch?v=CvsO_G9I3yk]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>6499</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";d:1371372284.941524982452392578125;s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>6563</wp:comment_id>
			<wp:comment_author><![CDATA[Robert Klemme]]></wp:comment_author>
			<wp:comment_author_email>shortcutter@googlemail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>80.66.20.180</wp:comment_author_IP>
			<wp:comment_date>2013-06-25 03:12:38</wp:comment_date>
			<wp:comment_date_gmt>2013-06-25 10:12:38</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[I'm in group 2.  And I don't believe in code generation and model driven design because of the quirks of roundtrip engineering.  Also, modeling a complete application in UML is just plain awkward.  It's better to use it to visualize important aspects of it and write program code based on that important aspects.  UML is also great at whiteboards.  It helps to have a notation that everybody (mostly) understands.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";d:1372155158.94079494476318359375;s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>6510</wp:comment_id>
			<wp:comment_author><![CDATA[UML adoption in practice: has anything changed in the last decade? | Modeling Languages]]></wp:comment_author>
			<wp:comment_author_email></wp:comment_author_email>
			<wp:comment_author_url>http://modeling-languages.com/uml-adoption-in-practice-has-anything-changed-in-the-last-decade/</wp:comment_author_url>
			<wp:comment_author_IP>64.50.165.102</wp:comment_author_IP>
			<wp:comment_date>2013-06-14 03:51:00</wp:comment_date>
			<wp:comment_date_gmt>2013-06-14 10:51:00</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[[...] vu&#8221;. The first one while reading the &#8220;UML in Practice&#8221; ICSE&#8217;13 paper (read this summary also) and the second one while browsing the tweets of the last MiSE&#8217;13 [...]]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type>pingback</wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";d:1371207060.5943090915679931640625;s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>6496</wp:comment_id>
			<wp:comment_author><![CDATA[UML in practice &raquo; Wisconsin Web Works]]></wp:comment_author>
			<wp:comment_author_email></wp:comment_author_email>
			<wp:comment_author_url>http://wiswebworks.com/uml-in-practice/</wp:comment_author_url>
			<wp:comment_author_IP>192.30.35.20</wp:comment_author_IP>
			<wp:comment_date>2013-06-13 12:47:59</wp:comment_date>
			<wp:comment_date_gmt>2013-06-13 19:47:59</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[[...] by  tpk1024   [link] [1 comment]  &#8230;read [...]]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type>pingback</wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";d:1371152879.6783161163330078125;s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>6498</wp:comment_id>
			<wp:comment_author><![CDATA[Daniel Sobral]]></wp:comment_author>
			<wp:comment_author_email>dcsobral@gmail.com</wp:comment_author_email>
			<wp:comment_author_url>http://dcsobral.blogspot.com/</wp:comment_author_url>
			<wp:comment_author_IP>186.213.213.48</wp:comment_author_IP>
			<wp:comment_date>2013-06-13 13:28:07</wp:comment_date>
			<wp:comment_date_gmt>2013-06-13 20:28:07</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[I think the question is not so much why not use it, but why use it, and how the reasons put forth by the proponents match up to practice from non-users.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";d:1371155287.9592049121856689453125;s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>6499</wp:comment_id>
			<wp:comment_author><![CDATA[Paolo Marino]]></wp:comment_author>
			<wp:comment_author_email>marino@inrete.it</wp:comment_author_email>
			<wp:comment_author_url>http://www.pa-mar.net</wp:comment_author_url>
			<wp:comment_author_IP>188.216.96.141</wp:comment_author_IP>
			<wp:comment_date>2013-06-13 14:07:11</wp:comment_date>
			<wp:comment_date_gmt>2013-06-13 21:07:11</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[I mostly deal with corporate-level custom apps.
This (for the last 10 years or so) mostly means webapps.
This also means that the two areas that need the most effort in order to "get it right" are:
- DB Design
- User Interface 

Enters UML, which does not provide any specific support for DB design, or for modelling User interaction in terms of actual (web) interface functionality for the end user.

Therefore I  never found much use for it: it's always DBA tools on one side, and lots of mockups, wireframing and prototypes on the other. And it really never helped in communicating with the end user, either.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";d:1371157631.773130893707275390625;s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>6530</wp:comment_id>
			<wp:comment_author><![CDATA[ICSE 2013: Four Days of San Francisco | The CHISEL Group, University of Victoria, BC]]></wp:comment_author>
			<wp:comment_author_email></wp:comment_author_email>
			<wp:comment_author_url>http://thechiselgroup.org/2013/06/17/icse-2013-four-days-of-san-francisco/</wp:comment_author_url>
			<wp:comment_author_IP>72.233.69.75</wp:comment_author_IP>
			<wp:comment_date>2013-06-17 16:42:43</wp:comment_date>
			<wp:comment_date_gmt>2013-06-17 23:42:43</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[[...] The session after that again spoke to my heart: it was about empirical studies. Bacchelli and Bird presented a study on the &#8220;Expectations, Outcomes, and Challenges of Modern Code Review&#8220;. Again, this was an investigation that involved actual developers. What&#8217;s more, based on their findings, the authors even give recommendations to practitioners on how to conduct code reviews. Another great talk in this session was Marian Petre&#8217;s &#8220;UML in Practice&#8221;. She also talked to developers and inquired about whether, how, and why they use UML, the Unified Modeling Language. Greg Wilson gave a nice overview of the paper at the It Will Never Work in Theory blog. [...]]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type>pingback</wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";d:1371512563.3628890514373779296875;s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>6531</wp:comment_id>
			<wp:comment_author><![CDATA[ICSE 2013: Four Days of San Francisco | Leif Singer&#039;s Blog]]></wp:comment_author>
			<wp:comment_author_email></wp:comment_author_email>
			<wp:comment_author_url>http://blog.leif.me/2013/06/icse-2013-four-days-of-san-francisco/</wp:comment_author_url>
			<wp:comment_author_IP>207.192.75.116</wp:comment_author_IP>
			<wp:comment_date>2013-06-17 16:44:30</wp:comment_date>
			<wp:comment_date_gmt>2013-06-17 23:44:30</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[[...] The session after that again spoke to my heart: it was about empirical studies. Bacchelli and Bird presented a study on the &#8220;Expectations, Outcomes, and Challenges of Modern Code Review&#8220;. Again, this was an investigation that involved actual developers. What&#8217;s more, based on their findings, the authors even give recommendations to practitioners on how to conduct code reviews. Another great talk in this session was Marian Petre&#8217;s &#8220;UML in Practice&#8221;. She also talked to developers and inquired about whether, how, and why they use UML, the Unified Modeling Language. Greg Wilson gave a nice overview of the paper at the It Will Never Work in Theory blog. [...]]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type>pingback</wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";d:1371512670.8811409473419189453125;s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
		<title>The MSR Cookbook: Mining a Decade of Research</title>
		<link>http://www.neverworkintheory.org/?p=545</link>
		<pubDate>Thu, 13 Jun 2013 17:44:40 +0000</pubDate>
		<dc:creator>gvwilson</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=545</guid>
		<description></description>
		<content:encoded><![CDATA[Hadi Hemmati, Sarah Nadi, Olga Baysal, Oleksii Kononenko, Wei Wang, Reid Holmes, and Michael W. Godfrey: "The MSR Cookbook: Mining a Decade of Research". <cite>ICSE'13</cite>, 2013, <a href="https://cs.uwaterloo.ca/~obaysal/msr2013_hemmati.pdf">https://cs.uwaterloo.ca/~obaysal/msr2013_hemmati.pdf</a>.
<blockquote><em>The Mining Software Repositories (MSR) research community has grown significantly since the first MSR workshop was held in 2004. As the community continues to broaden its scope and deepens its expertise, it is worthwhile to reflect on the best practices that our community has developed over the past decade of research. We identify these best practices by surveying past MSR conferences and workshops. To that end, we review all 117 full papers published in the MSR proceedings between 2004 and 2012. We extract 268 comments from these papers, and categorize them using a grounded theory methodology. From this evaluation, four high-level themes were identified: data acquisition and preparation, synthesis, analysis, and sharing/replication. Within each theme we identify several common recommendations, and also examine how these recommendations have evolved over the past decade. In an effort to make this survey a living artifact, we also provide a public forum that contains the extracted recommendations in the hopes that the MSR community can engage in a continuing discussion on our evolving best practices.</em></blockquote>
From modest beginnings a decade ago, the idea of applying data mining and machine learning techniques to software repositories has grown into a dynamic and game-changing research area. Instead of talking about how programmers <em>ought</em> to work, we can now say quite a bit about how they <em>actually</em> work, and about what practices work (or don't).

This paper summarizes what the MSR community has learned over those years. The authors went through 117 papers published in the MSR conference, extracted comments, and categorized them to produce the following insights and advice:
<ul>
	<li>D1: SCM repositories contain a variety of noise; validation of heuristics and assumptions is essential.</li>
	<li>D2: The choice of code extraction approach (simple diff, building AST or CFG, etc.) is often heavily influenced by analysis cost.</li>
	<li>D3: When working with issue trackers, it is often best to only consider closed and fixed issues.</li>
	<li>D4: Social communication data requires extensive pre-processing before it can be used.</li>
	<li>D5: Plain text requires splitting, stemming, normalization and smoothing before analysis.</li>
	<li>D6: Text analyses should be manually verified (e.g., sampled) in addition to regular bias reporting.</li>
	<li>D7: Multiple online personas can cause individuals to be represented as multiple people.</li>
	<li>S1: Be careful to remove collinearities and deal with skewness when synthesizing models from data.</li>
	<li>S2: Carefully tuning parameters and performing sensitivity analysis can improve the modelling process.</li>
	<li>S3: Simple analyses often outperform their complex counterparts.</li>
	<li>S4: Be aware of the assumptions made by regression analyses.</li>
	<li>A1: Manual verification of all outputs is required.</li>
	<li>A2: Correlation analysis can be used to quickly check initial hypotheses about a set of data.</li>
	<li>A3: While precision and recall are valuable measures, be aware that other indicators may be more appropriate in a given context.</li>
	<li>A4: While applying rigorous statistical analyses is important, consider practical differences when drawing conclusions.</li>
	<li>R1: Sharing data, tools, and techniques helps push the community forward and is just Good Science<sup>TM</sup>.</li>
</ul>
We look forward to more great work in the coming years.

<em>Postscript: readers interested in this paper may also enjoy Kocaguneli et al's "Distibuted Development Considered Harmful?" (<a href="http://menzies.us/pdf/13distributed.pdf">http://menzies.us/pdf/13distributed.pdf</a>), which presents three rules for reporting research results to industrial practitioners.</em>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>545</wp:post_id>
		<wp:post_date>2013-06-13 10:44:40</wp:post_date>
		<wp:post_date_gmt>2013-06-13 17:44:40</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>the-msr-cookbook-mining-a-decade-of-research</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="experience-reports"><![CDATA[Experience Reports]]></category>
		<category domain="category" nicename="literature-reviews"><![CDATA[Literature Reviews]]></category>
		<category domain="category" nicename="mining"><![CDATA[Mining]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wpas_done_all</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>It&#039;s Not a Bug, It&#039;s a Feature: How Misclassification Impacts Bug Prediction</title>
		<link>http://www.neverworkintheory.org/?p=547</link>
		<pubDate>Thu, 13 Jun 2013 17:45:41 +0000</pubDate>
		<dc:creator>gvwilson</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=547</guid>
		<description></description>
		<content:encoded><![CDATA[Kim Herzig, Sascha Just, and Andreas Zeller: "It's not a Bug, it's a Feature: How Misclassification Impacts Bug Prediction". <cite>ICSE'13</cite>, 2013, <a href="http://www.st.cs.uni-saarland.de/softevo/bugclassify/paper/icse2013-bugclassify.pdf">http://www.st.cs.uni-saarland.de/softevo/bugclassify/paper/icse2013-bugclassify.pdf</a>.
<blockquote><em>In a manual examination of more than 7,000 issue reports from the bug databases of five open-source projects, we found 33.8% of all bug reports to be misclassified—that is, rather than referring to a code fix, they resulted in a new feature, an update to documentation, or an internal refactoring. This misclassification introduces bias in bug prediction models, confusing bugs and features: On average, 39% of files marked as defective actually never had a bug. We estimate the impact of this misclassification on earlier studies and recommend manual data validation for future studies.</em></blockquote>
The popular media often gets very excited when a new study overturns an old one. Skeptics seize on this as proof that scientists don't know what they're talking about; what they fail to realize is that this is often actually evidence that science is working as it should. To paraphrase Enrico Fermi, its goal is to leave us confused, but on a higher level, and the insight that comes from realizing that earlier questions were poorly phrased, or their answers mis-understood, is often as valuable as any "Eureka!" moment.

This paper is a prime example of that, and evidence of how quickly empirical software engineering research is maturing. By carefully examining thousands of bug reports from several projects, they have found that many mis-report themselves in ways that will inevitably skew the results of simplistic data mining. From one perspective, it's just a large-scale replication of Aranda and Venolia's "<a href="http://research.microsoft.com/apps/pubs/default.aspx?id=81022">Secret Life of Bugs</a>" paper from ICSE 2009, but there's a lot of hard work hiding in that "just". And while this kind of research may not feel like a big step forward, it's what ensures that the next generation of studies will be more useful. Like the lewis et al paper on <a href="http://www.neverworkintheory.org/?p=531">the usability of bug prediction tools</a> described a few days ago, it gives practitioners a more trustworthy foundation for translating insights into projections and decisions.]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>547</wp:post_id>
		<wp:post_date>2013-06-13 10:45:41</wp:post_date>
		<wp:post_date_gmt>2013-06-13 17:45:41</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>its-not-a-bug-its-a-feature-how-misclassification-impacts-bug-prediction</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="mining"><![CDATA[Mining]]></category>
		<category domain="category" nicename="quantitative-studies"><![CDATA[Quantitative Studies]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wpas_done_all</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Formal Specifications Better Than Function Points for Code Sizing</title>
		<link>http://www.neverworkintheory.org/?p=549</link>
		<pubDate>Thu, 13 Jun 2013 17:46:26 +0000</pubDate>
		<dc:creator>gvwilson</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=549</guid>
		<description></description>
		<content:encoded><![CDATA[Mark Staples, Rafal Kolanski, Gerwin Klein, Corey Lewis, June Andronick, Toby Murray, Ross Jeffery, and Len Bass: "Formal Specifications Better Than Function Points for Code Sizing". <cite>ICSE'13</cite>, 2013, <a href="http://www.nicta.com.au/pub?doc=6416">http://www.nicta.com.au/pub?doc=6416</a>.
<blockquote><em>Size and effort estimation is a significant challenge for the management of large-scale formal verification projects. We report on an initial study of relationships between the sizes of artefacts from the development of seL4, a formally-verified embedded systems microkernel. For each API function we first determined its COSMIC Function Point (CFP) count (based on the seL4 user manual), then sliced the formal specifications and source code, and performed a normalised line count on these artefact slices. We found strong and significant relationships between the sizes of the artefact slices, but no significant relationships between them and the CFP counts. Our finding that CFP is poorly correlated with lines of code is based on just one system, but is largely consistent with prior literature. We find CFP is also poorly correlated with the size of formal specifications. Nonetheless, lines of formal specification correlate with lines of source code, and this may provide a basis for size prediction in future formal verification projects. In future work we will investigate proof sizing.</em></blockquote>
Donald Knuth reportedly once said that C was the best language ever invented for analyzing algorithms because you could see how many atomic operations there were simply by counting punctuation. In this paper, Staples et al. apply that idea at a much, much higher level. Does the size of the formal specification for part of a micro-kernel correlate with the number of lines required to implement it? The answer appears to be "yes", and moreover, that correlation is much better than the correlation between lines of code and function points. This doesn't necessarily mean that formal specifications are worth writing solely as an aid to project cost estimation, but it does open up some new practical applications—not least, the question of whether the effort saved by having a formal specification repays the cost of creating it. We look forward to seeing this work replicated on other systems.]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>549</wp:post_id>
		<wp:post_date>2013-06-13 10:46:26</wp:post_date>
		<wp:post_date_gmt>2013-06-13 17:46:26</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>formal-specifications-better-than-function-points-for-code-sizing</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="estimation"><![CDATA[Estimation]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wpas_done_all</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Reducing Human Effort and Improving Quality in Peer Code Reviews using Automatic Static Analysis and Reviewer Recommendation</title>
		<link>http://www.neverworkintheory.org/?p=554</link>
		<pubDate>Wed, 19 Jun 2013 16:16:32 +0000</pubDate>
		<dc:creator>Fayola Peters</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=554</guid>
		<description></description>
		<content:encoded><![CDATA[Vipin Balachandran: "Reducing Human Effort and Improving Quality in Peer Code Reviews using Automatic Static Analysis and Reviewer Recommendation." <cite>ICSE'13</cite>, 2013, <a href="http://labs.vmware.com/download/198/">http://labs.vmware.com/download/198/</a>.
<blockquote><em>Peer code review is a cost-effective software defect detection technique. Tool assisted code review is a form of peer code review, which can improve both quality and quantity of reviews. However, there is a significant amount of human effort involved even in tool based code reviews. Using static analysis tools, it is possible to reduce the human effort by automating the checks for coding standard violations and common defect patterns. Towards this goal, we propose a tool called Review Bot for the integration of automatic static analysis with the code review process. Review Bot uses output of multiple static analysis tools to publish reviews automatically. Through a user study, we show that integrating static analysis tools with code review process can improve the quality of code review. The developer feedback for a subset of comments from automatic reviews shows that the developers agree to fix 93% of all the automatically generated comments. There is only 14.71% of all the accepted comments which need improvements in terms of priority, comment message, etc. Another problem with tool assisted code review is the assignment of appropriate reviewers. Review Bot solves this problem by generating reviewer recommendations based on change history of source code lines. Our experimental results show that the recommendation accuracy is in the range of 60%-92%, which is significantly better than a comparable method based on file change history.</em></blockquote>
In the case of human code review vs. tool assisted code review, this paper by Balachandran favors tool assistance. The tool in question, Review Bot (an extension of the online code review tool <a href="http://www.reviewboard.org/">Review Board</a>) automates the checks for standard coding violations and defect patterns that turn up regularly in approved code reviews. In other words, let the tool sweat the small stuff while developers focus on the logic verification aspects in the code. However, for a tool like Review Bot to be useful, it must be used. A <a href="http://www.neverworkintheory.org/?p=531">paper</a> we reviewed a few days ago said that developers were unwilling to adopt an analysis tool. This paper finds the opposite. With Review Bot, developers acted on 93% of the auto-review comments.

This paper does not stop there: Review Bot improves on reviewer assignment for large projects. Using line change history to rank reviewers outperforms the commonly used file change history. However, it has a shared problem with manual reviewer assignment—it cannot be used on new files. Balachandran left this problem for future work and proposes a syntactic similarity method as a possible solution. It will be interesting to see if his idea works.]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>554</wp:post_id>
		<wp:post_date>2013-06-19 09:16:32</wp:post_date>
		<wp:post_date_gmt>2013-06-19 16:16:32</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>reducing-human-effort-and-improving-quality-in-peer-code-reviews-using-automatic-static-analysis-and-reviewer-recommendation</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="code-review"><![CDATA[Code Review]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wpas_done_all</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>6567</wp:comment_id>
			<wp:comment_author><![CDATA[Benjamin Meyer]]></wp:comment_author>
			<wp:comment_author_email>ben@meyerhome.net</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>4.79.245.132</wp:comment_author_IP>
			<wp:comment_date>2013-06-25 12:55:19</wp:comment_date>
			<wp:comment_date_gmt>2013-06-25 19:55:19</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Note that in the previous paper stated that "TWR doesn’t provide actionable messages [to developers]." while this tool did provide an actionable message even if it was small.

I have used tools that provide general feedback about a commit such as "it seems overly complex" which is ignored, but when there is feedback that on line 37 you violate style rule X I will happily change that as part of the review process.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";d:1372190120.0259549617767333984375;s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
		<title>How, and Why, Process Metrics Are Better</title>
		<link>http://www.neverworkintheory.org/?p=565</link>
		<pubDate>Sun, 07 Jul 2013 11:37:15 +0000</pubDate>
		<dc:creator>Fayola Peters</dc:creator>
		<guid isPermaLink="false">http://www.neverworkintheory.org/?p=565</guid>
		<description></description>
		<content:encoded><![CDATA[Foyzur Rahman and Premkumar Devanbu: "How, and Why, Process Metrics Are Better." <em>ICSE'13</em>, 2013, <a href="http://www.cs.ucdavis.edu/research/tech-reports/2012/CSE-2012-33.pdf">http://www.cs.ucdavis.edu/research/tech-reports/2012/CSE-2012-33.pdf</a>.
<blockquote><em>Defect prediction techniques could potentially help us to focus quality-assurance efforts on the most defect-prone files. Modern statistical tools make it very easy to quickly build and deploy prediction models. Software metrics are at the heart of prediction models; understanding how and especially why different types of metrics are effective is very important for successful model deployment. In this paper we analyze the applicability and efficacy of process and code metrics from several different perspectives. We build many prediction models across 85 releases of 12 large open source projects to address the performance, stability, portability and stasis of different sets of metrics. Our results suggest that code metrics, despite widespread use in the defect prediction literature, are generally less useful than process metrics for prediction. Second, we find that code metrics have high stasis; they don't change very much from release to release. This leads to stagnation in the prediction models, leading to the same files being repeatedly predicted as defective; unfortunately, these recurringly defective files turn out to be comparatively less defect-dense.</em></blockquote>
Software engineering practices are often based on the 'guruisms' or pure myth. However, in resent years researchers have empirically prove or disprove some of these myths. One example is code cloning being considered as bad practice. But why? A <a href="http://www.neverworkintheory.org/?p=102">past review</a> of Kapser and Godfrey's work stated that many code clones are actually OK. Kapser and Godfrey found that as many as 71% of the clones they studied could be considered to have a positive impact on the maintainability of the software system. This isn't the only clones result that denounces the "bad practice" premise: Rahman et al.'s "<a href="http://www.cabird.com/papers/rahman2010cws.pdf">Clones: What is that Smell</a>?" found no evidence that cloning makes code more defect prone.

Here, Rahman et al. are exploring the question of "how" and "why" process metrics are better than code metrics. In this "don't take my word for it" study, the authors answer seven research questions comparing the performance, stability, portability and stasis of these metrics. To answer the "how" they found the following:
<ol>
	<li>Process metrics create significantly better defect predictors than code metrics across multiple learners.</li>
	<li>By using older project releases to predict for newer ones, they found no significant difference in the stability of process metrics and code metrics.</li>
	<li>Process metrics are more portable than code metrics, in other words, using data from one project to predict for another works better with process metrics.</li>
	<li>Process metrics are less static than code metrics: They change more than code metrics over releases.</li>
</ol>
To answer the "why" they found that code metrics have what the authors call "high stasis": they don't change much over releases. This led them to conclude that "...the stasis of code metrics leads to stagnant prediction models, that predict the same files as defective over and over again".

Is this a bad thing? Their results show that not only do code metrics predict for "recurringly" defective files, these files tend to be larger and less defect dense, thus making code metric based predictors less cost effective. Considering that the use of software metrics for defect prediction helps to prioritize quality assurance activities, this paper definitely helps in the decision process of which metrics to collect for software projects and why.]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>565</wp:post_id>
		<wp:post_date>2013-07-07 04:37:15</wp:post_date>
		<wp:post_date_gmt>2013-07-07 11:37:15</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>how-and-why-process-metrics-are-better</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="code-smells"><![CDATA[Code Smells]]></category>
		<category domain="category" nicename="metrics"><![CDATA[Metrics]]></category>
		<category domain="category" nicename="quantitative-studies"><![CDATA[Quantitative Studies]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_s2mail</wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wpas_done_all</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
</channel>
</rss>
