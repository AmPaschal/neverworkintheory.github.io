---
layout: page
title: Bibliography
---
<p><a href="../tex/nwit.bib">BibTeX</a> | <a href="../tex/nwit.pdf">PDF</a></p>

<p><a href="#A">A</a> <a href="#B">B</a> <a href="#C">C</a> <a href="#D">D</a> <a href="#E">E</a> <a href="#F">F</a> <a href="#G">G</a> <a href="#H">H</a> <a href="#I">I</a> <a href="#J">J</a> <a href="#K">K</a> <a href="#L">L</a> <a href="#M">M</a> <a href="#N">N</a> <a href="#O">O</a> <a href="#P">P</a> <a href="#Q">Q</a> <a href="#R">R</a> <a href="#S">S</a> <a href="#T">T</a> <a href="#U">U</a> <a href="#V">V</a> <a href="#W">W</a> <a href="#X">X</a> <a href="#Y">Y</a> <a href="#Z">Z</a></p>

<h2 id="A">A</h2>

<p id="Abad2018" class="bib"><cite>Abad2018</cite>
Zahra Shakeri Hossein Abad, Oliver Karras, Kurt Schneider, Ken Barker, and Mike Bauer:
"<a href="https://doi.org/10.1145/3210459.3210471">Task interruption in software development projects</a>".
<em>Proceedings of the 22nd International Conference on Evaluation and Assessment in Software Engineering 2018</em>, <a class="doi" href="https://doi.org/10.1145/3210459.3210471">10.1145/3210459.3210471</a>.
</p>
<blockquote class="abstract">Multitasking has always been an inherent part of software development and is known as the primary source of interruptions due to task switching in software development teams. Developing software involves a mix of analytical and creative work, and requires a significant load on brain functions, such as working memory and decision making. Thus, task switching in the context of software development imposes a cognitive load that causes software developers to lose focus and concentration while working thereby taking a toll on productivity. To investigate the disruptiveness of task switching and interruptions in software development projects, and to understand the reasons for and perceptions of the disruptiveness of task switching we used a mixed-methods approach including a longitudinal data analysis on 4,910 recorded tasks of 17 professional software developers, and a survey of 132 software developers. We found that, compared to task-specific factors (e.g. priority, level, and temporal stage), contextual factors such as interruption type (e.g. self/external), time of day, and task type and context are a more potent determinant of task switching disruptiveness in software development tasks. Furthermore, while most survey respondents believe external interruptions are more disruptive than self-interruptions, the results of our retrospective analysis reveals otherwise. We found that self-interruptions (i.e. voluntary task switchings) are more disruptive than external interruptions and have a negative effect on the performance of the interrupted tasks. Finally, we use the results of both studies to provide a set of comparative vulnerability and interaction patterns which can be used as a mean to guide decision-making and forecasting the consequences of task switching in software development teams.</blockquote>

<p id="Abdalkareem2017" class="bib"><cite>Abdalkareem2017</cite>
Rabe Abdalkareem, Olivier Nourry, Sultan Wehaibi, Suhaib Mujahid, and Emad Shihab:
"<a href="https://doi.org/10.1145/3106237.3106267">Why do developers use trivial packages? an empirical case study on NPM</a>".
<em>Proceedings of the 2017 11th Joint Meeting on Foundations of Software Engineering</em>, <a class="doi" href="https://doi.org/10.1145/3106237.3106267">10.1145/3106237.3106267</a>.
</p>
<blockquote class="abstract">Code reuse is traditionally seen as good practice. Recent trends have pushed the concept of code reuse to an extreme, by using packages that implement simple and trivial tasks, which we call 'trivial packages'. A recent incident where a trivial package led to the breakdown of some of the most popular web applications such as Facebook and Netflix made it imperative to question the growing use of trivial packages. Therefore, in this paper, we mine more than 230,000 npm packages and 38,000 JavaScript applications in order to study the prevalence of trivial packages. We found that trivial packages are common and are increasing in popularity, making up 16.8% of the studied npm packages. We performed a survey with 88 Node.js developers who use trivial packages to understand the reasons and drawbacks of their use. Our survey revealed that trivial packages are used because they are perceived to be well implemented and tested pieces of code. However, developers are concerned about maintaining and the risks of breakages due to the extra dependencies trivial packages introduce. To objectively verify the survey results, we empirically validate the most cited reason and drawback and find that, contrary to developers' beliefs, only 45.2% of trivial packages even have tests. However, trivial packages appear to be `deployment tested' and to have similar test, usage and community interest as non-trivial packages. On the other hand, we found that 11.5% of the studied trivial packages have more than 20 dependencies. Hence, developers should be careful about which trivial packages they decide to use.</blockquote>

<p id="Akerblom2016" class="bib"><cite>Akerblom2016</cite>
Beatrice Åkerblom and Tobias Wrigstad:
"<a href="https://doi.org/10.1145/2936313.2816717">Measuring polymorphism in Python programs</a>".
<em>ACM SIGPLAN Notices</em>, 51(2), 2016,
<a class="doi" href="https://doi.org/10.1145/2936313.2816717">10.1145/2936313.2816717</a>.
</p>
<blockquote class="abstract">Following the increased popularity of dynamic languages and their increased use in critical software, there have been many proposals to retrofit static type system to these languages to improve possibilities to catch bugs and improve performance. A key question for any type system is whether the types should be structural, for more expressiveness, or nominal, to carry more meaning for the programmer. For retrofitted type systems, it seems the current trend is using structural types. This paper attempts to answer the question to what extent this extra expressiveness is needed, and how the possible polymorphism in dynamic code is used in practise. We study polymorphism in 36 real-world open source Python programs and approximate to what extent nominal and structural types could be used to type these programs. The study is based on collecting traces from multiple runs of the programs and analysing the polymorphic degrees of targets at more than 7 million call-sites. Our results show that while polymorphism is used in all programs, the programs are to a great extent monomorphic. The polymorphism found is evenly distributed across libraries and program-specific code and occur both during program start-up and normal execution. Most programs contain a few ``megamorphic'' call-sites where receiver types vary widely. The non-monomorphic parts of the programs can to some extent be typed with nominal or structural types, but none of the approaches can type entire programs.</blockquote>

<p id="AlencarDaCosta2017" class="bib"><cite>AlencarDaCosta2017</cite>
Daniel Alencar da Costa, Shane McIntosh, Christoph Treude, Uirá Kulesza, and Ahmed E. Hassan:
"<a href="https://doi.org/10.1007/s10664-017-9548-7">The impact of rapid release cycles on the integration delay of fixed issues</a>".
<em>Empirical Software Engineering</em>, 23(2), 2017,
<a class="doi" href="https://doi.org/10.1007/s10664-017-9548-7">10.1007/s10664-017-9548-7</a>.
</p>
<blockquote class="abstract">The release frequency of software projects has increased in recent years. Adopters of so-called rapid releases—short release cycles, often on the order of weeks, days, or even hours—claim that they can deliver fixed issues (i.e., implemented bug fixes and new features) to users more quickly. However, there is little empirical evidence to support these claims. In fact, our prior work shows that code integration phases may introduce delays for rapidly releasing projects—98% of the fixed issues in the rapidly releasing Firefox project had their integration delayed by at least one release. To better understand the impact that rapid release cycles have on the integration delay of fixed issues, we perform a comparative study of traditional and rapid release cycles. Our comparative study has two parts: (i) a quantitative empirical analysis of 72,114 issue reports from the Firefox project, and a (ii) qualitative study involving 37 participants, who are contributors of the Firefox, Eclipse, and ArgoUML projects. Our study is divided into quantitative and qualitative analyses. Quantitative analyses reveal that, surprisingly, fixed issues take a median of 54% (57 days) longer to be integrated in rapid Firefox releases than the traditional ones. To investigate the factors that are related to integration delay in traditional and rapid release cycles, we train regression models that model whether a fixed issue will have its integration delayed or not. Our explanatory models achieve good discrimination (ROC areas of 0.80--0.84) and calibration scores (Brier scores of 0.05--0.16) for rapid and traditional releases. Our explanatory models indicate that (i) traditional releases prioritize the integration of backlog issues, while (ii) rapid releases prioritize issues that were fixed in the current release cycle. Complementary qualitative analyses reveal that participants' perception about integration delay is tightly related to activities that involve decision making, risk management, and team collaboration. Moreover, the allure of shipping fixed issues faster is a main motivator for adopting rapid release cycles among participants (although this motivation is not supported by our quantitative analysis). Furthermore, to explain why traditional releases deliver fixed issues more quickly, our participants point out the rush for integration in traditional releases and the increased time that is invested on polishing issues in rapid releases. Our results suggest that rapid release cycles may not be a silver bullet for the rapid delivery of new content to users. Instead, our results suggest that the benefits of rapid releases are increased software stability and user feedback.</blockquote>

<p id="Ali2020" class="bib"><cite>Ali2020</cite>
Rao Hamza Ali, Chelsea Parlett-Pelleriti, and Erik Linstead:
"<a href="https://doi.org/10.1145/3379597.3387511">Cheating death: a statistical survival analysis of publicly available Python projects</a>".
<em>Proceedings of the 17th International Conference on Mining Software Repositories</em>, <a class="doi" href="https://doi.org/10.1145/3379597.3387511">10.1145/3379597.3387511</a>.
</p>
<blockquote class="abstract">We apply survival analysis methods to a dataset of publicly-available software projects in order to examine the attributes that might lead to their inactivity over time. We ran a Kaplan-Meier analysis and fit a Cox Proportional-Hazards model to a subset of Software Heritage Graph Dataset, consisting of 3052 popular Python projects hosted on GitLab/GitHub, Debian, and PyPI, over a period of 165 months. We show that projects with repositories on multiple hosting services, a timeline of publishing major releases, and a good network of developers, remain healthy over time and should be worthy of the effort put in by developers and contributors.</blockquote>

<p id="Almeida2017" class="bib"><cite>Almeida2017</cite>
Daniel A. Almeida, Gail C. Murphy, Greg Wilson, and Mike Hoye:
"<a href="https://doi.org/10.1109/icpc.2017.7">do software developers understand open source licenses?</a>".
<em>2017 IEEE/ACM 25th International Conference on Program Comprehension (ICPC)</em>, <a class="doi" href="https://doi.org/10.1109/icpc.2017.7">10.1109/icpc.2017.7</a>.
</p>
<blockquote class="abstract">Software provided under open source licenses is widely used, from forming high-profile stand-alone applications (e.g., Mozilla Firefox) to being embedded in commercial offerings (e.g., network routers). Despite the high frequency of use of open source licenses, there has been little work about whether software developers understand the open source licenses they use. To our knowledge, only one survey has been conducted, which focused on which licenses developers choose and when they encounter problems with licensing open source software. To help fill the gap of whether or not developers understand the open source licenses they use, we conducted a survey that posed development scenarios involving three popular open source licenses (GNU GPL 3.0, GNU LGPL 3.0 and MPL 2.0) both alone and in combination. The 375 respondents to the survey, who were largely developers, gave answers consistent with those of a legal expert's opinion in 62% of 42 cases. Although developers clearly understood cases involving one license, they struggled when multiple licenses were involved. An analysis of the quantitative and qualitative results of the study indicate a need for tool support to help guide developers in understanding this critical information attached to software components.</blockquote>

<p id="Altadmri2015" class="bib"><cite>Altadmri2015</cite>
Amjad Altadmri and Neil C.C. Brown:
"<a href="https://doi.org/10.1145/2676723.2677258">37 million compilations: investigating novice programming mistakes in large-scale student data</a>".
<em>Proceedings of the 46th ACM Technical Symposium on Computer Science Education</em>, <a class="doi" href="https://doi.org/10.1145/2676723.2677258">10.1145/2676723.2677258</a>.
</p>
<blockquote class="abstract">Previous investigations of student errors have typically focused on samples of hundreds of students at individual institutions. This work uses a year's worth of compilation events from over 250,000 students all over the world, taken from the large Blackbox data set. We analyze the frequency, time-to-fix, and spread of errors among users, showing how these factors inter-relate, in addition to their development over the course of the year. These results can inform the design of courses, textbooks and also tools to target the most frequent (or hardest to fix) errors.</blockquote>

<p id="Ameller2012" class="bib"><cite>Ameller2012</cite>
David Ameller, Claudia Ayala, Jordi Cabot, and Xavier Franch:
"<a href="https://doi.org/10.1109/re.2012.6345838">How do software architects consider non-functional requirements: an exploratory study</a>".
<em>2012 20th IEEE International Requirements Engineering Conference (RE)</em>, <a class="doi" href="https://doi.org/10.1109/re.2012.6345838">10.1109/re.2012.6345838</a>.
</p>
<blockquote class="abstract">Dealing with non-functional requirements (NFRs) has posed a challenge onto software engineers for many years. Over the years, many methods and techniques have been proposed to improve their elicitation, documentation, and validation. Knowing more about the state of the practice on these topics may benefit both practitioners' and researchers' daily work. A few empirical studies have been conducted in the past, but none under the perspective of software architects, in spite of the great influence that NFRs have on daily architects' practices. This paper presents some of the findings of an empirical study based on 13 interviews with software architects. It addresses questions such as: who decides the NFRs, what types of NFRs matter to architects, how are NFRs documented, and how are NFRs validated. The results are contextualized with existing previous work.</blockquote>

<p id="Anda2009" class="bib"><cite>Anda2009</cite>
B.C.D. Anda, D.I.K. Sjøberg, and Audris Mockus:
"<a href="https://doi.org/10.1109/tse.2008.89">Variability and reproducibility in software engineering: a study of four companies that developed the same system</a>".
<em>IEEE Transactions on Software Engineering</em>, 35(3), 2009,
<a class="doi" href="https://doi.org/10.1109/tse.2008.89">10.1109/tse.2008.89</a>.
</p>
<blockquote class="abstract">The scientific study of a phenomenon requires it to be reproducible. Mature engineering industries are recognized by projects and products that are, to some extent, reproducible. Yet, reproducibility in software engineering (SE) has not been investigated thoroughly, despite the fact that lack of reproducibility has both practical and scientific consequences. We report a longitudinal multiple-case study of variations and reproducibility in software development, from bidding to deployment, on the basis of the same requirement specification. In a call for tender to 81 companies, 35 responded. Four of them developed the system independently. The firm price, planned schedule, and planned development process, had, respectively, ldquolow,rdquo ldquolow,rdquo and ldquomediumrdquo reproducibilities. The contractor's costs, actual lead time, and schedule overrun of the projects had, respectively, ldquomedium,rdquo ldquohigh,rdquo and ldquolowrdquo reproducibilities. The quality dimensions of the delivered products, reliability, usability, and maintainability had, respectively, ldquolow,rdquo "high,rdquo and ldquolowrdquo reproducibilities. Moreover, variability for predictable reasons is also included in the notion of reproducibility. We found that the observed outcome of the four development projects matched our expectations, which were formulated partially on the basis of SE folklore. Nevertheless, achieving more reproducibility in SE remains a great challenge for SE research, education, and industry.</blockquote>

<p id="Apel2011" class="bib"><cite>Apel2011</cite>
Sven Apel, Jörg Liebig, Benjamin Brandl, Christian Lengauer, and Christian Kästner:
"<a href="https://doi.org/10.1145/2025113.2025141">Semistructured merge: rethinking merge in revision control systems</a>".
<em>Proceedings of the 19th ACM SIGSOFT symposium and the 13th European conference on Foundations of software engineering - SIGSOFT/FSE '11</em>, <a class="doi" href="https://doi.org/10.1145/2025113.2025141">10.1145/2025113.2025141</a>.
</p>
<blockquote class="abstract">An ongoing problem in revision control systems is how to resolve conflicts in a merge of independently developed revisions. Unstructured revision control systems are purely text-based and solve conflicts based on textual similarity. Structured revision control systems are tailored to specific languages and use language-specific knowledge for conflict resolution. We propose semistructured revision control systems that inherit the strengths of both: the generality of unstructured systems and the expressiveness of structured systems. The idea is to provide structural information of the underlying software artifacts — declaratively, in the form of annotated grammars. This way, a wide variety of languages can be supported and the information provided can assist in the automatic resolution of two classes of conflicts: ordering conflicts and semantic conflicts. The former can be resolved independently of the language and the latter using specific conflict handlers. We have been developing a tool that supports semistructured merge and conducted an empirical study on 24 software projects developed in Java, C#, and Python comprising 180 merge scenarios. We found that semistructured merge reduces the number of conflicts in 60% of the sample merge scenarios by, on average, 34%, compared to unstructured merge. We found also that renaming is challenging in that it can increase the number of conflicts during semistructured merge, and that a combination of unstructured and semistructured merge is a pragmatic way to go.</blockquote>

<p id="Aurora2019" class="bib"><cite>Aurora2019</cite>
Valerie Aurora and Mary Gardiner:
<em>How to Respond to Code of Conduct Reports</em> (Version 1.1 edition).
Frame Shift Consulting LLC, 2019, 978-1386922575.
</p>
<blockquote class="abstract">A detailed, experience-based guide to handling what is often the most difficult situation in any project.</blockquote>

<h2 id="B">B</h2>

<p id="Balachandran2013" class="bib"><cite>Balachandran2013</cite>
Vipin Balachandran:
"<a href="https://doi.org/10.1109/icse.2013.6606642">Reducing human effort and improving quality in peer code reviews using automatic static analysis and reviewer recommendation</a>".
<em>2013 35th International Conference on Software Engineering (ICSE)</em>, <a class="doi" href="https://doi.org/10.1109/icse.2013.6606642">10.1109/icse.2013.6606642</a>.
</p>
<blockquote class="abstract">Peer code review is a cost-effective software defect detection technique. Tool assisted code review is a form of peer code review, which can improve both quality and quantity of reviews. However, there is a significant amount of human effort involved even in tool based code reviews. Using static analysis tools, it is possible to reduce the human effort by automating the checks for coding standard violations and common defect patterns. Towards this goal, we propose a tool called Review Bot for the integration of automatic static analysis with the code review process. Review Bot uses output of multiple static analysis tools to publish reviews automatically. Through a user study, we show that integrating static analysis tools with code review process can improve the quality of code review. The developer feedback for a subset of comments from automatic reviews shows that the developers agree to fix 93% of all the automatically generated comments. There is only 14.71% of all the accepted comments which need improvements in terms of priority, comment message, etc. Another problem with tool assisted code review is the assignment of appropriate reviewers. Review Bot solves this problem by generating reviewer recommendations based on change history of source code lines. Our experimental results show that the recommendation accuracy is in the range of 60%-92%, which is significantly better than a comparable method based on file change history.</blockquote>

<p id="Barbosa2014" class="bib"><cite>Barbosa2014</cite>
Eiji Adachi Barbosa, Alessandro Garcia, and Simone Diniz Junqueira Barbosa:
"<a href="https://doi.org/10.1109/sbes.2014.19">Categorizing faults in exception handling: a study of open source projects</a>".
<em>2014 Brazilian Symposium on Software Engineering</em>, <a class="doi" href="https://doi.org/10.1109/sbes.2014.19">10.1109/sbes.2014.19</a>.
</p>
<blockquote class="abstract">Even though exception handling mechanisms have been proposed as a means to improve software robustness, empirical evidence suggests that exception handling code is still poorly implemented in industrial systems. Moreover, it is often claimed that the poor quality of exception handling code can be a source of faults in a software system. However, there is still a gap in the literature in terms of better understanding exceptional faults, i.e., faults whose causes regard to exception handling. In particular, there is still little empirical knowledge about what are the specific causes of exceptional faults in software systems. In this paper we start to fill this gap by presenting a categorization of the causes of exceptional faults observed in two mainstream open source projects. We observed ten different categories of exceptional faults, most of which were never reported before in the literature. Our results pinpoint that current verification and validation mechanisms for exception handling code are still not properly addressing these categories of exceptional faults.</blockquote>

<p id="Barik2017" class="bib"><cite>Barik2017</cite>
Titus Barik, Justin Smith, Kevin Lubick, Elisabeth Holmes, Jing Feng, Emerson Murphy-Hill, and Chris Parnin:
"<a href="https://doi.org/10.1109/icse.2017.59">Do Developers Read Compiler Error Messages?</a>".
<em>2017 IEEE/ACM 39th International Conference on Software Engineering (ICSE)</em>, <a class="doi" href="https://doi.org/10.1109/icse.2017.59">10.1109/icse.2017.59</a>.
</p>
<blockquote class="abstract">In integrated development environments, developers receive compiler error messages through a variety of textual and visual mechanisms, such as popups and wavy red underlines. Although error messages are the primary means of communicating defects to developers, researchers have a limited understanding on how developers actually use these messages to resolve defects. To understand how developers use error messages, we conducted an eye tracking study with 56 participants from undergraduate and graduate software engineering courses at our university. The participants attempted to resolve common, yet problematic defects in a Java code base within the Eclipse development environment. We found that: 1) participants read error messages and the difficulty of reading these messages is comparable to the difficulty of reading source code, 2) difficulty reading error messages significantly predicts participants' task performance, and 3) participants allocate a substantial portion of their total task to reading error messages (13%-25%). The results of our study offer empirical justification for the need to improve compiler error messages for developers.</blockquote>

<p id="Barik2018" class="bib"><cite>Barik2018</cite>
Titus Barik, Denae Ford, Emerson Murphy-Hill, and Chris Parnin:
"<a href="https://doi.org/10.1145/3236024.3236040">How should compilers explain problems to developers?</a>".
<em>Proceedings of the 2018 26th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering</em>, <a class="doi" href="https://doi.org/10.1145/3236024.3236040">10.1145/3236024.3236040</a>.
</p>
<blockquote class="abstract">Compilers primarily give feedback about problems to developers through the use of error messages. Unfortunately, developers routinely find these messages to be confusing and unhelpful. In this paper, we postulate that because error messages present poor explanations, theories of explanation—such as Toulmin's model of argument—can be applied to improve their quality. To understand how compilers should present explanations to developers, we conducted a comparative evaluation with 68 professional software developers and an empirical study of compiler error messages found in Stack Overflow questions across seven different programming languages. Our findings suggest that, given a pair of error messages, developers significantly prefer the error message that employs proper argument structure over a deficient argument structure when neither offers a resolution—but will accept a deficient argument structure if it provides a resolution to the problem. Human-authored explanations on Stack Overflow converge to one of the three argument structures: those that provide a resolution to the error, simple arguments, and extended arguments that provide additional evidence for the problem. Finally, we contribute three practical design principles to inform the design and evaluation of compiler error messages.</blockquote>

<p id="Barnett2011" class="bib"><cite>Barnett2011</cite>
Mike Barnett, Manuel Fähndrich, K. Rustan M. Leino, Peter Müller, Wolfram Schulte, and Herman Venter:
"<a href="https://doi.org/10.1145/1953122.1953145">Specification and verification: the Spec# experience</a>".
<em>Communications of the ACM</em>, 54(6), 2011,
<a class="doi" href="https://doi.org/10.1145/1953122.1953145">10.1145/1953122.1953145</a>.
</p>
<blockquote class="abstract">Can a programming language really help programmers write better programs?</blockquote>

<p id="Barr2012" class="bib"><cite>Barr2012</cite>
Earl T. Barr, Christian Bird, Peter C. Rigby, Abram Hindle, Daniel M. German, and Premkumar Devanbu:
"<a href="https://doi.org/10.1007/978-3-642-28872-2_22">Cohesive and isolated development with branches</a>".
<em>Proceedings of the 15th international conference on Fundamental Approaches to Software Engineering</em>, <a class="doi" href="https://doi.org/10.1007/978-3-642-28872-2_22">10.1007/978-3-642-28872-2_22</a>.
</p>
<blockquote class="abstract">The adoption of distributed version control (DVC ), such as Git and Mercurial, in open-source software (OSS) projects has been explosive. Why is this and how are projects using DVC? This new generation of version control supports two important new features: distributed repositories and histories that preserve branches and merges. Through interviews with lead developers in OSS projects and a quantitative analysis of mined data from the histories of sixty project, we find that the vast majority of the projects now using DVC continue to use a centralized model of code sharing, while using branching much more extensively than before their transition to DVC. We then examine the Linux history in depth in an effort to understand and evaluate how branches are used and what benefits they provide. We find that they enable natural collaborative processes: DVC branching allows developers to collaborate on tasks in highly cohesive branches, while enjoying reduced interference from developers working on other tasks, even if those tasks are strongly coupled to theirs.</blockquote>

<p id="Barzilay2011" class="bib"><cite>Barzilay2011</cite>
Ohad Barzilay:
"<a href="https://doi.org/10.1145/2089131.2089135">Example embedding</a>".
<em>Proceedings of the 10th SIGPLAN symposium on New ideas, new paradigms, and reflections on programming and software - ONWARD '11</em>, <a class="doi" href="https://doi.org/10.1145/2089131.2089135">10.1145/2089131.2089135</a>.
</p>
<blockquote class="abstract">Using code examples in professional software development is like teenage sex. Those who say they do it all the time are probably lying. Although it is natural, those who do it feel guilty. Finally, once they start doing it, they are often not too concerned with safety, they discover that it is going to take a while to get really good at it, and they realize they will have to come up with a bunch of new ways of doing it before they really figure it all out.</blockquote>

<p id="Beck2011" class="bib"><cite>Beck2011</cite>
Fabian Beck and Stephan Diehl:
"<a href="https://doi.org/10.1145/2025113.2025162">On the congruence of modularity and code coupling</a>".
<em>Proceedings of the 19th ACM SIGSOFT symposium and the 13th European conference on Foundations of software engineering - SIGSOFT/FSE '11</em>, <a class="doi" href="https://doi.org/10.1145/2025113.2025162">10.1145/2025113.2025162</a>.
</p>
<blockquote class="abstract">Software systems are modularized to make their inherent complexity manageable. While there exists a set of well-known principles that may guide software engineers to design the modules of a software system, we do not know which principles are followed in practice. In a study based on 16 open source projects, we look at different kinds of coupling concepts between source code entities, including structural dependencies, fan-out similarity, evolutionary coupling, code ownership, code clones, and semantic similarity. The congruence between these coupling concepts and the modularization of the system hints at the modularity principles used in practice. Furthermore, the results provide insights on how to support developers to modularize software systems.</blockquote>

<p id="Becker2019" class="bib"><cite>Becker2019</cite>
Brett A. Becker, Paul Denny, Raymond Pettit, Durell Bouchard, Dennis J. Bouvier, Brian Harrington, Amir Kamil, Amey Karkare, Chris McDonald, Peter-Michael Osera, Janice L. Pearce, and James Prather:
"<a href="https://doi.org/10.1145/3344429.3372508">Compiler error messages considered unhelpful</a>".
<em>Proceedings of the Working Group Reports on Innovation and Technology in Computer Science Education</em>, <a class="doi" href="https://doi.org/10.1145/3344429.3372508">10.1145/3344429.3372508</a>.
</p>
<blockquote class="abstract">Diagnostic messages generated by compilers and interpreters such as syntax error messages have been researched for over half of a century. Unfortunately, these messages which include error, warning, and run-time messages, present substantial difficulty and could be more effective, particularly for novices. Recent years have seen an increased number of papers in the area including studies on the effectiveness of these messages, improving or enhancing them, and their usefulness as a part of programming process data that can be used to predict student performance, track student progress, and tailor learning plans. Despite this increased interest, the long history of literature is quite scattered and has not been brought together in any digestible form. In order to help the computing education community (and related communities) to further advance work on programming error messages, we present a comprehensive, historical and state-of-the-art report on research in the area. In addition, we synthesise and present the existing evidence for these messages including the difficulties they present and their effectiveness. We finally present a set of guidelines, curated from the literature, classified on the type of evidence supporting each one (historical, anecdotal, and empirical). This work can serve as a starting point for those who wish to conduct research on compiler error messages, runtime errors, and warnings. We also make the bibtex file of our 300+ reference corpus publicly available. Collectively this report and the bibliography will be useful to those who wish to design better messages or those that aim to measure their effectiveness, more effectively.</blockquote>

<p id="Begel2014" class="bib"><cite>Begel2014</cite>
Andrew Begel and Thomas Zimmermann:
"<a href="https://doi.org/10.1145/2568225.2568233">Analyze this! 145 questions for data scientists in software engineering</a>".
<em>Proceedings of the 36th International Conference on Software Engineering</em>, <a class="doi" href="https://doi.org/10.1145/2568225.2568233">10.1145/2568225.2568233</a>.
</p>
<blockquote class="abstract">In this paper, we present the results from two surveys related to data science applied to software engineering. The first survey solicited questions that software engineers would like data scientists to investigate about software, about software processes and practices, and about software engineers. Our analyses resulted in a list of 145 questions grouped into 12 categories. The second survey asked a different pool of software engineers to rate these 145 questions and identify the most important ones to work on first. Respondents favored questions that focus on how customers typically use their applications. We also saw opposition to questions that assess the performance of individual employees or compare them with one another. Our categorization and catalog of 145 questions can help researchers, practitioners, and educators to more easily focus their efforts on topics that are important to the software industry.</blockquote>

<p id="Behroozi2019" class="bib"><cite>Behroozi2019</cite>
Mahnaz Behroozi, Chris Parnin, and Titus Barik:
"<a href="https://doi.org/10.1109/vlhcc.2019.8818836">Hiring is Broken: What Do Developers Say About Technical Interviews?</a>".
<em>2019 IEEE Symposium on Visual Languages and Human-Centric Computing (VL/HCC)</em>, <a class="doi" href="https://doi.org/10.1109/vlhcc.2019.8818836">10.1109/vlhcc.2019.8818836</a>.
</p>
<blockquote class="abstract">Technical interviews—a problem-solving form of interview in which candidates write code—are commonplace in the software industry, and are used by several well-known companies including Facebook, Google, and Microsoft. These interviews are intended to objectively assess candidates and determine fit within the company. But what do developers say about them?To understand developer perceptions about technical interviews, we conducted a qualitative study using the online social news website, Hacker News—a venue for software practitioners. Hacker News posters report several concerns and negative perceptions about interviews, including their lack of real-world relevance, bias towards younger developers, and demanding time commitment. Posters report that these interviews cause unnecessary anxiety and frustration, requiring them to learn arbitrary, implicit, and obscure norms. The findings from our study inform inclusive hiring guidelines for technical interviews, such as collaborative problem-solving sessions.</blockquote>

<p id="Behroozi2020" class="bib"><cite>Behroozi2020</cite>
Mahnaz Behroozi, Shivani Shirolkar, Titus Barik, and Chris Parnin:
"<a href="https://doi.org/10.1145/3377815.3381372">Debugging Hiring: What Went Right and What Went Wrong in the Technical Interview Process</a>".
<em>International Conference on Software Engineering (ICSE 2020)</em>, <a class="doi" href="https://doi.org/10.1145/3377815.3381372">10.1145/3377815.3381372</a>.
</p>
<blockquote class="abstract">The typical hiring pipeline for software engineering occurs over several stages—from phone screening and technical on-site interviews, to offer and negotiation. When these hiring pipelines are "leaky," otherwise qualified candidates are lost at some stage of the pipeline. These leaky pipelines impact companies in several ways, including hindering a company's ability to recruit competitive candidates and build diverse software teams.To understand where candidates become disengaged in the hiring pipeline—and what companies can do to prevent it—we conducted a qualitative study on over 10,000 reviews on 19 companies from Glassdoor, a website where candidates can leave reviews about their hiring process experiences. We identified several poor practices which prematurely sabotage the hiring process—for example, not adequately communicating hiring criteria, conducting interviews with inexperienced interviewers, and ghosting candidates. Our findings provide a set of guidelines to help companies improve their hiring pipeline practices—such as being deliberate about phrasing and language during initial contact with the candidate, providing candidates with constructive feedback after their interviews, and bringing salary transparency and long-term career discussions into offers and negotiations. Operationalizing these guidelines helps make the hiring pipeline more transparent, fair, and inclusive.</blockquote>

<p id="Beller2015" class="bib"><cite>Beller2015</cite>
Moritz Beller, Georgios Gousios, Annibale Panichella, and Andy Zaidman:
"<a href="https://doi.org/10.1145/2786805.2786843">When, how, and why developers (do not) test in their IDEs</a>".
<em>Proceedings of the 2015 10th Joint Meeting on Foundations of Software Engineering</em>, <a class="doi" href="https://doi.org/10.1145/2786805.2786843">10.1145/2786805.2786843</a>.
</p>
<blockquote class="abstract">The research community in Software Engineering and Software Testing in particular builds many of its contributions on a set of mutually shared expectations. Despite the fact that they form the basis of many publications as well as open-source and commercial testing applications, these common expectations and beliefs are rarely ever questioned. For example, Frederic Brooks' statement that testing takes half of the development time seems to have manifested itself within the community since he first made it in the "Mythical Man Month" in 1975. With this paper, we report on the surprising results of a large-scale field study with 416 software engineers whose development activity we closely monitored over the course of five months, resulting in over 13 years of recorded work time in their integrated development environments (IDEs). Our findings question several commonly shared assumptions and beliefs about testing and might be contributing factors to the observed bug proneness of software in practice: the majority of developers in our study does not test; developers rarely run their tests in the IDE; Test-Driven Development (TDD) is not widely practiced; and, last but not least, software developers only spend a quarter of their work time engineering tests, whereas they think they test half of their time.</blockquote>

<p id="Beller2019" class="bib"><cite>Beller2019</cite>
Moritz Beller, Georgios Gousios, Annibale Panichella, Sebastian Proksch, Sven Amann, and Andy Zaidman:
"<a href="https://doi.org/10.1109/tse.2017.2776152">Developer Testing in the IDE: Patterns, Beliefs, and Behavior</a>".
<em>IEEE Transactions on Software Engineering</em>, 45(3), 2019,
<a class="doi" href="https://doi.org/10.1109/tse.2017.2776152">10.1109/tse.2017.2776152</a>.
</p>
<blockquote class="abstract">Software testing is one of the key activities to achieve software quality in practice. Despite its importance, however, we have a remarkable lack of knowledge on how developers test in real-world projects. In this paper, we report on a large-scale field study with 2,443 software engineers whose development activities we closely monitored over 2.5 years in four integrated development environments (IDEs). Our findings, which largely generalized across the studied IDEs and programming languages Java and C#, question several commonly shared assumptions and beliefs about developer testing: half of the developers in our study do not test; developers rarely run their tests in the IDE; most programming sessions end without any test execution; only once they start testing, do they do it extensively; a quarter of test cases is responsible for three quarters of all test failures; 12 percent of tests show flaky behavior; Test-Driven Development (TDD) is not widely practiced; and software developers only spend a quarter of their time engineering tests, whereas they think they test half of their time. We summarize these practices of loosely guiding one's development efforts with the help of testing in an initial summary on Test-Guided Development (TGD), a behavior we argue to be closer to the development reality of most developers than TDD.</blockquote>

<p id="BenAri2011" class="bib"><cite>BenAri2011</cite>
Mordechai Ben-Ari, Roman Bednarik, Ronit Ben-Bassat Levy, Gil Ebel, Andrés Moreno, Niko Myller, and Erkki Sutinen:
"<a href="https://doi.org/10.1016/j.jvlc.2011.04.004">A decade of research and development on program animation: the Jeliot experience</a>".
<em>Journal of Visual Languages &amp; Computing</em>, 22(5), 2011,
<a class="doi" href="https://doi.org/10.1016/j.jvlc.2011.04.004">10.1016/j.jvlc.2011.04.004</a>.
</p>
<blockquote class="abstract">Jeliot is a program animation system for teaching and learning elementary programming that has been developed over the past decade, building on the Eliot animation system developed several years before. Extensive pedagogical research has been done on various aspects of the use of Jeliot including improvements in learning, effects on attention, and acceptance by teachers. This paper surveys this research and development, and summarizes the experience and the lessons learned.</blockquote>

<p id="Beniamini2017" class="bib"><cite>Beniamini2017</cite>
Gal Beniamini, Sarah Gingichashvili, Alon Klein Orbach, and Dror G. Feitelson:
"<a href="https://doi.org/10.1109/icpc.2017.18">Meaningful identifier names: the case of single-letter variables</a>".
<em>2017 IEEE/ACM 25th International Conference on Program Comprehension (ICPC)</em>, <a class="doi" href="https://doi.org/10.1109/icpc.2017.18">10.1109/icpc.2017.18</a>.
</p>
<blockquote class="abstract">It is widely accepted that variable names in computer programs should be meaningful, and that this aids program comprehension. "Meaningful" is commonly interpreted as favoring long descriptive names. However, there is at least some use of short and even single-letter names: using i in loops is very common, and we show (by extracting variable names from 1000 popular GitHub projects in 5 languages) that some other letters are also widely used. In addition, controlled experiments with different versions of the same functions (specifically, different variable names) failed to show significant differences in ability to modify the code. Finally, an online survey showed that certain letters are strongly associated with certain types and meanings. This implies that a single letter can in fact convey meaning. The conclusion from all this is that single letter variables can indeed be used beneficially in certain cases, leading to more concise code.</blockquote>

<p id="Bettenburg2008" class="bib"><cite>Bettenburg2008</cite>
Nicolas Bettenburg, Sascha Just, Adrian Schröter, Cathrin Weiss, Rahul Premraj, and Thomas Zimmermann:
"<a href="https://doi.org/10.1145/1453101.1453146">What makes a good bug report?</a>".
<em>Proceedings of the 16th ACM SIGSOFT International Symposium on Foundations of software engineering - SIGSOFT '08/FSE-16</em>, <a class="doi" href="https://doi.org/10.1145/1453101.1453146">10.1145/1453101.1453146</a>.
</p>
<blockquote class="abstract">In software development, bug reports provide crucial information to developers. However, these reports widely differ in their quality. We conducted a survey among developers and users of APACHE, ECLIPSE, and MOZILLA to find out what makes a good bug report. The analysis of the 466 responses revealed an information mismatch between what developers need and what users supply. Most developers consider steps to reproduce, stack traces, and test cases as helpful, which are, at the same time, most difficult to provide for users. Such insight is helpful for designing new bug tracking tools that guide users at collecting and providing more helpful information. Our CUEZILLA prototype is such a tool and measures the quality of new bug reports; it also recommends which elements should be added to improve the quality. We trained CUEZILLA on a sample of 289 bug reports, rated by developers as part of the survey. The participants of our survey also provided 175 comments on hurdles in reporting and resolving bugs. Based on these comments, we discuss several recommendations for better bug tracking systems, which should focus on engaging bug reporters, better tool support, and improved handling of bug duplicates.</blockquote>

<p id="Bird2011" class="bib"><cite>Bird2011</cite>
Christian Bird, Nachiappan Nagappan, Brendan Murphy, Harald Gall, and Premkumar Devanbu:
"<a href="https://doi.org/10.1145/2025113.2025119">Don't touch my code!: examining the effects of ownership on software quality</a>".
<em>Proceedings of the 19th ACM SIGSOFT symposium and the 13th European conference on Foundations of software engineering - SIGSOFT/FSE '11</em>, <a class="doi" href="https://doi.org/10.1145/2025113.2025119">10.1145/2025113.2025119</a>.
</p>
<blockquote class="abstract">Ownership is a key aspect of large-scale software development. We examine the relationship between different ownership measures and software failures in two large software projects: Windows Vista and Windows 7. We find that in all cases, measures of ownership such as the number of low-expertise developers, and the proportion of ownership for the top owner have a relationship with both pre-release faults and post-release failures. We also empirically identify reasons that low-expertise developers make changes to components and show that the removal of low-expertise contributions dramatically decreases the performance of contribution based defect prediction. Finally we provide recommendations for source code change policies and utilization of resources such as code inspections based on our results.</blockquote>

<p id="Bluedorn1999" class="bib"><cite>Bluedorn1999</cite>
Allen C. Bluedorn, Daniel B. Turban, and Mary Sue Love:
"<a href="https://doi.org/10.1037/0021-9010.84.2.277">The effects of stand-up and sit-down meeting formats on meeting outcomes</a>".
<em>Journal of Applied Psychology</em>, 84(2), 1999,
<a class="doi" href="https://doi.org/10.1037/0021-9010.84.2.277">10.1037/0021-9010.84.2.277</a>.
</p>
<blockquote class="abstract">The effects of meeting format (standing or sitting) on meeting length and the quality of group decision making were investigated by comparing meeting outcomes for 56 five-member groups that conducted meetings in a standing format with 55 five-member groups that conducted meetings in a seated format. Sit-down meetings were 34% longer than stand-up meetings, but they produced no better decisions than stand-up meetings. Significant differences were also obtained for satisfaction with the meeting and task information use during the meeting but not for synergy or commitment to the group's decision. The findings were generally congruent with meeting-management recommendations in the time-management literature, although the lack of a significant difference for decision quality was contrary to theoretical expectations. This contrary finding may have been due to differences between the temporal context in which this study was conducted and those in which other time constraint research has been conducted, thereby revealing a potentially important contingency-temporal context.</blockquote>

<p id="Borle2017" class="bib"><cite>Borle2017</cite>
Neil C. Borle, Meysam Feghhi, Eleni Stroulia, Russell Greiner, and Abram Hindle:
"<a href="https://doi.org/10.1007/s10664-017-9576-3">Analyzing the effects of test driven development in GitHub</a>".
<em>Empirical Software Engineering</em>, 23(4), 2017,
<a class="doi" href="https://doi.org/10.1007/s10664-017-9576-3">10.1007/s10664-017-9576-3</a>.
</p>
<blockquote class="abstract">Testing is an integral part of the software development lifecycle, approached with varying degrees of rigor by different process models. Agile process models recommend Test Driven Development (TDD) as a key practice for reducing costs and improving code quality. The objective of this work is to perform a cost-benefit analysis of this practice. To that end, we have conducted a comparative analysis of GitHub repositories that adopts TDD to a lesser or greater extent, in order to determine how TDD affects software development productivity and software quality. We classified GitHub repositories archived in 2015 in terms of how rigorously they practiced TDD, thus creating a TDD spectrum. We then matched and compared various subsets of these repositories on this TDD spectrum with control sets of equal size. The control sets were samples from all GitHub repositories that matched certain characteristics, and that contained at least one test file. We compared how the TDD sets differed from the control sets on the following characteristics: number of test files, average commit velocity, number of bug-referencing commits, number of issues recorded, usage of continuous integration, number of pull requests, and distribution of commits per author. We found that Java TDD projects were relatively rare. In addition, there were very few significant differences in any of the metrics we used to compare TDD-like and non-TDD projects; therefore, our results do not reveal any observable benefits from using TDD.</blockquote>

<p id="Brown2018" class="bib"><cite>Brown2018</cite>
Neil C. C. Brown, Amjad Altadmri, Sue Sentance, and Michael Kölling:
"<a href="https://doi.org/10.1145/3230977.3230991">Blackbox, five years on: an evaluation of a large-scale programming data collection project</a>".
<em>Proceedings of the 2018 ACM Conference on International Computing Education Research</em>, <a class="doi" href="https://doi.org/10.1145/3230977.3230991">10.1145/3230977.3230991</a>.
</p>
<blockquote class="abstract">The Blackbox project has been collecting programming activity data from users of BlueJ (a novice-targeted Java development environment) for nearly five years. The resulting dataset of more than two terabytes of data has been made available to interested researchers from the outset. In this paper, we assess the impact of the Blackbox project: we perform a mapping study to assess eighteen publications which have made use of the Blackbox data, and we report on the advantages and difficulties experienced by researchers working with this data, collected via a survey. We find that Blackbox has enabled pieces of research which otherwise would not have been possible, but there remain technical challenges in the analysis. Some of these—but not all—relate to the scale of the data. We provide suggestions for the future use of Blackbox, and reflections on the role of such data collection projects in programming research.</blockquote>

<p id="Brun2011" class="bib"><cite>Brun2011</cite>
Yuriy Brun, Reid Holmes, Michael D. Ernst, and David Notkin:
"<a href="https://doi.org/10.1145/2025113.2025139">Proactive detection of collaboration conflicts</a>".
<em>Proceedings of the 19th ACM SIGSOFT symposium and the 13th European conference on Foundations of software engineering - SIGSOFT/FSE '11</em>, <a class="doi" href="https://doi.org/10.1145/2025113.2025139">10.1145/2025113.2025139</a>.
</p>
<blockquote class="abstract">Collaborative development can be hampered when conflicts arise because developers have inconsistent copies of a shared project. We present an approach to help developers identify and resolve conflicts early, before those conflicts become severe and before relevant changes fade away in the developers' memories. This paper presents three results. First, a study of open-source systems establishes that conflicts are frequent, persistent, and appear not only as overlapping textual edits but also as subsequent build and test failures. The study spans nine open-source systems totaling 3.4 million lines of code; our conflict data is derived from 550,000 development versions of the systems. Second, using previously-unexploited information, we precisely diagnose important classes of conflicts using the novel technique of speculative analysis over version control operations. Third, we describe the design of Crystal, a publicly-available tool that uses speculative analysis to make concrete advice unobtrusively available to developers, helping them identify, manage, and prevent conflicts.</blockquote>

<h2 id="C">C</h2>

<p id="Campos2017" class="bib"><cite>Campos2017</cite>
Eduardo Cunha Campos and Marcelo de Almeida Maia:
"<a href="https://doi.org/10.1109/esem.2017.55">Common bug-fix patterns: a large-scale observational study</a>".
<em>2017 ACM/IEEE International Symposium on Empirical Software Engineering and Measurement (ESEM)</em>, <a class="doi" href="https://doi.org/10.1109/esem.2017.55">10.1109/esem.2017.55</a>.
</p>
<blockquote class="abstract">[Background]: There are more bugs in real-world programs than human programmers can realistically address. Several approaches have been proposed to aid debugging. A recent research direction that has been increasingly gaining interest to address the reduction of costs associated with defect repair is automatic program repair. Recent work has shown that some kind of bugs are more suitable for automatic repair techniques. [Aim]: The detection and characterization of common bug-fix patterns in software repositories play an important role in advancing the field of automatic program repair. In this paper, we aim to characterize the occurrence of known bug-fix patterns in Java repositories at an unprecedented large scale. [Method]: The study was conducted for Java GitHub projects organized in two distinct data sets: the first one (i.e., Boa data set) contains more than 4 million bug-fix commits from 101,471 projects and the second one (i.e., Defects4J data set) contains 369 real bug fixes from five open-source projects. We used a domain-specific programming language called Boa in the first data set and conducted a manual analysis on the second data set in order to confront the results. [Results]: We characterized the prevalence of the five most common bug-fix patterns (identified in the work of Pan et al.) in those bug fixes. The combined results showed direct evidence that developers often forget to add IF preconditions in the code. Moreover, 76% of bug-fix commits associated with the IF-APC bug-fix pattern are isolated from the other four bug-fix patterns analyzed. [Conclusion]: Targeting on bugs that miss preconditions is a feasible alternative in automatic repair techniques that would produce a relevant payback.</blockquote>

<p id="Chen2016" class="bib"><cite>Chen2016</cite>
Tse-Hsun Chen, Weiyi Shang, Jinqiu Yang, Ahmed E. Hassan, Michael W. Godfrey, Mohamed Nasser, and Parminder Flora:
"<a href="https://doi.org/10.1145/2901739.2901758">An empirical study on the practice of maintaining object-relational mapping code in Java systems</a>".
<em>Proceedings of the 13th International Conference on Mining Software Repositories</em>, <a class="doi" href="https://doi.org/10.1145/2901739.2901758">10.1145/2901739.2901758</a>.
</p>
<blockquote class="abstract">Databases have become one of the most important components in modern software systems. For example, web services, cloud computing systems, and online transaction processing systems all rely heavily on databases. To abstract the complexity of accessing a database, developers make use of Object-Relational Mapping (ORM) frameworks. ORM frameworks provide an abstraction layer between the application logic and the underlying database. Such abstraction layer automatically maps objects in Object-Oriented Languages to database records, which significantly reduces the amount of boilerplate code that needs to be written. Despite the advantages of using ORM frameworks, we observe several difficulties in maintaining ORM code (i.e., code that makes use of ORM frameworks) when cooperating with our industrial partner. After conducting studies on other open source systems, we find that such difficulties are common in other Java systems. Our study finds that i) ORM cannot completely encapsulate database accesses in objects or abstract the underlying database technology, thus may cause ORM code changes more scattered; ii) ORM code changes are more frequent than regular code, but there is a lack of tools that help developers verify ORM code at compilation time; iii) we find that changes to ORM code are more commonly due to performance or security reasons; however, traditional static code analyzers need to be extended to capture the peculiarities of ORM code in order to detect such problems. Our study highlights the hidden maintenance costs of using ORM frameworks, and provides some initial insights about potential approaches to help maintain ORM code. Future studies should carefully examine ORM code, especially given the rising use of ORM in modern software systems.</blockquote>

<p id="Cherubini2007" class="bib"><cite>Cherubini2007</cite>
Mauro Cherubini, Gina Venolia, Rob DeLine, and Amy J. Ko:
"<a href="https://doi.org/10.1145/1240624.1240714">Let's go to the whiteboard: how and why software developers use drawings</a>".
<em>Proceedings of the SIGCHI Conference on Human Factors in Computing Systems</em>, <a class="doi" href="https://doi.org/10.1145/1240624.1240714">10.1145/1240624.1240714</a>.
</p>
<blockquote class="abstract">Software developers are rooted in the written form of their code, yet they often draw diagrams representing their code. Unfortunately, we still know little about how and why they create these diagrams, and so there is little research to inform the design of visual tools to support developers' work. This paper presents findings from semi-structured interviews that have been validated with a structured survey. Results show that most of the diagrams had a transient nature because of the high cost of changing whiteboard sketches to electronic renderings. Diagrams that documented design decisions were often externalized in these temporary drawings and then subsequently lost. Current visualization tools and the software development practices that we observed do not solve these issues, but these results suggest several directions for future research.</blockquote>

<p id="Chong2007" class="bib"><cite>Chong2007</cite>
Jan Chong and Tom Hurlbutt:
"<a href="https://doi.org/10.1109/icse.2007.87">The social dynamics of pair programming</a>".
<em>29th International Conference on Software Engineering (ICSE'07)</em>, <a class="doi" href="https://doi.org/10.1109/icse.2007.87">10.1109/icse.2007.87</a>.
</p>
<blockquote class="abstract">This paper presents data from a four month ethnographic study of professional pair programmers from two software development teams. Contrary to the current conception of pair programmers, the pairs in this study did not hew to the separate roles of "driver" and "navigator". Instead, the observed programmers moved together through different phases of the task, considering and discussing issues at the same strategic "range " or level of abstraction and in largely the same role. This form of interaction was reinforced by frequent switches in keyboard control during pairing and the use of dual keyboards. The distribution of expertise among the members of a pair had a strong influence on the tenor of pair programming interaction. Keyboard control had a consistent secondary effect on decisionmaking within the pair. These findings have implications for software development managers and practitioners as well as for the design of software development tools.</blockquote>

<p id="Cinneide2012" class="bib"><cite>Cinneide2012</cite>
Mel Ó Cinnéide, Laurence Tratt, Mark Harman, Steve Counsell, and Iman Hemati Moghadam:
"<a href="https://doi.org/10.1145/2372251.2372260">Experimental assessment of software metrics using automated refactoring</a>".
<em>Proceedings of the ACM-IEEE international symposium on Empirical software engineering and measurement - ESEM '12</em>, <a class="doi" href="https://doi.org/10.1145/2372251.2372260">10.1145/2372251.2372260</a>.
</p>
<blockquote class="abstract">A large number of software metrics have been proposed in the literature, but there is little understanding of how these metrics relate to one another. We propose a novel experimental technique, based on search-based refactoring, to assess software metrics and to explore relationships between them. Our goal is not to improve the program being refactored, but to assess the software metrics that guide the automated refactoring through repeated refactoring experiments. We apply our approach to five popular cohesion metrics using eight real-world Java systems, involving 300,000 lines of code and over 3,000 refactorings. Our results demonstrate that cohesion metrics disagree with each other in 55% of cases, and show how our approach can be used to reveal novel and surprising insights into the software metrics under investigation.</blockquote>

<p id="Coelho2016" class="bib"><cite>Coelho2016</cite>
Roberta Coelho, Lucas Almeida, Georgios Gousios, Arie van Deursen, and Christoph Treude:
"<a href="https://doi.org/10.1007/s10664-016-9443-7">Exception handling bug hazards in Android</a>".
<em>Empirical Software Engineering</em>, 22(3), 2016,
<a class="doi" href="https://doi.org/10.1007/s10664-016-9443-7">10.1007/s10664-016-9443-7</a>.
</p>
<blockquote class="abstract">Adequate handling of exceptions has proven difficult for many software engineers. Mobile app developers in particular, have to cope with compatibility, middleware, memory constraints, and battery restrictions. The goal of this paper is to obtain a thorough understanding of common exception handling bug hazards that app developers face. To that end, we first provide a detailed empirical study of over 6,000 Java exception stack traces we extracted from over 600 open source Android projects. Key insights from this study include common causes for system crashes, and common chains of wrappings between checked and unchecked exceptions. Furthermore, we provide a survey with 71 developers involved in at least one of the projects analyzed. The results corroborate the stack trace findings, and indicate that developers are unaware of frequently occurring undocumented exception handling behavior. Overall, the findings of our study call for tool support to help developers understand their own and third party exception handling and wrapping logic.</blockquote>

<p id="CruzLemus2009" class="bib"><cite>CruzLemus2009</cite>
José A. Cruz-Lemus, Marcela Genero, M. Esperanza Manso, Sandro Morasca, and Mario Piattini:
"<a href="https://doi.org/10.1007/s10664-009-9106-z">Assessing the understandability of UML statechart diagrams with composite states—a family of empirical studies</a>".
<em>Empirical Software Engineering</em>, 14(6), 2009,
<a class="doi" href="https://doi.org/10.1007/s10664-009-9106-z">10.1007/s10664-009-9106-z</a>.
</p>
<blockquote class="abstract">The main goal of this work is to present a family of empirical studies that we have carried out to investigate whether the use of composite states may improve the understandability of UML statechart diagrams derived from class diagrams. Our hypotheses derive from conventional wisdom, which says that hierarchical modeling mechanisms are helpful in mastering the complexity of a software system. In our research, we have carried out three empirical studies, consisting of five experiments in total. The studies differed somewhat as regards the size of the UML statechart models, though their size and the complexity of the models were chosen so that they could be analyzed by the subjects within a limited time period. The studies also differed with respect to the type of subjects (students vs. professionals), the familiarity of the subjects with the domains of the diagrams, and other factors. To integrate the results obtained from each of the five experiments, we performed a meta-analysis study which allowed us to take into account the differences between studies and to obtain the overall effect that the use of composite states has on the understandability of UML statechart diagrams throughout all the experiments. The results obtained are not completely conclusive. They cast doubts on the usefulness of composite states for a better understanding and memorizing of UML statechart diagrams. Composite states seem only to be helpful for acquiring knowledge from the diagrams. At any rate, it should be noted that these results are affected by the previous experience of the subjects on modeling, as well as by the size and complexity of the UML statechart diagrams we used, so care should be taken when generalizing our results.</blockquote>

<h2 id="D">D</h2>

<p id="Dabbish2012" class="bib"><cite>Dabbish2012</cite>
Laura Dabbish, Colleen Stuart, Jason Tsay, and Jim Herbsleb:
"<a href="https://doi.org/10.1145/2145204.2145396">Social coding in GitHub: transparency and collaboration in an open software repository</a>".
<em>Proceedings of the ACM 2012 conference on Computer Supported Cooperative Work - CSCW '12</em>, <a class="doi" href="https://doi.org/10.1145/2145204.2145396">10.1145/2145204.2145396</a>.
</p>
<blockquote class="abstract">Social applications on the web let users track and follow the activities of a large number of others regardless of location or affiliation. There is a potential for this transparency to radically improve collaboration and learning in complex knowledge-based activities. Based on a series of in-depth interviews with central and peripheral GitHub users, we examined the value of transparency for large-scale distributed collaborations and communities of practice. We find that people make a surprisingly rich set of social inferences from the networked activity information in GitHub, such as inferring someone else's technical goals and vision when they edit code, or guessing which of several similar projects has the best chance of thriving in the long term. Users combine these inferences into effective strategies for coordinating work, advancing technical skills and managing their reputation.</blockquote>

<p id="Dagenais2010" class="bib"><cite>Dagenais2010</cite>
Barthélémy Dagenais and Martin P. Robillard:
"<a href="https://doi.org/10.1145/1882291.1882312">Creating and evolving developer documentation</a>".
<em>Proceedings of the eighteenth ACM SIGSOFT international symposium on Foundations of software engineering - FSE '10</em>, <a class="doi" href="https://doi.org/10.1145/1882291.1882312">10.1145/1882291.1882312</a>.
</p>
<blockquote class="abstract">Developer documentation helps developers learn frameworks and libraries. To better understand how documentation in open source projects is created and maintained, we performed a qualitative study in which we interviewed core contributors who wrote developer documentation and developers who read documentation. In addition, we studied the evolution of 19 documents by analyzing more than 1500 document revisions. We identified the decisions that contributors make, the factors influencing these decisions and the consequences for the project. Among many findings, we observed how working on the documentation could improve the code quality and how constant interaction with the projects' community positively impacted the documentation.</blockquote>

<p id="Dang2012" class="bib"><cite>Dang2012</cite>
Yingnong Dang, Rongxin Wu, Hongyu Zhang, Dongmei Zhang, and Peter Nobel:
"<a href="https://doi.org/10.1109/icse.2012.6227111">ReBucket: a method for clustering duplicate crash reports based on call stack similarity</a>".
<em>2012 34th International Conference on Software Engineering (ICSE)</em>, <a class="doi" href="https://doi.org/10.1109/icse.2012.6227111">10.1109/icse.2012.6227111</a>.
</p>
<blockquote class="abstract">Software often crashes. Once a crash happens, a crash report could be sent to software developers for investigation upon user permission. To facilitate efficient handling of crashes, crash reports received by Microsoft's Windows Error Reporting (WER) system are organized into a set of "buckets". Each bucket contains duplicate crash reports that are deemed as manifestations of the same bug. The bucket information is important for prioritizing efforts to resolve crashing bugs. To improve the accuracy of bucketing, we propose ReBucket, a method for clustering crash reports based on call stack matching. ReBucket measures the similarities of call stacks in crash reports and then assigns the reports to appropriate buckets based on the similarity values. We evaluate ReBucket using crash data collected from five widely-used Microsoft products. The results show that ReBucket achieves better overall performance than the existing methods. On average, the F-measure obtained by ReBucket is about 0.88.</blockquote>

<p id="Davis2019" class="bib"><cite>Davis2019</cite>
James C. Davis, Louis G. Michael IV, Christy A. Coghlan, Francisco Servant, and Dongyoon Lee:
"<a href="https://doi.org/10.1145/3338906.3338909">Why aren't regular expressions a lingua franca? An empirical study on the re-use and portability of regular expressions</a>".
<em>Proceedings of the 2019 27th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering</em>, <a class="doi" href="https://doi.org/10.1145/3338906.3338909">10.1145/3338906.3338909</a>.
</p>
<blockquote class="abstract">This paper explores the extent to which regular expressions (regexes) are portable across programming languages. Many languages offer similar regex syntaxes, and it would be natural to assume that regexes can be ported across language boundaries. But can regexes be copy/pasted across language boundaries while retaining their semantic and performance characteristics? In our survey of 158 professional software developers, most indicated that they re-use regexes across language boundaries and about half reported that they believe regexes are a universal language. We experimentally evaluated the riskiness of this practice using a novel regex corpus—537,806 regexes from 193,524 projects written in JavaScript, Java, PHP, Python, Ruby, Go, Perl, and Rust. Using our polyglot regex corpus, we explored the hitherto-unstudied regex portability problems: logic errors due to semantic differences, and security vulnerabilities due to performance differences. We report that developers’ belief in a regex lingua franca is understandable but unfounded. Though most regexes compile across language boundaries, 15% exhibit semantic differences across languages and 10% exhibit performance differences across languages. We explained these differences using regex documentation, and further illuminate our findings by investigating regex engine implementations. Along the way we found bugs in the regex engines of JavaScript-V8, Python, Ruby, and Rust, and potential semantic and performance regex bugs in thousands of modules.</blockquote>

<p id="DeLucia2009" class="bib"><cite>DeLucia2009</cite>
Andrea De Lucia, Carmine Gravino, Rocco Oliveto, and Genoveffa Tortora:
"<a href="https://doi.org/10.1007/s10664-009-9127-7">An experimental comparison of ER and UML class diagrams for data modelling</a>".
<em>Empirical Software Engineering</em>, 15(5), 2009,
<a class="doi" href="https://doi.org/10.1007/s10664-009-9127-7">10.1007/s10664-009-9127-7</a>.
</p>
<blockquote class="abstract">We present the results of three sets of controlled experiments aimed at analysing whether UML class diagrams are more comprehensible than ER diagrams during data models maintenance. In particular, we considered the support given by the two notations in the comprehension and interpretation of data models, comprehension of the change to perform to meet a change request, and detection of defects contained in a data model. The experiments involved university students with different levels of ability and experience. The results demonstrate that using UML class diagrams subjects achieved better comprehension levels. With regard to the support given by the two notations during maintenance activities the results demonstrate that the two notations give the same support, while in general UML class diagrams provide a better support with respect to ER diagrams during verification activities.</blockquote>

<p id="DePadua2018" class="bib"><cite>DePadua2018</cite>
Guilherme B. de Pádua and Weiyi Shang:
"<a href="https://doi.org/10.1145/3196398.3196435">Studying the relationship between exception handling practices and post-release defects</a>".
<em>Proceedings of the 15th International Conference on Mining Software Repositories</em>, <a class="doi" href="https://doi.org/10.1145/3196398.3196435">10.1145/3196398.3196435</a>.
</p>
<blockquote class="abstract">Modern programming languages, such as Java and C#, typically provide features that handle exceptions. These features separate error-handling code from regular source code and aim to assist in the practice of software comprehension and maintenance. Nevertheless, their misuse can still cause reliability degradation or even catastrophic software failures. Prior studies on exception handling revealed the suboptimal practices of the exception handling flows and the prevalence of their anti-patterns. However, little is known about the relationship between exception handling practices and software quality. In this work, we investigate the relationship between software quality (measured by the probability of having post-release defects) and: (i) exception flow characteristics and (ii) 17 exception handling anti-patterns. We perform a case study on three Java and C# open-source projects. By building statistical models of the probability of post-release defects using traditional software metrics and metrics that are associated with exception handling practice, we study whether exception flow characteristics and exception handling anti-patterns have a statistically significant relationship with post-release defects. We find that exception flow characteristics in Java projects have a significant relationship with post-release defects. In addition, although the majority of the exception handing anti-patterns are not significant in the models, there exist anti-patterns that can provide significant explanatory power to the probability of post-release defects. Therefore, development teams should consider allocating more resources to improving their exception handling practices and avoid the anti-patterns that are found to have a relationship with post-release defects. Our findings also highlight the need for techniques that assist in handling exceptions in the software development practice.</blockquote>

<p id="Dzidek2008" class="bib"><cite>Dzidek2008</cite>
W.J. Dzidek, E. Arisholm, and L.C. Briand:
"<a href="https://doi.org/10.1109/tse.2008.15">A realistic empirical evaluation of the costs and benefits of UML in software maintenance</a>".
<em>IEEE Transactions on Software Engineering</em>, 34(3), 2008,
<a class="doi" href="https://doi.org/10.1109/tse.2008.15">10.1109/tse.2008.15</a>.
</p>
<blockquote class="abstract">The Unified Modeling Language (UML) is the de facto standard for object-oriented software analysis and design modeling. However, few empirical studies exist that investigate the costs and evaluate the benefits of using UML in realistic contexts. Such studies are needed so that the software industry can make informed decisions regarding the extent to which they should adopt UML in their development practices. This is the first controlled experiment that investigates the costs of maintaining and the benefits of using UML documentation during the maintenance and evolution of a real, non-trivial system, using professional developers as subjects, working with a state-of-the-art UML tool during an extended period of time. The subjects in the control group had no UML documentation. In this experiment, the subjects in the UML group had on average a practically and statistically significant 54% increase in the functional correctness of changes (p=0.03), and an insignificant 7% overall improvement in design quality (p=0.22) - though a much larger improvement was observed on the first change task (56%) - at the expense of an insignificant 14% increase in development time caused by the overhead of updating the UML documentation (p=0.35).</blockquote>

<h2 id="E">E</h2>

<p id="Eichberg2015" class="bib"><cite>Eichberg2015</cite>
Michael Eichberg, Ben Hermann, Mira Mezini, and Leonid Glanz:
"<a href="https://doi.org/10.1145/2786805.2786865">Hidden truths in dead software paths</a>".
<em>Proceedings of the 2015 10th Joint Meeting on Foundations of Software Engineering</em>, <a class="doi" href="https://doi.org/10.1145/2786805.2786865">10.1145/2786805.2786865</a>.
</p>
<blockquote class="abstract">Approaches and techniques for statically finding a multitude of issues in source code have been developed in the past. A core property of these approaches is that they are usually targeted towards finding only a very specific kind of issue and that the effort to develop such an analysis is significant. This strictly limits the number of kinds of issues that can be detected. In this paper, we discuss a generic approach based on the detection of infeasible paths in code that can discover a wide range of code smells ranging from useless code that hinders comprehension to real bugs. Code issues are identified by calculating the difference between the control-flow graph that contains all technically possible edges and the corresponding graph recorded while performing a more precise analysis using abstract interpretation. We have evaluated the approach using the Java Development Kit as well as the Qualitas Corpus (a curated collection of over 100 Java Applications) and were able to find thousands of issues across a wide range of categories.</blockquote>

<p id="ElEmam2001" class="bib"><cite>ElEmam2001</cite>
K. El Emam, S. Benlarbi, N. Goel, and S.N. Rai:
"<a href="https://doi.org/10.1109/32.935855">The confounding effect of class size on the validity of object-oriented metrics</a>".
<em>IEEE Transactions on Software Engineering</em>, 27(7), 2001,
<a class="doi" href="https://doi.org/10.1109/32.935855">10.1109/32.935855</a>.
</p>
<blockquote class="abstract">Much effort has been devoted to the development and empirical validation of object-oriented metrics. The empirical validations performed thus far would suggest that a core set of validated metrics is close to being identified. However, none of these studies allow for the potentially confounding effect of class size. We demonstrate a strong size confounding effect and question the results of previous object-oriented metrics validation studies. We first investigated whether there is a confounding effect of class size in validation studies of object-oriented metrics and show that, based on previous work, there is reason to believe that such an effect exists. We then describe a detailed empirical methodology for identifying those effects. Finally, we perform a study on a large C++ telecommunications framework to examine if size is really a confounder. This study considered the Chidamber and Kemerer metrics and a subset of the Lorenz and Kidd metrics. The dependent variable was the incidence of a fault attributable to a field failure (fault-proneness of a class). Our findings indicate that, before controlling for size, the results are very similar to previous studies. The metrics that are expected to be validated are indeed associated with fault-proneness.</blockquote>

<h2 id="F">F</h2>

<p id="Fischer2015" class="bib"><cite>Fischer2015</cite>
Lars Fischer and Stefan Hanenberg:
"<a href="https://doi.org/10.1145/2816707.2816720">An empirical investigation of the effects of type systems and code completion on API usability using TypeScript and JavaScript in MS Visual Studio</a>".
<em>Proceedings of the 11th Symposium on Dynamic Languages</em>, <a class="doi" href="https://doi.org/10.1145/2816707.2816720">10.1145/2816707.2816720</a>.
</p>
<blockquote class="abstract">Recent empirical studies that compared static and dynamic type systems on API usability showed a positive impact of static type systems on developer productivity in most cases. Nevertheless, it is unclear how large this effect is in comparison to other factors. One obvious factor in programming is tooling: It is commonly accepted that modern IDEs have a large positive impact on developers, although it is not clear which parts of modern IDEs are responsible for that. One possible—and for most developers obvious candidate—is code completion. This paper describes a 2x2 randomized trial that compares JavaScript and Microsoft's statically typed alternative TypeScript with and without code completion in MS Visual Studio. While the experiment shows (in correspondence to previous experiments) a large positive effect of the statically typed language TypeScript, the code completion effect is not only marginal, but also just approaching statistical significance. This seems to be an indicator that the effect of static type systems is larger than often assumed, at least in comparison to code completion.</blockquote>

<p id="Ford2016" class="bib"><cite>Ford2016</cite>
Denae Ford, Justin Smith, Philip J. Guo, and Chris Parnin:
"<a href="https://doi.org/10.1145/2950290.2950331">Paradise unplugged: identifying barriers for female participation on Stack Overflow</a>".
<em>Proceedings of the 2016 24th ACM SIGSOFT International Symposium on Foundations of Software Engineering</em>, <a class="doi" href="https://doi.org/10.1145/2950290.2950331">10.1145/2950290.2950331</a>.
</p>
<blockquote class="abstract">It is no secret that females engage less in programming fields than males. However, in online communities, such as Stack Overflow, this gender gap is even more extreme: only 5.8% of contributors are female. In this paper, we use a mixed-methods approach to identify contribution barriers females face in online communities. Through 22 semi-structured interviews with a spectrum of female users ranging from non-contributors to a top 100 ranked user of all time, we identified 14 barriers preventing them from contributing to Stack Overflow. We then conducted a survey with 1470 female and male developers to confirm which barriers are gender related or general problems for everyone. Females ranked five barriers significantly higher than males. A few of these include doubts in the level of expertise needed to contribute, feeling overwhelmed when competing with a large number of users, and limited awareness of site features. Still, there were other barriers that equally impacted all Stack Overflow users or affected particular groups, such as industry programmers. Finally, we describe several implications that may encourage increased participation in the Stack Overflow community across genders and other demographics.</blockquote>

<p id="Ford2017" class="bib"><cite>Ford2017</cite>
Denae Ford, Tom Zimmermann, Christian Bird, and Nachiappan Nagappan:
"<a href="https://doi.org/10.1109/esem.2017.54">Characterizing Software Engineering Work with Personas Based on Knowledge Worker Actions</a>".
<em>2017 ACM/IEEE International Symposium on Empirical Software Engineering and Measurement (ESEM)</em>, <a class="doi" href="https://doi.org/10.1109/esem.2017.54">10.1109/esem.2017.54</a>.
</p>
<blockquote class="abstract">Mistaking versatility for universal skills, some companies tend to categorize all software engineers the same not knowing a difference exists. For example, a company may select one of many software engineers to complete a task, later finding that the engineer's skills and style do not match those needed to successfully complete that task. This can result in delayed task completion and demonstrates that a one-size fits all concept should not apply to how software engineers work. In order to gain a comprehensive understanding of different software engineers and their working styles we interviewed 21 participants and surveyed 868 software engineers at a large software company and asked them about their work in terms of knowledge worker actions. We identify how tasks, collaboration styles, and perspectives of autonomy can significantly effect different approaches to software engineering work. To characterize differences, we describe empirically informed personas on how they work. Our defined software engineering personas include those with focused debugging abilities, engineers with an active interest in learning, experienced advisors who serve as experts in their role, and more. Our study and results serve as a resource for building products, services, and tools around these software engineering personas.</blockquote>

<p id="Ford2019" class="bib"><cite>Ford2019</cite>
Denae Ford, Mahnaz Behroozi, Alexander Serebrenik, and Chris Parnin:
"<a href="https://doi.org/10.1109/icse-seis.2019.00014">Beyond the code itself: how programmers really look at pull requests</a>".
<em>2019 IEEE/ACM 41st International Conference on Software Engineering: Software Engineering in Society (ICSE-SEIS)</em>, <a class="doi" href="https://doi.org/10.1109/icse-seis.2019.00014">10.1109/icse-seis.2019.00014</a>.
</p>
<blockquote class="abstract">Developers in open source projects must make decisions on contributions from other community members, such as whether or not to accept a pull request. However, secondary factors-beyond the code itself-can influence those decisions. For example, signals from GitHub profiles, such as a number of followers, activity, names, or gender can also be considered when developers make decisions. In this paper, we examine how developers use these signals (or not) when making decisions about code contributions. To evaluate this question, we evaluate how signals related to perceived gender identity and code quality influenced decisions on accepting pull requests. Unlike previous work, we analyze this decision process with data collected from an eye-tracker. We analyzed differences in what signals developers said are important for themselves versus what signals they actually used to make decisions about others. We found that after the code snippet (x=57%), the second place programmers spent their time fixating is on supplemental technical signals (x=32%), such as previous contributions and popular repositories. Diverging from what participants reported themselves, we also found that programmers fixated on social signals more than recalled.</blockquote>

<p id="Freeman1972" class="bib"><cite>Freeman1972</cite>
Jo Freeman:
"The Tyranny of Structurelessness".
<em>The Second Wave</em>, 2(1), 1972.
</p>
<blockquote class="abstract">An influential essay pointing out that every organization has a power structure; the only question is whether it's formal and accountable, or informal and unaccountable.</blockquote>

<p id="Fucci2016" class="bib"><cite>Fucci2016</cite>
Davide Fucci, Giuseppe Scanniello, Simone Romano, Martin Shepperd, Boyce Sigweni, Fernando Uyaguari, Burak Turhan, Natalia Juristo, and Markku Oivo:
"<a href="https://doi.org/10.1145/2961111.2962592">An external replication on the effects of test-driven development using a multi-site blind analysis approach</a>".
<em>Proceedings of the 10th ACM/IEEE International Symposium on Empirical Software Engineering and Measurement</em>, <a class="doi" href="https://doi.org/10.1145/2961111.2962592">10.1145/2961111.2962592</a>.
</p>
<blockquote class="abstract">Context: Test-driven development (TDD) is an agile practice claimed to improve the quality of a software product, as well as the productivity of its developers. A previous study (i.e., baseline experiment) at the University of Oulu (Finland) compared TDD to a test-last development (TLD) approach through a randomized controlled trial. The results failed to support the claims. Goal: We want to validate the original study results by replicating it at the University of Basilicata (Italy), using a different design. Method: We replicated the baseline experiment, using a crossover design, with 21 graduate students. We kept the settings and context as close as possible to the baseline experiment. In order to limit researchers bias, we involved two other sites (UPM, Spain, and Brunel, UK) to conduct blind analysis of the data. Results: The Kruskal-Wallis tests did not show any significant difference between TDD and TLD in terms of testing effort (p-value = .27), external code quality (p-value = .82), and developers' productivity (p-value = .83). Nevertheless, our data revealed a difference based on the order in which TDD and TLD were applied, though no carry over effect. Conclusions: We verify the baseline study results, yet our results raises concerns regarding the selection of experimental objects, particularly with respect to their interaction with the order in which of treatments are applied. We recommend future studies to survey the tasks used in experiments evaluating TDD. Finally, to lower the cost of replication studies and reduce researchers' bias, we encourage other research groups to adopt similar multi-site blind analysis approach described in this paper.</blockquote>

<h2 id="G">G</h2>

<p id="Gao2017" class="bib"><cite>Gao2017</cite>
Zheng Gao, Christian Bird, and Earl T. Barr:
"<a href="https://doi.org/10.1109/icse.2017.75">To type or not to type: quantifying detectable bugs in JavaScript</a>".
<em>2017 IEEE/ACM 39th International Conference on Software Engineering (ICSE)</em>, <a class="doi" href="https://doi.org/10.1109/icse.2017.75">10.1109/icse.2017.75</a>.
</p>
<blockquote class="abstract">JavaScript is growing explosively and is now used in large mature projects even outside the web domain. JavaScript is also a dynamically typed language for which static type systems, notably Facebook's Flow and Microsoft's TypeScript, have been written. What benefits do these static type systems provide? Leveraging JavaScript project histories, we select a fixed bug and check out the code just prior to the fix. We manually add type annotations to the buggy code and test whether Flow and TypeScript report an error on the buggy code, thereby possibly prompting a developer to fix the bug before its public release. We then report the proportion of bugs on which these type systems reported an error. Evaluating static type systems against public bugs, which have survived testing and review, is conservative: it understates their effectiveness at detecting bugs during private development, not to mention their other benefits such as facilitating code search/completion and serving as documentation. Despite this uneven playing field, our central finding is that both static type systems find an important percentage of public bugs: both Flow 0.30 and TypeScript 2.0 successfully detect 15%!.</blockquote>

<p id="Gauthier2013" class="bib"><cite>Gauthier2013</cite>
Francois Gauthier and Ettore Merlo:
"<a href="https://doi.org/10.1109/icse.2013.6606670">Semantic smells and errors in access control models: a case study in PHP</a>".
<em>2013 35th International Conference on Software Engineering (ICSE)</em>, <a class="doi" href="https://doi.org/10.1109/icse.2013.6606670">10.1109/icse.2013.6606670</a>.
</p>
<blockquote class="abstract">Access control models implement mechanisms to restrict access to sensitive data from unprivileged users. Access controls typically check privileges that capture the semantics of the operations they protect. Semantic smells and errors in access control models stem from privileges that are partially or totally unrelated to the action they protect. This paper presents a novel approach, partly based on static analysis and information retrieval techniques, for the automatic detection of semantic smells and errors in access control models. Investigation of the case study application revealed 31 smells and 2 errors. Errors were reported to developers who quickly confirmed their relevance and took actions to correct them. Based on the obtained results, we also propose three categories of semantic smells and errors to lay the foundations for further research on access control smells in other systems and domains.</blockquote>

<p id="Ghiotto2020" class="bib"><cite>Ghiotto2020</cite>
Gleiph Ghiotto, Leonardo Murta, Marcio Barros, and André van der Hoek:
"<a href="https://doi.org/10.1109/tse.2018.2871083">On the nature of merge conflicts: a study of 2,731 open source Java projects hosted by GitHub</a>".
<em>IEEE Transactions on Software Engineering</em>, 46(8), 2020,
<a class="doi" href="https://doi.org/10.1109/tse.2018.2871083">10.1109/tse.2018.2871083</a>.
</p>
<blockquote class="abstract">When multiple developers change a software system in parallel, these concurrent changes need to be merged to all appear in the software being developed. Numerous merge techniques have been proposed to support this task, but none of them can fully automate the merge process. Indeed, it has been reported that as much as 10 to 20 percent of all merge attempts result in a merge conflict, meaning that a developer has to manually complete the merge. To date, we have little insight into the nature of these merge conflicts. What do they look like, in detail? How do developers resolve them? Do any patterns exist that might suggest new merge techniques that could reduce the manual effort? This paper contributes an in-depth study of the merge conflicts found in the histories of 2,731 open source Java projects. Seeded by the manual analysis of the histories of five projects, our automated analysis of all 2,731 projects: (1) characterizes the merge conflicts in terms of number of chunks, size, and programming language constructs involved, (2) classifies the manual resolution strategies that developers use to address these merge conflicts, and (3) analyzes the relationships between various characteristics of the merge conflicts and the chosen resolution strategies. Our results give rise to three primary recommendations for future merge techniques, that—when implemented—could on one hand help in automatically resolving certain types of conflicts and on the other hand provide the developer with tool-based assistance to more easily resolve other types of conflicts that cannot be automatically resolved.</blockquote>

<p id="Giger2011" class="bib"><cite>Giger2011</cite>
Emanuel Giger, Martin Pinzger, and Harald Gall:
"<a href="https://doi.org/10.1145/2024445.2024455">Using the Gini Coefficient for bug prediction in Eclipse</a>".
<em>Proceedings of the 12th international workshop and the 7th annual ERCIM workshop on Principles on software evolution and software evolution - IWPSE-EVOL '11</em>, <a class="doi" href="https://doi.org/10.1145/2024445.2024455">10.1145/2024445.2024455</a>.
</p>
<blockquote class="abstract">The Gini coefficient is a prominent measure to quantify the inequality of a distribution. It is often used in the field of economy to describe how goods, e.g., wealth or farmland, are distributed among people. We use the Gini coefficient to measure code ownership by investigating how changes made to source code are distributed among the developer population. The results of our study with data from the Eclipse platform show that less bugs can be expected if a large share of all changes are accumulated, i.e., carried out, by relatively few developers.</blockquote>

<p id="Gousios2016" class="bib"><cite>Gousios2016</cite>
Georgios Gousios, Margaret-Anne Storey, and Alberto Bacchelli:
"<a href="https://doi.org/10.1145/2884781.2884826">Work practices and challenges in pull-based development</a>".
<em>Proceedings of the 38th International Conference on Software Engineering</em>, <a class="doi" href="https://doi.org/10.1145/2884781.2884826">10.1145/2884781.2884826</a>.
</p>
<blockquote class="abstract">The pull-based development model is an emerging way of contributing to distributed software projects that is gaining enormous popularity within the open source software (OSS) world. Previous work has examined this model by focusing on projects and their owners—we complement it by examining the work practices of project contributors and the challenges they face. We conducted a survey with 645 top contributors to active OSS projects using the pull-based model on GitHub, the prevalent social coding site. We also analyzed traces extracted from corresponding GitHub repositories. Our research shows that: contributors have a strong interest in maintaining awareness of project status to get inspiration and avoid duplicating work, but they do not actively propagate information; communication within pull requests is reportedly limited to low-level concerns and contributors often use communication channels external to pull requests; challenges are mostly social in nature, with most reporting poor responsiveness from integrators; and the increased transparency of this setting is a confirmed motivation to contribute. Based on these findings, we present recommendations for practitioners to streamline the contribution process and discuss potential future research directions.</blockquote>

<p id="Graziotin2014" class="bib"><cite>Graziotin2014</cite>
Daniel Graziotin, Xiaofeng Wang, and Pekka Abrahamsson:
"<a href="https://doi.org/10.7717/peerj.289">Happy software developers solve problems better: psychological measurements in empirical software engineering</a>".
<em>PeerJ</em>, 2, 2014,
<a class="doi" href="https://doi.org/10.7717/peerj.289">10.7717/peerj.289</a>.
</p>
<blockquote class="abstract">For more than thirty years, it has been claimed that a way to improve software developers' productivity and software quality is to focus on people and to provide incentives to make developers satisfied and happy. This claim has rarely been verified in software engineering research, which faces an additional challenge in comparison to more traditional engineering fields: software development is an intellectual activity and is dominated by often-neglected human factors (called human aspects in software engineering research). Among the many skills required for software development, developers must possess high analytical problem-solving skills and creativity for the software construction process. According to psychology research, affective states—emotions and moods—deeply influence the cognitive processing abilities and performance of workers, including creativity and analytical problem solving. Nonetheless, little research has investigated the correlation between the affective states, creativity, and analytical problem-solving performance of programmers. This article echoes the call to employ psychological measurements in software engineering research. We report a study with 42 participants to investigate the relationship between the affective states, creativity, and analytical problem-solving skills of software developers. The results offer support for the claim that happy developers are indeed better problem solvers in terms of their analytical abilities. The following contributions are made by this study: (1) providing a better understanding of the impact of affective states on the creativity and analytical problem-solving capacities of developers, (2) introducing and validating psychological measurements, theories, and concepts of affective states, creativity, and analytical-problem-solving skills in empirical software engineering, and (3) raising the need for studying the human factors of software engineering by employing a multidisciplinary viewpoint.</blockquote>

<p id="Green1996" class="bib"><cite>Green1996</cite>
Thomas R. G. Green and Marian Petre:
"<a href="https://doi.org/10.1006/jvlc.1996.0009">Usability analysis of visual programming environments: a 'cognitive dimensions' framework</a>".
<em>Journal of Visual Languages &amp; Computing</em>, 7(2), 1996,
<a class="doi" href="https://doi.org/10.1006/jvlc.1996.0009">10.1006/jvlc.1996.0009</a>.
</p>
<blockquote class="abstract">Abstract The cognitive dimensions framework is a broad-brush evaluation technique for interactive devices and for non-interactive notations. It sets out a small vocabulary of terms designed to capture the cognitively-relevant aspects of structure, and shows how they can be traded off against each other. The purpose of this paper is to propose the framework as an evaluation technique for visual programming environments. We apply it to two commercially-available dataflow languages (with further examples from other systems) and conclude that it is effective and insightful; other HCI-based evaluation techniques focus on different aspects and would make good complements. Insofar as the examples we used are representative, current VPLs are successful in achieving a good 'closeness of match', but designers need to consider the 'viscosity ' (resistance to local change) and the 'secondary notation' (possibility of conveying extra meaning by choice of layout, colour, etc.).</blockquote>

<p id="Gulzar2016" class="bib"><cite>Gulzar2016</cite>
Muhammad Ali Gulzar, Matteo Interlandi, Seunghyun Yoo, Sai Deep Tetali, Tyson Condie, Todd Millstein, and Miryung Kim:
"<a href="https://doi.org/10.1145/2884781.2884813">BigDebug: debugging primitives for interactive big data processing in Spark</a>".
<em>Proceedings of the 38th International Conference on Software Engineering</em>, <a class="doi" href="https://doi.org/10.1145/2884781.2884813">10.1145/2884781.2884813</a>.
</p>
<blockquote class="abstract">Developers use cloud computing platforms to process a large quantity of data in parallel when developing big data analytics. Debugging the massive parallel computations that run in today's data-centers is time consuming and error-prone. To address this challenge, we design a set of interactive, real-time debugging primitives for big data processing in Apache Spark, the next generation data-intensive scalable cloud computing platform. This requires re-thinking the notion of step-through debugging in a traditional debugger such as gdb, because pausing the entire computation across distributed worker nodes causes significant delay and naively inspecting millions of records using a watchpoint is too time consuming for an end user.First, BigDebug's simulated breakpoints and on-demand watchpoints allow users to selectively examine distributed, intermediate data on the cloud with little overhead. Second, a user can also pinpoint a crash-inducing record and selectively resume relevant sub-computations after a quick fix. Third, a user can determine the root causes of errors (or delays) at the level of individual records through a fine-grained data provenance capability. Our evaluation shows that BigDebug scales to terabytes and its record-level tracing incurs less than 25% overhead on average. It determines crash culprits orders of magnitude more accurately and provides up to 100% time saving compared to the baseline replay debugger. The results show that BigDebug supports debugging at interactive speeds with minimal performance impact.</blockquote>

<h2 id="H">H</h2>

<p id="Hanenberg2010" class="bib"><cite>Hanenberg2010</cite>
Stefan Hanenberg:
"<a href="https://doi.org/10.1145/1869459.1869462">An experiment about static and dynamic type systems</a>".
<em>Proceedings of the ACM international conference on Object oriented programming systems languages and applications - OOPSLA '10</em>, <a class="doi" href="https://doi.org/10.1145/1869459.1869462">10.1145/1869459.1869462</a>.
</p>
<blockquote class="abstract">Although static type systems are an essential part in teach-ing and research in software engineering and computer science, there is hardly any knowledge about what the impact of static type systems on the development time or the resulting quality for a piece of software is. On the one hand there are authors that state that static type systems decrease an application's complexity and hence its development time (which means that the quality must be improved since developers have more time left in their projects). On the other hand there are authors that argue that static type systems increase development time (and hence decrease the code quality) since they restrict developers to express themselves in a desired way. This paper presents an empirical study with 49 subjects that studies the impact of a static type system for the development of a parser over 27 hours working time. In the experiments the existence of the static type system has neither a positive nor a negative impact on an application's development time (under the conditions of the experiment).</blockquote>

<p id="Hanenberg2013" class="bib"><cite>Hanenberg2013</cite>
Stefan Hanenberg, Sebastian Kleinschmager, Romain Robbes, Éric Tanter, and Andreas Stefik:
"<a href="https://doi.org/10.1007/s10664-013-9289-1">An empirical study on the impact of static typing on software maintainability</a>".
<em>Empirical Software Engineering</em>, 19(5), 2013,
<a class="doi" href="https://doi.org/10.1007/s10664-013-9289-1">10.1007/s10664-013-9289-1</a>.
</p>
<blockquote class="abstract">Static type systems play an essential role in contemporary programming languages. Despite their importance, whether static type systems impact human software development capabilities remains open. One frequently mentioned argument in favor of static type systems is that they improve the maintainability of software systems—an often-used claim for which there is little empirical evidence. This paper describes an experiment that tests whether static type systems improve the maintainability of software systems, in terms of understanding undocumented code, fixing type errors, and fixing semantic errors. The results show rigorous empirical evidence that static types are indeed beneficial to these activities, except when fixing semantic errors. We further conduct an exploratory analysis of the data in order to understand possible reasons for the effect of type systems on the three kinds of tasks used in this experiment. From the exploratory analysis, we conclude that developers using a dynamic type system tend to look at different files more frequently when doing programming tasks—which is a potential reason for the observed differences in time.</blockquote>

<p id="Hannay2010" class="bib"><cite>Hannay2010</cite>
J.E. Hannay, E. Arisholm, H. Engvik, and D.I.K. Sjøberg:
"<a href="https://doi.org/10.1109/tse.2009.41">Effects of personality on pair programming</a>".
<em>IEEE Transactions on Software Engineering</em>, 36(1), 2010,
<a class="doi" href="https://doi.org/10.1109/tse.2009.41">10.1109/tse.2009.41</a>.
</p>
<blockquote class="abstract">Personality tests in various guises are commonly used in recruitment and career counseling industries. Such tests have also been considered as instruments for predicting the job performance of software professionals both individually and in teams. However, research suggests that other human-related factors such as motivation, general mental ability, expertise, and task complexity also affect the performance in general. This paper reports on a study of the impact of the Big Five personality traits on the performance of pair programmers together with the impact of expertise and task complexity. The study involved 196 software professionals in three countries forming 98 pairs. The analysis consisted of a confirmatory part and an exploratory part. The results show that: (1) Our data do not confirm a meta-analysis-based model of the impact of certain personality traits on performance and (2) personality traits, in general, have modest predictive value on pair programming performance compared with expertise, task complexity, and country. We conclude that more effort should be spent on investigating other performance-related predictors such as expertise, and task complexity, as well as other promising predictors, such as programming skill and learning. We also conclude that effort should be spent on elaborating on the effects of personality on various measures of collaboration, which, in turn, may be used to predict and influence performance. Insights into such malleable, rather than static, factors may then be used to improve pair programming performance.</blockquote>

<p id="Harms2016" class="bib"><cite>Harms2016</cite>
Kyle James Harms, Jason Chen, and Caitlin L. Kelleher:
"<a href="https://doi.org/10.1145/2960310.2960314">Distractors in Parsons Problems decrease learning efficiency for young novice programmers</a>".
<em>Proceedings of the 2016 ACM Conference on International Computing Education Research</em>, <a class="doi" href="https://doi.org/10.1145/2960310.2960314">10.1145/2960310.2960314</a>.
</p>
<blockquote class="abstract">Parsons problems are an increasingly popular method for helping inexperienced programmers improve their programming skills. In Parsons problems, learners are given a set of programming statements that they must assemble into the correct order. Parsons problems commonly use distractors, extra statements that are not part of the solution. Yet, little is known about the effect distractors have on a learner's ability to acquire new programming skills. We present a study comparing the effectiveness of learning programming from Parsons problems with and without distractors. The results suggest that distractors decrease learning efficiency. We found that distractor participants showed no difference in transfer task performance compared to those without distractors. However, the distractors increased learners cognitive load, decreased their success at completing Parsons problems by 26%, and increased learners' time on task by 14%.</blockquote>

<p id="Hata2019" class="bib"><cite>Hata2019</cite>
Hideaki Hata, Christoph Treude, Raula Gaikovina Kula, and Takashi Ishio:
"<a href="https://doi.org/10.1109/icse.2019.00123">9.6 million links in source code comments: purpose, evolution, and decay</a>".
<em>2019 IEEE/ACM 41st International Conference on Software Engineering (ICSE)</em>, <a class="doi" href="https://doi.org/10.1109/icse.2019.00123">10.1109/icse.2019.00123</a>.
</p>
<blockquote class="abstract">Links are an essential feature of the World Wide Web, and source code repositories are no exception. However, despite their many undisputed benefits, links can suffer from decay, insufficient versioning, and lack of bidirectional traceability. In this paper, we investigate the role of links contained in source code comments from these perspectives. We conducted a large-scale study of around 9.6 million links to establish their prevalence, and we used a mixed-methods approach to identify the links' targets, purposes, decay, and evolutionary aspects. We found that links are prevalent in source code repositories, that licenses, software homepages, and specifications are common types of link targets, and that links are often included to provide metadata or attribution. Links are rarely updated, but many link targets evolve. Almost 10% of the links included in source code comments are dead. We then submitted a batch of link-fixing pull requests to open source software repositories, resulting in most of our fixes being merged successfully. Our findings indicate that links in source code comments can indeed be fragile, and our work opens up avenues for future work to address these problems.</blockquote>

<p id="Hemmati2013" class="bib"><cite>Hemmati2013</cite>
Hadi Hemmati, Sarah Nadi, Olga Baysal, Oleksii Kononenko, Wei Wang, Reid Holmes, and Michael W. Godfrey:
"<a href="https://doi.org/10.1109/msr.2013.6624048">The MSR Cookbook: mining a decade of research</a>".
<em>2013 10th Working Conference on Mining Software Repositories (MSR)</em>, <a class="doi" href="https://doi.org/10.1109/msr.2013.6624048">10.1109/msr.2013.6624048</a>.
</p>
<blockquote class="abstract">The Mining Software Repositories (MSR) research community has grown significantly since the first MSR workshop was held in 2004. As the community continues to broaden its scope and deepens its expertise, it is worthwhile to reflect on the best practices that our community has developed over the past decade of research. We identify these best practices by surveying past MSR conferences and workshops. To that end, we review all 117 full papers published in the MSR proceedings between 2004 and 2012. We extract 268 comments from these papers, and categorize them using a grounded theory methodology. From this evaluation, four high-level themes were identified: data acquisition and preparation, synthesis, analysis, and sharing/replication. Within each theme we identify several common recommendations, and also examine how these recommendations have evolved over the past decade. In an effort to make this survey a living artifact, we also provide a public forum that contains the extracted recommendations in the hopes that the MSR community can engage in a continuing discussion on our evolving best practices.</blockquote>

<p id="Hermans2011" class="bib"><cite>Hermans2011</cite>
Felienne Hermans, Martin Pinzger, and Arie van Deursen:
"<a href="https://doi.org/10.1145/1985793.1985855">Supporting professional spreadsheet users by generating leveled dataflow diagrams</a>".
<em>Proceedings of the 33rd International Conference on Software Engineering</em>, <a class="doi" href="https://doi.org/10.1145/1985793.1985855">10.1145/1985793.1985855</a>.
</p>
<blockquote class="abstract">Thanks to their flexibility and intuitive programming model, spreadsheets are widely used in industry, often for businesscritical applications. Similar to software developers, professional spreadsheet users demand support for maintaining and transferring their spreadsheets. In this paper, we first study the problems and information needs of professional spreadsheet users by means of a survey conducted at a large financial company. Based on these needs, we then present an approach that extracts this information from spreadsheets and presents it in a compact and easy to understand way, with leveled dataflow diagrams. Our approach comes with three different views on the dataflow that allow the user to analyze the dataflow diagrams in a top-down fashion. To evaluate the usefulness of the proposed approach, we conducted a series of interviews as well as nine case studies in an industrial setting. The results of the evaluation clearly indicate the demand for and usefulness of our approach in ease the understanding of spreadsheets.</blockquote>

<p id="Hermans2016" class="bib"><cite>Hermans2016</cite>
Felienne Hermans and Efthimia Aivaloglou:
"<a href="https://doi.org/10.1109/icpc.2016.7503706">Do code smells hamper novice programming? A controlled experiment on Scratch programs</a>".
<em>2016 IEEE 24th International Conference on Program Comprehension (ICPC)</em>, <a class="doi" href="https://doi.org/10.1109/icpc.2016.7503706">10.1109/icpc.2016.7503706</a>.
</p>
<blockquote class="abstract">Recently, block-based programming languages like Alice, Scratch and Blockly have become popular tools for programming education. There is substantial research showing that block-based languages are suitable for early programming education. But can block-based programs be smelly too? And does that matter to learners? In this paper we explore the code smells metaphor in the context of block-based programming language Scratch. We conduct a controlled experiment with 61 novice Scratch programmers, in which we divided the novices into three groups. One third receive a non-smelly program, while the other groups receive a program suffering from the Duplication or the Long Method smell respectively. All subjects then perform the same comprehension tasks on their program, after which we measure their time and correctness. The results of the experiment show that code smell indeed influence performance: subjects working on the program exhibiting code smells perform significantly worse, but the smells did not affect the time subjects needed. Investigating different types of tasks in more detail, we find that Long Method mainly decreases system understanding, while Duplication decreases the ease with which subjects modify Scratch programs.</blockquote>

<p id="Herraiz2010" class="bib"><cite>Herraiz2010</cite>
Israel Herraiz and Ahmed E. Hassan:
"Beyond Lines of Code: Do We Need More Complexity Metrics?".
In 
Andy Oram and Greg Wilson (eds.):
<em>Making Software.</em>
O'Reilly, 2010, 978-0596808327.
</p>
<blockquote class="abstract">Summarizes work on code complexity metrics and finds that there is little evidence any of them provide more information than simply counting lines of code.</blockquote>

<p id="Herzig2013" class="bib"><cite>Herzig2013</cite>
Kim Herzig, Sascha Just, and Andreas Zeller:
"<a href="https://doi.org/10.1109/icse.2013.6606585">It's not a bug, it's a feature: how misclassification impacts bug prediction</a>".
<em>2013 35th International Conference on Software Engineering (ICSE)</em>, <a class="doi" href="https://doi.org/10.1109/icse.2013.6606585">10.1109/icse.2013.6606585</a>.
</p>
<blockquote class="abstract">In a manual examination of more than 7,000 issue reports from the bug databases of five open-source projects, we found 33.8% of all bug reports to be misclassified - that is, rather than referring to a code fix, they resulted in a new feature, an update to documentation, or an internal refactoring. This misclassification introduces bias in bug prediction models, confusing bugs and features: On average, 39% of files marked as defective actually never had a bug. We discuss the impact of this misclassification on earlier studies and recommend manual data validation for future studies.</blockquote>

<p id="Hindle2012" class="bib"><cite>Hindle2012</cite>
Abram Hindle, Christian Bird, Thomas Zimmermann, and Nachiappan Nagappan:
"<a href="https://doi.org/10.1109/icsm.2012.6405278">Relating requirements to implementation via topic analysis: do topics extracted from requirements make sense to managers and developers?</a>".
<em>2012 28th IEEE International Conference on Software Maintenance (ICSM)</em>, <a class="doi" href="https://doi.org/10.1109/icsm.2012.6405278">10.1109/icsm.2012.6405278</a>.
</p>
<blockquote class="abstract">Large organizations like Microsoft tend to rely on formal requirements documentation in order to specify and design the software products that they develop. These documents are meant to be tightly coupled with the actual implementation of the features they describe. In this paper we evaluate the value of high-level topic-based requirements traceability in the version control system, using Latent Dirichlet Allocation (LDA). We evaluate LDA topics on practitioners and check if the topics and trends extracted matches the perception that Program Managers and Developers have about the effort put into addressing certain topics. We found that effort extracted from version control that was relevant to a topic often matched the perception of the managers and developers of what occurred at the time. Furthermore we found evidence that many of the identified topics made sense to practitioners and matched their perception of what occurred. But for some topics, we found that practitioners had difficulty interpreting and labelling them. In summary, we investigate the high-level traceability of requirements topics to version control commits via topic analysis and validate with the actual stakeholders the relevance of these topics extracted from requirements.</blockquote>

<p id="Hindle2016" class="bib"><cite>Hindle2016</cite>
Abram Hindle, Earl T. Barr, Mark Gabel, Zhendong Su, and Premkumar Devanbu:
"<a href="https://doi.org/10.1145/2902362">On the naturalness of software</a>".
<em>Communications of the ACM</em>, 59(5), 2016,
<a class="doi" href="https://doi.org/10.1145/2902362">10.1145/2902362</a>.
</p>
<blockquote class="abstract">Natural languages like English are rich, complex, and powerful. The highly creative and graceful use of languages like English and Tamil, by masters like Shakespeare and Avvaiyar, can certainly delight and inspire. But in practice, given cognitive constraints and the exigencies of daily life, most human utterances are far simpler and much more repetitive and predictable. In fact, these utterances can be very usefully modeled using modern statistical methods. This fact has led to the phenomenal success of statistical approaches to speech recognition, natural language translation, question-answering, and text mining and comprehension. We begin with the conjecture that most software is also natural, in the sense that it is created by humans at work, with all the attendant constraints and limitations - and thus, like natural language, it is also likely to be repetitive and predictable. We then proceed to ask whether a) code can be usefully modeled by statistical language models and b) such models can be leveraged to support software engineers. Using the widely adopted n-gram model, we provide empirical evidence supportive of a positive answer to both these questions. We show that code is also very repetitive, and in fact even more so than natural languages. As an example use of the model, we have developed a simple code completion engine for Java that, despite its simplicity, already improves Eclipse's built-in completion capability. We conclude the paper by laying out a vision for future research in this area.</blockquote>

<p id="Hofmeister2017" class="bib"><cite>Hofmeister2017</cite>
Johannes Hofmeister, Janet Siegmund, and Daniel V. Holt:
"<a href="https://doi.org/10.1109/saner.2017.7884623">Shorter identifier names take longer to comprehend</a>".
<em>2017 IEEE 24th International Conference on Software Analysis, Evolution and Reengineering (SANER)</em>, <a class="doi" href="https://doi.org/10.1109/saner.2017.7884623">10.1109/saner.2017.7884623</a>.
</p>
<blockquote class="abstract">Developers spend the majority of their time comprehending code, a process in which identifier names play a key role. Although many identifier naming styles exist, they often lack an empirical basis and it is not quite clear whether short or long identifier names facilitate comprehension. In this paper, we investigate the effect of different identifier naming styles (letters, abbreviations, words) on program comprehension, and whether these effects arise because of their length or their semantics. We conducted an experimental study with 72 professional C# developers, who looked for defects in source-code snippets. We used a within-subjects design, such that each developer saw all three versions of identifier naming styles and we measured the time it took them to find a defect. We found that words lead to, on average, 19% faster comprehension speed compared to letters and abbreviations, but we did not find a significant difference in speed between letters and abbreviations. The results of our study suggest that defects in code are more difficult to detect when code contains only letters and abbreviations. Words as identifier names facilitate program comprehension and can help to save costs and improve software quality.</blockquote>

<p id="Hora2021b" class="bib"><cite>Hora2021b</cite>
Andre Hora:
"<a href="https://doi.org/10.1109/msr52588.2021.00051">What code is deliberately excluded from test coverage and why?</a>".
<em>2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR)</em>, <a class="doi" href="https://doi.org/10.1109/msr52588.2021.00051">10.1109/msr52588.2021.00051</a>.
</p>
<blockquote class="abstract">Test coverage is largely used to assess test effectiveness. In practice, not all code is equally important for coverage analysis, for instance, code that will not be executed during tests is irrelevant and can actually harm the analysis. Some coverage tools provide support for code exclusion from coverage reports, however, we are not yet aware of what code tends to be excluded nor the reasons behind it. This can support the creation of more accurate coverage reports and reveal novel and harmful usage cases. In this paper, we provide the first empirical study to understand code exclusion practices in test coverage. We mine 55 Python projects and assess commit messages and code comments to detect rationales for exclusions. We find that (1) over 1/3 of the projects perform deliberate coverage exclusion; (2) 75% of the code are already created using the exclusion feature, while 25% add it over time; (3) developers exclude non-runnable, debug-only, and defensive code, but also platform-specific and conditional importing; and (4) most code is excluded because it is already untested, low-level, or complex. Finally, we discuss implications to improve coverage analysis and shed light on the existence of biased coverage reports.</blockquote>

<p id="Hundhausen2011" class="bib"><cite>Hundhausen2011</cite>
Christopher D. Hundhausen, Pawan Agarwal, and Michael Trevisan:
"<a href="https://doi.org/10.1145/1953163.1953201">Online vs. face-to-face pedagogical code reviews</a>".
<em>Proceedings of the 42nd ACM technical symposium on Computer science education - SIGCSE '11</em>, <a class="doi" href="https://doi.org/10.1145/1953163.1953201">10.1145/1953163.1953201</a>.
</p>
<blockquote class="abstract">Given the increased importance of communication, teamwork, and critical thinking skills in the computing profession, we have been exploring studio-based instructional methods, in which students develop solutions and iteratively refine them through critical review by their peers and instructor. We have developed an adaptation of studio-based instruction for computing education called the pedagogical code review (PCR), which is modeled after the code inspection process used in the software industry. Unfortunately, PCRs are time-intensive, making them difficult to implement within a typical computing course. To address this issue, we have developed an online environment that allows PCRs to take place asynchronously outside of class. We conducted an empirical study that compared a CS 1 course with online PCRs against a CS 1 course with face-to-face PCRs. Our study had three key results: (a) in the course with face-to-face PCRs, student attitudes with respect to self-efficacy and peer learning were significantly higher; (b) in the course with face-to-face PCRs, students identified more substantive issues in their reviews; and (c) in the course with face-to-face PCRs, students were generally more positive about the value of PCRs. In light of our findings, we recommend specific ways online PCRs can be better designed.</blockquote>

<h2 id="I">I</h2>
<h2 id="J">J</h2>

<p id="Jacobson2013" class="bib"><cite>Jacobson2013</cite>
Ivar Jacobson, Pan-Wei Ng, Paul E. McMahon, Ian Spence, and Svante Lidman:
<em>The Essence of Software Engineering: Applying the SEMAT Kernel</em>.
Addison-Wesley Professional, 2013, 978-0321885951.
</p>
<blockquote class="abstract">SEMAT (Software Engineering Methods and Theory) is an international initiative designed to identify a common ground, or universal standard, for software engineering. It is supported by some of the most distinguished contributors to the field. Creating a simple language to describe methods and practices, the SEMAT team expresses this common ground as a kernel—or framework—of elements essential to all software development. The Essence of Software Engineering introduces this kernel and shows how to apply it when developing software and improving a team's way of working. It is a book for software professionals, not methodologists. Its usefulness to development team members, who need to evaluate and choose the best practices for their work, goes well beyond the description or application of any single method.</blockquote>

<p id="Jorgensen2011" class="bib"><cite>Jorgensen2011</cite>
Magne Jørgensen and Stein Grimstad:
"<a href="https://doi.org/10.1109/tse.2010.78">the impact of irrelevant and misleading information on software development effort estimates: a randomized controlled field experiment</a>".
<em>IEEE Transactions on Software Engineering</em>, 37(5), 2011,
<a class="doi" href="https://doi.org/10.1109/tse.2010.78">10.1109/tse.2010.78</a>.
</p>
<blockquote class="abstract">Studies in laboratory settings report that software development effort estimates can be strongly affected by effort-irrelevant and misleading information. To increase our knowledge about the importance of these effects in field settings, we paid 46 outsourcing companies from various countries to estimate the required effort of the same five software development projects. The companies were allocated randomly to either the original requirement specification or a manipulated version of the original requirement specification. The manipulations were as follows: 1) reduced length of requirement specification with no change of content, 2) information about the low effort spent on the development of the old system to be replaced, 3) information about the client's unrealistic expectations about low cost, and 4) a restriction of a short development period with start up a few months ahead. We found that the effect sizes in the field settings were much smaller than those found for similar manipulations in laboratory settings. Our findings suggest that we should be careful about generalizing to field settings the effect sizes found in laboratory settings. While laboratory settings can be useful to demonstrate the existence of an effect and better understand it, field studies may be needed to study the size and importance of these effects.</blockquote>

<p id="Jorgensen2012" class="bib"><cite>Jorgensen2012</cite>
Magne Jørgensen and Stein Grimstad:
"<a href="https://doi.org/10.1109/tse.2011.40">Software development estimation biases: the role of interdependence</a>".
<em>IEEE Transactions on Software Engineering</em>, 38(3), 2012,
<a class="doi" href="https://doi.org/10.1109/tse.2011.40">10.1109/tse.2011.40</a>.
</p>
<blockquote class="abstract">Software development effort estimates are frequently too low, which may lead to poor project plans and project failures. One reason for this bias seems to be that the effort estimates produced by software developers are affected by information that has no relevance for the actual use of effort. We attempted to acquire a better understanding of the underlying mechanisms and the robustness of this type of estimation bias. For this purpose, we hired 374 software developers working in outsourcing companies to participate in a set of three experiments. The experiments examined the connection between estimation bias and developer dimensions: self-construal (how one sees oneself), thinking style, nationality, experience, skill, education, sex, and organizational role. We found that estimation bias was present along most of the studied dimensions. The most interesting finding may be that the estimation bias increased significantly with higher levels of interdependence, i.e., with stronger emphasis on connectedness, social context, and relationships. We propose that this connection may be enabled by an activation of one's self-construal when engaging in effort estimation, and a connection between a more interdependent self-construal and increased search for indirect messages, lower ability to ignore irrelevant context, and a stronger emphasis on socially desirable responses.</blockquote>

<h2 id="K">K</h2>

<p id="KanatAlexander2012" class="bib"><cite>KanatAlexander2012</cite>
Max Kanat-Alexander:
<em>Code Simplicity: The Science of Software Development</em>.
O'Reilly, 2012, 978-1449313890.
</p>
<blockquote class="abstract">Good software development results in simple code. Unfortunately, much of the code existing in the world today is far too complex. This concise guide helps you understand the fundamentals of good software development through universal laws—principles you can apply to any programming language or project from here to eternity.</blockquote>

<p id="Kapser2008" class="bib"><cite>Kapser2008</cite>
Cory J. Kapser and Michael W. Godfrey:
"<a href="https://doi.org/10.1007/s10664-008-9076-6">'Cloning considered harmful' considered harmful: patterns of cloning in software</a>".
<em>Empirical Software Engineering</em>, 13(6), 2008,
<a class="doi" href="https://doi.org/10.1007/s10664-008-9076-6">10.1007/s10664-008-9076-6</a>.
</p>
<blockquote class="abstract">Literature on the topic of code cloning often asserts that duplicating code within a software system is a bad practice, that it causes harm to the system's design and should be avoided. However, in our studies, we have found significant evidence that cloning is often used in a variety of ways as a principled engineering tool. For example, one way to evaluate possible new features for a system is to clone the affected subsystems and introduce the new features there, in a kind of sandbox testbed. As features mature and become stable within the experimental subsystems, they can be migrated incrementally into the stable code base; in this way, the risk of introducing instabilities in the stable version is minimized. This paper describes several patterns of cloning that we have observed in our case studies and discusses the advantages and disadvantages associated with using them. We also examine through a case study the frequencies of these clones in two medium-sized open source software systems, the Apache web server and the Gnumeric spreadsheet application. In this study, we found that as many as 71% of the clones could be considered to have a positive impact on the maintainability of the software system.</blockquote>

<p id="Kasi2013" class="bib"><cite>Kasi2013</cite>
Bakhtiar Khan Kasi and Anita Sarma:
"<a href="https://doi.org/10.1109/icse.2013.6606619">Cassandra: proactive conflict minimization through optimized task scheduling</a>".
<em>2013 35th International Conference on Software Engineering (ICSE)</em>, <a class="doi" href="https://doi.org/10.1109/icse.2013.6606619">10.1109/icse.2013.6606619</a>.
</p>
<blockquote class="abstract">Software conflicts arising because of conflicting changes are a regular occurrence and delay projects. The main precept of workspace awareness tools has been to identify potential conflicts early, while changes are still small and easier to resolve. However, in this approach conflicts still occur and require developer time and effort to resolve. We present a novel conflict minimization technique that proactively identifies potential conflicts, encodes them as constraints, and solves the constraint space to recommend a set of conflict-minimal development paths for the team. Here we present a study of four open source projects to characterize the distribution of conflicts and their resolution efforts. We then explain our conflict minimization technique and the design and implementation of this technique in our prototype, Cassandra. We show that Cassandra would have successfully avoided a majority of conflicts in the four open source test subjects. We demonstrate the efficiency of our approach by applying the technique to a simulated set of scenarios with higher than normal incidence of conflicts.</blockquote>

<p id="Khomh2012" class="bib"><cite>Khomh2012</cite>
Foutse Khomh, Tejinder Dhaliwal, Ying Zou, and Bram Adams:
"<a href="https://doi.org/10.1109/msr.2012.6224279">Do faster releases improve software quality? An empirical case study of Mozilla Firefox</a>".
<em>2012 9th IEEE Working Conference on Mining Software Repositories (MSR)</em>, <a class="doi" href="https://doi.org/10.1109/msr.2012.6224279">10.1109/msr.2012.6224279</a>.
</p>
<blockquote class="abstract">Nowadays, many software companies are shifting from the traditional 18-month release cycle to shorter release cycles. For example, Google Chrome and Mozilla Firefox release new versions every 6 weeks. These shorter release cycles reduce the users' waiting time for a new release and offer better marketing opportunities to companies, but it is unclear if the quality of the software product improves as well, since shorter release cycles result in shorter testing periods. In this paper, we empirically study the development process of Mozilla Firefox in 2010 and 2011, a period during which the project transitioned to a shorter release cycle. We compare crash rates, median uptime, and the proportion of post-release bugs of the versions that had a shorter release cycle with those having a traditional release cycle, to assess the relation between release cycle length and the software quality observed by the end user. We found that (1) with shorter release cycles, users do not experience significantly more post-release bugs and (2) bugs are fixed faster, yet (3) users experience these bugs earlier during software execution (the program crashes earlier).</blockquote>

<p id="Kiefer2015" class="bib"><cite>Kiefer2015</cite>
Marc Kiefer, Daniel Warzel, and Walter F. Tichy:
"<a href="https://doi.org/10.1145/2837476.2837481">An empirical study on parallelism in modern open-source projects</a>".
<em>Proceedings of the 2nd International Workshop on Software Engineering for Parallel Systems</em>, <a class="doi" href="https://doi.org/10.1145/2837476.2837481">10.1145/2837476.2837481</a>.
</p>
<blockquote class="abstract">Writing parallel programs is hard, especially for inexperienced programmers. Parallel language features are still being added on a regular basis to most modern object-oriented languages and this trend is likely to continue. Being able to support developers with tools for writing and optimizing parallel programs requires a deep understanding of how programmers approach and implement parallelism. We present an empirical study of 135 parallel open-source projects in Java, C# and C++ ranging from small (&lt; 1000 lines of code) to very large (&gt; 2M lines of code) codebases. We examine the projects to find out how language features, synchronization mechanisms, parallel data structures and libraries are used by developers to express parallelism. We also determine which common parallel patterns are used and how the implemented solutions compare to typical textbook advice. The results show that similar parallel constructs are used equally often across languages, but usage also heavily depends on how easy to use a certain language feature is. Patterns that do not map well to a language are much rarer compared to other languages. Bad practices are prevalent in hobby projects but also occur in larger projects.</blockquote>

<p id="Kim2013" class="bib"><cite>Kim2013</cite>
Dongsun Kim, Jaechang Nam, Jaewoo Song, and Sunghun Kim:
"<a href="https://doi.org/10.1109/icse.2013.6606626">Automatic patch generation learned from human-written patches</a>".
<em>2013 35th International Conference on Software Engineering (ICSE)</em>, <a class="doi" href="https://doi.org/10.1109/icse.2013.6606626">10.1109/icse.2013.6606626</a>.
</p>
<blockquote class="abstract">Patch generation is an essential software maintenance task because most software systems inevitably have bugs that need to be fixed. Unfortunately, human resources are often insufficient to fix all reported and known bugs. To address this issue, several automated patch generation techniques have been proposed. In particular, a genetic-programming-based patch generation technique, GenProg, proposed by Weimer et al., has shown promising results. However, these techniques can generate nonsensical patches due to the randomness of their mutation operations. To address this limitation, we propose a novel patch generation approach, Pattern-based Automatic program Repair (Par), using fix patterns learned from existing human-written patches. We manually inspected more than 60,000 human-written patches and found there are several common fix patterns. Our approach leverages these fix patterns to generate program patches automatically. We experimentally evaluated Par on 119 real bugs. In addition, a user study involving 89 students and 164 developers confirmed that patches generated by our approach are more acceptable than those generated by GenProg. Par successfully generated patches for 27 out of 119 bugs, while GenProg was successful for only 16 bugs.</blockquote>

<p id="Kim2016" class="bib"><cite>Kim2016</cite>
Dohyeong Kim, Yonghwi Kwon, Peng Liu, I. Luk Kim, David Mitchel Perry, Xiangyu Zhang, and Gustavo Rodriguez-Rivera:
"<a href="https://doi.org/10.1145/2983990.2984031">Apex: automatic programming assignment error explanation</a>".
<em>Proceedings of the 2016 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications</em>, <a class="doi" href="https://doi.org/10.1145/2983990.2984031">10.1145/2983990.2984031</a>.
</p>
<blockquote class="abstract">This paper presents Apex, a system that can automatically generate explanations for programming assignment bugs, regarding where the bugs are and how the root causes led to the runtime failures. It works by comparing the passing execution of a correct implementation (provided by the instructor) and the failing execution of the buggy implementation (submitted by the student). The technique overcomes a number of technical challenges caused by syntactic and semantic differences of the two implementations. It collects the symbolic traces of the executions and matches assignment statements in the two execution traces by reasoning about symbolic equivalence. It then matches predicates by aligning the control dependences of the matched assignment statements, avoiding direct matching of path conditions which are usually quite different. Our evaluation shows that Apex is every effective for 205 buggy real world student submissions of 4 programming assignments, and a set of 15 programming assignment type of buggy programs collected from stackoverflow.com, precisely pinpointing the root causes and capturing the causality for 94.5% of them. The evaluation on a standard benchmark set with over 700 student bugs shows similar results. A user study in the classroom shows that Apex has substantially improved student productivity.</blockquote>

<p id="Kinshumann2011" class="bib"><cite>Kinshumann2011</cite>
Kinshuman Kinshumann, Kirk Glerum, Steve Greenberg, Gabriel Aul, Vince Orgovan, Greg Nichols, David Grant, Gretchen Loihle, and Galen Hunt:
"<a href="https://doi.org/10.1145/1965724.1965749">Debugging in the (very) large: ten years of implementation and experience</a>".
<em>Communications of the ACM</em>, 54(7), 2011,
<a class="doi" href="https://doi.org/10.1145/1965724.1965749">10.1145/1965724.1965749</a>.
</p>
<blockquote class="abstract">Windows Error Reporting (WER) is a distributed system that automates the processing of error reports coming from an installed base of a billion machines. WER has collected billions of error reports in 10 years of operation. It collects error data automatically and classifies errors into buckets, which are used to prioritize developer effort and report fixes to users. WER uses a progressive approach to data collection, which minimizes overhead for most reports yet allows developers to collect detailed information when needed. WER takes advantage of its scale to use error statistics as a tool in debugging; this allows developers to isolate bugs that cannot be found at smaller scale. WER has been designed for efficient operation at large scale: one pair of database servers records all the errors that occur on all Windows computers worldwide.</blockquote>

<p id="Kocaguneli2012" class="bib"><cite>Kocaguneli2012</cite>
Ekrem Kocaguneli, Tim Menzies, and Jacky W. Keung:
"<a href="https://doi.org/10.1109/tse.2011.111">On the value of ensemble effort estimation</a>".
<em>IEEE Transactions on Software Engineering</em>, 38(6), 2012,
<a class="doi" href="https://doi.org/10.1109/tse.2011.111">10.1109/tse.2011.111</a>.
</p>
<blockquote class="abstract">Background: Despite decades of research, there is no consensus on which software effort estimation methods produce the most accurate models. Aim: Prior work has reported that, given M estimation methods, no single method consistently outperforms all others. Perhaps rather than recommending one estimation method as best, it is wiser to generate estimates from ensembles of multiple estimation methods. Method: Nine learners were combined with 10 preprocessing options to generate 9×10 = 90 solo methods. These were applied to 20 datasets and evaluated using seven error measures. This identified the best n (in our case n = 13) solo methods that showed stable performance across multiple datasets and error measures. The top 2, 4, 8, and 13 solo methods were then combined to generate 12 multimethods, which were then compared to the solo methods. Results: 1) The top 10 (out of 12) multimethods significantly outperformed all 90 solo methods. 2) The error rates of the multimethods were significantly less than the solo methods. 3) The ranking of the best multimethod was remarkably stable. Conclusion: While there is no best single effort estimation method, there exist best combinations of such effort estimation methods.</blockquote>

<p id="Krein2016" class="bib"><cite>Krein2016</cite>
Jonathan L. Krein, Lutz Prechelt, Natalia Juristo, Aziz Nanthaamornphong, Jeffrey C. Carver, Sira Vegas, Charles D. Knutson, Kevin D. Seppi, and Dennis L. Eggett:
"<a href="https://doi.org/10.1109/tse.2015.2488625">A multi-site joint replication of a design patterns experiment using moderator variables to generalize across contexts</a>".
<em>IEEE Transactions on Software Engineering</em>, 42(4), 2016,
<a class="doi" href="https://doi.org/10.1109/tse.2015.2488625">10.1109/tse.2015.2488625</a>.
</p>
<blockquote class="abstract">Context. Several empirical studies have explored the benefits of software design patterns, but their collective results are highly inconsistent. Resolving the inconsistencies requires investigating moderators—i.e., variables that cause an effect to differ across contexts. Objectives. Replicate a design patterns experiment at multiple sites and identify sufficient moderators to generalize the results across prior studies. Methods. We perform a close replication of an experiment investigating the impact (in terms of time and quality) of design patterns (Decorator and Abstract Factory) on software maintenance. The experiment was replicated once previously, with divergent results. We execute our replication at four universities—spanning two continents and three countries—using a new method for performing distributed replications based on closely coordinated, small-scale instances ("joint replication"). We perform two analyses: 1) a post-hoc analysis of moderators, based on frequentist and Bayesian statistics; 2) an a priori analysis of the original hypotheses, based on frequentist statistics. Results. The main effect differs across the previous instances of the experiment and across the sites in our distributed replication. Our analysis of moderators (including developer experience and pattern knowledge) resolves the differences sufficiently to allow for cross-context (and cross-study) conclusions. The final conclusions represent 126 participants from five universities and 12 software companies, spanning two continents and at least four countries. Conclusions. The Decorator pattern is found to be preferable to a simpler solution during maintenance, as long as the developer has at least some prior knowledge of the pattern. For Abstract Factory, the simpler solution is found to be mostly equivalent to the pattern solution. Abstract Factory is shown to require a higher level of knowledge and/or experience than Decorator for the pattern to be beneficial.</blockquote>

<h2 id="L">L</h2>

<p id="Levy2020" class="bib"><cite>Levy2020</cite>
Karen Levy and Bruce Schneier:
"<a href="https://doi.org/10.1093/cybsec/tyaa006">Privacy threats in intimate relationships</a>".
<em>Journal of Cybersecurity</em>, 6(1), 2020,
<a class="doi" href="https://doi.org/10.1093/cybsec/tyaa006">10.1093/cybsec/tyaa006</a>.
</p>
<blockquote class="abstract">This article provides an overview of intimate threats: a class of privacy threats that can arise within our families, romantic partnerships, close friendships, and caregiving relationships. Many common assumptions about privacy are upended in the context of these relationships, and many otherwise effective protective measures fail when applied to intimate threats. Those closest to us know the answers to our secret questions, have access to our devices, and can exercise coercive power over us. We survey a range of intimate relationships and describe their common features. Based on these features, we explore implications for both technical privacy design and policy, and offer design recommendations for ameliorating intimate privacy risks.</blockquote>

<p id="Lewis2013" class="bib"><cite>Lewis2013</cite>
Chris Lewis, Zhongpeng Lin, Caitlin Sadowski, Xiaoyan Zhu, Rong Ou, and E. James Whitehead:
"<a href="https://doi.org/10.1109/icse.2013.6606583">Does bug prediction support human developers? Findings from a Google case study</a>".
<em>2013 35th International Conference on Software Engineering (ICSE)</em>, <a class="doi" href="https://doi.org/10.1109/icse.2013.6606583">10.1109/icse.2013.6606583</a>.
</p>
<blockquote class="abstract">While many bug prediction algorithms have been developed by academia, they're often only tested and verified in the lab using automated means. We do not have a strong idea about whether such algorithms are useful to guide human developers. We deployed a bug prediction algorithm across Google, and found no identifiable change in developer behavior. Using our experience, we provide several characteristics that bug prediction algorithms need to meet in order to be accepted by human developers and truly change how developers evaluate their code.</blockquote>

<p id="Li2013" class="bib"><cite>Li2013</cite>
Sihan Li, Hucheng Zhou, Haoxiang Lin, Tian Xiao, Haibo Lin, Wei Lin, and Tao Xie:
"<a href="https://doi.org/10.1109/icse.2013.6606646">A characteristic study on failures of production distributed data-parallel programs</a>".
<em>2013 35th International Conference on Software Engineering (ICSE)</em>, <a class="doi" href="https://doi.org/10.1109/icse.2013.6606646">10.1109/icse.2013.6606646</a>.
</p>
<blockquote class="abstract">SCOPE is adopted by thousands of developers from tens of different product teams in Microsoft Bing for daily web-scale data processing, including index building, search ranking, and advertisement display. A SCOPE job is composed of declarative SQL-like queries and imperative C# user-defined functions (UDFs), which are executed in pipeline by thousands of machines. There are tens of thousands of SCOPE jobs executed on Microsoft clusters per day, while some of them fail after a long execution time and thus waste tremendous resources. Reducing SCOPE failures would save significant resources. This paper presents a comprehensive characteristic study on 200 SCOPE failures/fixes and 50 SCOPE failures with debugging statistics from Microsoft Bing, investigating not only major failure types, failure sources, and fixes, but also current debugging practice. Our major findings include (1) most of the failures (84.5%) are caused by defects in data processing rather than defects in code logic; (2) table-level failures (22.5%) are mainly caused by programmers' mistakes and frequent data-schema changes while row-level failures (62%) are mainly caused by exceptional data; (3) 93% fixes do not change data processing logic; (4) there are 8% failures with root cause not at the failure-exposing stage, making current debugging practice insufficient in this case. Our study results provide valuable guidelines for future development of data-parallel programs. We believe that these guidelines are not limited to SCOPE, but can also be generalized to other similar data-parallel platforms.</blockquote>

<p id="Liao2016" class="bib"><cite>Liao2016</cite>
Soohyun Nam Liao, Daniel Zingaro, Michael A. Laurenzano, William G. Griswold, and Leo Porter:
"<a href="https://doi.org/10.1145/2960310.2960315">Lightweight, early identification of at-risk CS1 students</a>".
<em>Proceedings of the 2016 ACM Conference on International Computing Education Research</em>, <a class="doi" href="https://doi.org/10.1145/2960310.2960315">10.1145/2960310.2960315</a>.
</p>
<blockquote class="abstract">Being able to identify low-performing students early in the term may help instructors intervene or differently allocate course resources. Prior work in CS1 has demonstrated that clicker correctness in Peer Instruction courses correlates with exam outcomes and, separately, that machine learning models can be built based on early-term programming assessments. This work aims to combine the best elements of each of these approaches. We offer a methodology for creating models, based on in-class clicker questions, to predict cross-term student performance. In as early as week 3 in a 12-week CS1 course, this model is capable of correctly predicting students as being in danger of failing, or not, for 70% of the students, with only 17% of students misclassified as not at-risk when at-risk. Additional measures to ensure more broad applicability of the methodology, along with possible limitations, are explored.</blockquote>

<p id="Lo2015" class="bib"><cite>Lo2015</cite>
David Lo, Nachiappan Nagappan, and Thomas Zimmermann:
"<a href="https://doi.org/10.1145/2786805.2786809">How practitioners perceive the relevance of software engineering research</a>".
<em>Proceedings of the 2015 10th Joint Meeting on Foundations of Software Engineering</em>, <a class="doi" href="https://doi.org/10.1145/2786805.2786809">10.1145/2786805.2786809</a>.
</p>
<blockquote class="abstract">The number of software engineering research papers over the last few years has grown significantly. An important question here is: how relevant is software engineering research to practitioners in the field? To address this question, we conducted a survey at Microsoft where we invited 3,000 industry practitioners to rate the relevance of research ideas contained in 571 ICSE, ESEC/FSE and FSE papers that were published over a five year period. We received 17,913 ratings by 512 practitioners who labelled ideas as essential, worthwhile, unimportant, or unwise. The results from the survey suggest that practitioners are positive towards studies done by the software engineering research community: 71% of all ratings were essential or worthwhile. We found no correlation between the citation counts and the relevance scores of the papers. Through a qualitative analysis of free text responses, we identify several reasons why practitioners considered certain research ideas to be unwise. The survey approach described in this paper is lightweight: on average, a participant spent only 22.5 minutes to respond to the survey. At the same time, the results can provide useful insight to conference organizers, authors, and participating practitioners.</blockquote>

<h2 id="M">M</h2>

<p id="Maalej2014" class="bib"><cite>Maalej2014</cite>
Walid Maalej, Rebecca Tiarks, Tobias Roehm, and Rainer Koschke:
"<a href="https://doi.org/10.1145/2622669">On the comprehension of program comprehension</a>".
<em>ACM Transactions on Software Engineering and Methodology</em>, 23(4), 2014,
<a class="doi" href="https://doi.org/10.1145/2622669">10.1145/2622669</a>.
</p>
<blockquote class="abstract">Research in program comprehension has evolved considerably over the past decades. However, only little is known about how developers practice program comprehension in their daily work. This article reports on qualitative and quantitative research to comprehend the strategies, tools, and knowledge used for program comprehension. We observed 28 professional developers, focusing on their comprehension behavior, strategies followed, and tools used. In an online survey with 1,477 respondents, we analyzed the importance of certain types of knowledge for comprehension and where developers typically access and share this knowledge. We found that developers follow pragmatic comprehension strategies depending on context. They try to avoid comprehension whenever possible and often put themselves in the role of users by inspecting graphical interfaces. Participants confirmed that standards, experience, and personal communication facilitate comprehension. The team size, its distribution, and open-source experience influence their knowledge sharing and access behavior. While face-to-face communication is preferred for accessing knowledge, knowledge is frequently shared in informal comments. Our results reveal a gap between research and practice, as we did not observe any use of comprehension tools and developers seem to be unaware of them. Overall, our findings call for reconsidering the research agendas towards context-aware tool support.</blockquote>

<p id="Maenpaa2018" class="bib"><cite>Maenpaa2018</cite>
Hanna Mäenpää, Simo Mäkinen, Terhi Kilamo, Tommi Mikkonen, Tomi Männistö, and Paavo Ritala:
"<a href="https://doi.org/10.1186/s13174-018-0088-1">Organizing for openness: six models for developer involvement in hybrid OSS projects</a>".
<em>Journal of Internet Services and Applications</em>, 9(1), 2018,
<a class="doi" href="https://doi.org/10.1186/s13174-018-0088-1">10.1186/s13174-018-0088-1</a>.
</p>
<blockquote class="abstract">This article examines organization and governance of commercially influenced Open Source Software development communities by presenting a multiple-case study of six contemporary, hybrid OSS projects. The findings provide in-depth understanding on how to design the participatory nature of the software development process, while understanding the factors that influence the delicate balance of openness, motivations, and governance. The results lay ground for further research on how to organize and manage developer communities where needs of the stakeholders are competing, yet complementary.</blockquote>

<p id="Majumder2019" class="bib"><cite>Majumder2019</cite>
Suvodeep Majumder, Joymallya Chakraborty, Amritanshu Agrawal, and Tim Menzies:
"<a href="http://arxiv.org/abs/1904.09954">Why Software Projects need Heroes: Lessons Learned from 1100+ Projects</a>".
<em>arxiv.org</em>, abs/1904.09954, 2019.
</p>
<blockquote class="abstract">A "hero" project is one where 80% or more of the contributions are made by the 20% of the developers. Those developers are called "hero" developers. In the literature, heroes projects are deprecated since they might cause bottlenecks in development and communication. However, there is little empirical evidence on this matter. Further, recent studies show that such hero projects are very prevalent. Accordingly, this paper explores the effect of having heroes in project, from a code quality perspective by analyzing 1000+ open source GitHub projects. Based on the analysis, this study finds that (a) majority of the projects are hero projects; and (b)the commits from "hero developers" (who contribute most to the code) result in far fewer bugs than other developers. That is, contrary to the literature, heroes are standard and very useful part of modern open source projects.</blockquote>

<p id="Malloy2018" class="bib"><cite>Malloy2018</cite>
Brian A. Malloy and James F. Power:
"<a href="https://doi.org/10.1007/s10664-018-9637-2">An empirical analysis of the transition from Python 2 to Python 3</a>".
<em>Empirical Software Engineering</em>, 24(2), 2018,
<a class="doi" href="https://doi.org/10.1007/s10664-018-9637-2">10.1007/s10664-018-9637-2</a>.
</p>
<blockquote class="abstract">Python is one of the most popular and widely adopted programming languages in use today. In 2008 the Python developers introduced a new version of the language, Python 3.0, that was not backward compatible with Python 2, initiating a transitional phase for Python software developers. In this paper, we describe a study that investigates the degree to which Python software developers are making the transition from Python 2 to Python 3. We have developed a Python compliance analyser, PyComply, and have analysed a previously studied corpus of Python applications called Qualitas. We use PyComply to measure and quantify the degree to which Python 3 features are being used, as well as the rate and context of their adoption in the Qualitas corpus. Our results indicate that Python software developers are not exploiting the new features and advantages of Python 3, but rather are choosing to retain backward compatibility with Python 2. Moreover, Python developers are confining themselves to a language subset, governed by the diminishing intersection of Python 2, which is not under development, and Python 3, which is under development with new features being introduced as the language continues to evolve.</blockquote>

<p id="Marinescu2011" class="bib"><cite>Marinescu2011</cite>
Cristina Marinescu:
"<a href="https://doi.org/10.1145/2024445.2024456">Are the classes that use exceptions defect prone?</a>".
<em>Proceedings of the 12th international workshop and the 7th annual ERCIM workshop on Principles on software evolution and software evolution - IWPSE-EVOL '11</em>, <a class="doi" href="https://doi.org/10.1145/2024445.2024456">10.1145/2024445.2024456</a>.
</p>
<blockquote class="abstract">Exception handling is a mechanism that highlights exceptional functionality of software systems. Currently many empirical studies point out that sometimes developers neglect exceptional functionality, minimizing its importance. In this paper we investigate if the design entities (classes) that use exceptions are more defect prone than the other classes. The results, based on analyzing three releases of Eclipse, show that indeed the classes that use exceptions are more defect prone than the other classes. Based on our results, developers are advertised to pay more attention to the way they handle exceptions.</blockquote>

<p id="Masood2020a" class="bib"><cite>Masood2020a</cite>
Zainab Masood, Rashina Hoda, and Kelly Blincoe:
"<a href="https://doi.org/10.1007/s10664-020-09876-x">How agile teams make self-assignment work: a grounded theory study</a>".
<em>Empirical Software Engineering</em>, 25(6), 2020,
<a class="doi" href="https://doi.org/10.1007/s10664-020-09876-x">10.1007/s10664-020-09876-x</a>.
</p>
<blockquote class="abstract">Self-assignment, a self-directed method of task allocation in which teams and individuals assign and choose work for themselves, is considered one of the hallmark practices of empowered, self-organizing agile teams. Despite all the benefits it promises, agile software teams do not practice it as regularly as other agile practices such as iteration planning and daily stand-ups, indicating that it is likely not an easy and straighforward practice. There has been very little empirical research on self-assignment. This Grounded Theory study explores how self-assignment works in agile projects. We collected data through interviews with 42 participants representing 28 agile teams from 23 software companies and supplemented these interviews with observations. Based on rigorous application of Grounded Theory analysis procedures such as open, axial, and selective coding, we present a comprehensive grounded theory of making self-assignment work that explains the (a) context and (b) causal conditions that give rise to the need for self-assignment, (c) a set of facilitating conditions that mediate how self-assignment may be enabled, (d) a set of constraining conditions that mediate how self-assignment may be constrained and which are overcome by a set of (e) strategies applied by agile teams, which in turn result in (f) a set of consequences, all in an attempt to make the central phenomenon, self-assignment, work. The findings of this study will help agile practitioners and companies understand different aspects of self-assignment and practice it with confidence regularly as a valuable practice. Additionally, it will help teams already practicing self-assignment to apply strategies to overcome the challenges they face on an everyday basis.</blockquote>

<p id="Mattmann2015" class="bib"><cite>Mattmann2015</cite>
Chris A. Mattmann, Joshua Garcia, Ivo Krka, Daniel Popescu, and Nenad Medvidović:
"<a href="https://doi.org/10.1007/s10723-015-9324-0">Revisiting the anatomy and physiology of the grid</a>".
<em>Journal of Grid Computing</em>, 13(1), 2015,
<a class="doi" href="https://doi.org/10.1007/s10723-015-9324-0">10.1007/s10723-015-9324-0</a>.
</p>
<blockquote class="abstract">A domain-specific software architecture (DSSA) represents an effective, generalized, reusable solution to constructing software systems within a given application domain. In this paper, we revisit the widely cited DSSA for the domain of grid computing. We have studied systems in this domain over the last ten years. During this time, we have repeatedly observed that, while individual grid systems are widely used and deemed successful, the grid DSSA is actually underspecified to the point where providing a precise answer regarding what makes a software system a grid system is nearly impossible. Moreover, every one of the existing purported grid technologies actually violates the published grid DSSA. In response to this, based on an analysis of the source code, documentation, and usage of eighteen of the most pervasive grid technologies, we have significantly refined the original grid DSSA. We demonstrate that this DSSA much more closely matches the grid technologies studied. Our refinements allow us to more definitively identify a software system as a grid technology, and distinguish it from software libraries, middleware, and frameworks.</blockquote>

<p id="McGee2011" class="bib"><cite>McGee2011</cite>
Sharon McGee and Des Greer:
"<a href="https://doi.org/10.1109/re.2011.6051641">Software requirements change taxonomy: evaluation by case study</a>".
<em>2011 IEEE 19th International Requirements Engineering Conference</em>, <a class="doi" href="https://doi.org/10.1109/re.2011.6051641">10.1109/re.2011.6051641</a>.
</p>
<blockquote class="abstract">Although a number of requirements change classifications have been proposed in the literature, there is no empirical assessment of their practical value in terms of their capacity to inform change monitoring and management. This paper describes an investigation of the informative efficacy of a taxonomy of requirements change sources which distinguishes between changes arising from 'market', 'organisation', 'project vision', 'specification' and 'solution'. This investigation was effected through a case study where change data was recorded over a 16 month period covering the development lifecycle of a government sector software application. While insufficiency of data precluded an investigation of changes arising due to the change source of 'market', for the remainder of the change sources, results indicate a significant difference in cost, value to the customer and management considerations. Findings show that higher cost and value changes arose more often from 'organisation' and 'vision' sources; these changes also generally involved the co-operation of more stakeholder groups and were considered to be less controllable than changes arising from the 'specification' or 'solution' sources. Overall, the results suggest that monitoring and measuring change using this classification is a practical means to support change management, understanding and risk visibility.</blockquote>

<p id="McIntosh2011" class="bib"><cite>McIntosh2011</cite>
Shane McIntosh, Bram Adams, Thanh H.D. Nguyen, Yasutaka Kamei, and Ahmed E. Hassan:
"<a href="https://doi.org/10.1145/1985793.1985813">An empirical study of build maintenance effort</a>".
<em>Proceedings of the 33rd International Conference on Software Engineering</em>, <a class="doi" href="https://doi.org/10.1145/1985793.1985813">10.1145/1985793.1985813</a>.
</p>
<blockquote class="abstract">The build system of a software project is responsible for transforming source code and other development artifacts into executable programs and deliverables. Similar to source code, build system specifications require maintenance to cope with newly implemented features, changes to imported Application Program Interfaces (APIs), and source code restructuring. In this paper, we mine the version histories of one proprietary and nine open source projects of different sizes and domain to analyze the overhead that build maintenance imposes on developers. We split our analysis into two dimensions: (1) Build Coupling, i.e., how frequently source code changes require build changes, and (2) Build Ownership, i.e., the proportion of developers responsible for build maintenance. Our results indicate that, despite the difference in scale, the build system churn rate is comparable to that of the source code, and build changes induce more relative churn on the build system than source code changes induce on the source code. Furthermore, build maintenance yields up to a 27% overhead on source code development and a 44% overhead on test development. Up to 79% of source code developers and 89% of test code developers are significantly impacted by build maintenance, yet investment in build experts can reduce the proportion of impacted developers to 22% of source code developers and 24% of test code developers.</blockquote>

<p id="McLeod2011" class="bib"><cite>McLeod2011</cite>
Laurie McLeod and Stephen G. MacDonell:
"<a href="https://doi.org/10.1145/1978802.1978803">Factors that affect software systems development project outcomes</a>".
<em>ACM Computing Surveys</em>, 43(4), 2011,
<a class="doi" href="https://doi.org/10.1145/1978802.1978803">10.1145/1978802.1978803</a>.
</p>
<blockquote class="abstract">Determining the factors that have an influence on software systems development and deployment project outcomes has been the focus of extensive and ongoing research for more than 30 years. We provide here a survey of the research literature that has addressed this topic in the period 1996--2006, with a particular focus on empirical analyses. On the basis of this survey we present a new classification framework that represents an abstracted and synthesized view of the types of factors that have been asserted as influencing project outcomes.</blockquote>

<p id="Meneely2011" class="bib"><cite>Meneely2011</cite>
Andrew Meneely, Pete Rotella, and Laurie Williams:
"<a href="https://doi.org/10.1145/2025113.2025128">Does adding manpower also affect quality? An empirical, longitudinal analysis</a>".
<em>Proceedings of the 19th ACM SIGSOFT symposium and the 13th European conference on Foundations of software engineering - SIGSOFT/FSE '11</em>, <a class="doi" href="https://doi.org/10.1145/2025113.2025128">10.1145/2025113.2025128</a>.
</p>
<blockquote class="abstract">With each new developer to a software development team comes a greater challenge to manage the communication, coordination, and knowledge transfer amongst teammates. Fred Brooks discusses this challenge in The Mythical Man-Month by arguing that rapid team expansion can lead to a complex team organization structure. While Brooks focuses on productivity loss as the negative outcome, poor product quality is also a substantial concern. But if team expansion is unavoidable, can any quality impacts be mitigated? Our objective is to guide software engineering managers by empirically analyzing the effects of team size, expansion, and structure on product quality. We performed an empirical, longitudinal case study of a large Cisco networking product over a five year history. Over that time, the team underwent periods of no expansion, steady expansion, and accelerated expansion. Using team-level metrics, we quantified characteristics of team expansion, including team size, expansion rate, expansion acceleration, and modularity with respect to department designations. We examined statistical correlations between our monthly team-level metrics and monthly product-level metrics. Our results indicate that increased team size and linear growth are correlated with later periods of better product quality. However, periods of accelerated team expansion are correlated with later periods of reduced software quality. Furthermore, our linear regression prediction model based on team metrics was able to predict the product's post-release failure rate within a 95% prediction interval for 38 out of 40 months. Our analysis provides insight for project managers into how the expansion of development teams can impact product quality.</blockquote>

<p id="Meng2013" class="bib"><cite>Meng2013</cite>
Na Meng, Miryung Kim, and Kathryn S. McKinley:
"<a href="https://doi.org/10.1109/icse.2013.6606596">Lase: locating and applying systematic edits by learning from examples</a>".
<em>2013 35th International Conference on Software Engineering (ICSE)</em>, <a class="doi" href="https://doi.org/10.1109/icse.2013.6606596">10.1109/icse.2013.6606596</a>.
</p>
<blockquote class="abstract">Adding features and fixing bugs often require systematic edits that make similar, but not identical, changes to many code locations. Finding all the relevant locations and making the correct edits is a tedious and error-prone process for developers. This paper addresses both problems using edit scripts learned from multiple examples. We design and implement a tool called LASE that (1) creates a context-aware edit script from two or more examples, and uses the script to (2) automatically identify edit locations and to (3) transform the code. We evaluate LASE on an oracle test suite of systematic edits from Eclipse JDT and SWT. LASE finds edit locations with 99% precision and 89% recall, and transforms them with 91% accuracy. We also evaluate LASE on 37 example systematic edits from other open source programs and find LASE is accurate and effective. Furthermore, we confirmed with developers that LASE found edit locations which they missed. Our novel algorithm that learns from multiple examples is critical to achieving high precision and recall; edit scripts created from only one example produce too many false positives, false negatives, or both. Our results indicate that LASE should help developers in automating systematic editing. Whereas most prior work either suggests edit locations or performs simple edits, LASE is the first to do both for nontrivial program edits.</blockquote>

<p id="Meyer2014" class="bib"><cite>Meyer2014</cite>
André N. Meyer, Thomas Fritz, Gail C. Murphy, and Thomas Zimmermann:
"<a href="https://doi.org/10.1145/2635868.2635892">Software developers' perceptions of productivity</a>".
<em>Proceedings of the 22nd ACM SIGSOFT International Symposium on Foundations of Software Engineering</em>, <a class="doi" href="https://doi.org/10.1145/2635868.2635892">10.1145/2635868.2635892</a>.
</p>
<blockquote class="abstract">The better the software development community becomes at creating software, the more software the world seems to demand. Although there is a large body of research about measuring and investigating productivity from an organizational point of view, there is a paucity of research about how software developers, those at the front-line of software construction, think about, assess and try to improve their productivity. To investigate software developers' perceptions of software development productivity, we conducted two studies: a survey with 379 professional software developers to help elicit themes and an observational study with 11 professional software developers to investigate emergent themes in more detail. In both studies, we found that developers perceive their days as productive when they complete many or big tasks without significant interruptions or context switches. Yet, the observational data we collected shows our participants performed significant task and activity switching while still feeling productive. We analyze such apparent contradictions in our findings and use the analysis to propose ways to better support software developers in a retrospection and improvement of their productivity through the development of new tools and the sharing of best practices.</blockquote>

<p id="Miedema2021" class="bib"><cite>Miedema2021</cite>
Daphne Miedema, Efthimia Aivaloglou, and George Fletcher:
"<a href="https://doi.org/10.1145/3446871.3469759">Identifying SQL misconceptions of novices: findings from a think-aloud study</a>".
<em>Proceedings of the 17th ACM Conference on International Computing Education Research</em>, <a class="doi" href="https://doi.org/10.1145/3446871.3469759">10.1145/3446871.3469759</a>.
</p>
<blockquote class="abstract">SQL is the most commonly taught database query language. While previous research has investigated the errors made by novices during SQL query formulation, the underlying causes for these errors have remained unexplored. Understanding the basic misconceptions held by novices which lead to these errors would help improve how we teach query languages to our students. In this paper we aim to identify the misconceptions that might be the causes of documented SQL errors that novices make. To this end, we conducted a qualitative think-aloud study to gather information on the thinking process of university students while solving query formulation problems. With the queries in hand, we analyzed the underlying causes for the errors made by our participants. In this paper we present the identified SQL misconceptions organized into four top-level categories: misconceptions based in previous course knowledge, generalization-based misconceptions, language-based misconceptions, and misconceptions due to an incomplete or incorrect mental model. A deep exploration of misconceptions can uncover gaps in instruction. By drawing attention to these, we aim to improve SQL education.</blockquote>

<p id="Miller2016" class="bib"><cite>Miller2016</cite>
Craig S. Miller and Amber Settle:
"<a href="https://doi.org/10.1145/2960310.2960327">Some trouble with transparency: an analysis of student errors with object-oriented Python</a>".
<em>Proceedings of the 2016 ACM Conference on International Computing Education Research</em>, <a class="doi" href="https://doi.org/10.1145/2960310.2960327">10.1145/2960310.2960327</a>.
</p>
<blockquote class="abstract">We investigated implications of transparent mechanisms in the context of an introductory object-oriented programming course using Python. Here transparent mechanisms are those that reveal how the instance object in Python relates to its instance data. We asked students to write a new method for a provided Python class in an attempt to answer two research questions: 1) to what extent do Python's transparent OO mechanisms lead to student difficulties? and 2) what are common pitfalls in OO programming using Python that instructors should address? Our methodology also presented the correct answer to the students and solicited their comments on their submission. We conducted a content analysis to classify errors in the student submissions. We find that most students had difficulty with the instance (self) object, either by omitting the parameter in the method definition, by failing to use the instance object when referencing attributes of the object, or both. Reference errors in general were more common than other errors, including misplaced returns and indentation errors. These issues may be connected to problems with parameter passing and using dot-notation, which we argue are prerequisites for OO development in Python.</blockquote>

<p id="Mockus2010" class="bib"><cite>Mockus2010</cite>
Audris Mockus:
"<a href="https://doi.org/10.1145/1882291.1882311">Organizational volatility and its effects on software defects</a>".
<em>Proceedings of the eighteenth ACM SIGSOFT international symposium on Foundations of software engineering - FSE'10</em>, <a class="doi" href="https://doi.org/10.1145/1882291.1882311">10.1145/1882291.1882311</a>.
</p>
<blockquote class="abstract">The key premise of an organization is to allow more efficient production, including production of high quality software. To achieve that, an organization defines roles and reporting relationships. Therefore, changes in organization's structure are likely to affect product's quality. We propose and investigate a relationship between developer-centric measures of organizational change and the probability of customer-reported defects in the context of a large software project. We find that the proximity to an organizational change is significantly associated with reductions in software quality. We also replicate results of several prior studies of software quality supporting findings that code, change, and developer characteristics affect fault-proneness. In contrast to prior studies we find that distributed development decreases quality. Furthermore, recent departures from an organization were associated with increased probability of customer-reported defects, thus demonstrating that in the observed context the organizational change reduces product quality.</blockquote>

<p id="Moe2010" class="bib"><cite>Moe2010</cite>
Nils Brede Moe, Torgeir Dingsøyr, and Tore Dybå:
"<a href="https://doi.org/10.1016/j.infsof.2009.11.004">A teamwork model for understanding an agile team: A case study of a Scrum project</a>".
<em>Information and Software Technology</em>, 52(5), 2010,
<a class="doi" href="https://doi.org/10.1016/j.infsof.2009.11.004">10.1016/j.infsof.2009.11.004</a>.
</p>
<blockquote class="abstract">Context: Software development depends significantly on team performance, as does any process that involves human interaction. Objective: Most current development methods argue that teams should self-manage. Our objective is thus to provide a better understanding of the nature of self-managing agile teams, and the teamwork challenges that arise when introducing such teams. Method: We conducted extensive fieldwork for 9months in a software development company that introduced Scrum. We focused on the human sensemaking, on how mechanisms of teamwork were understood by the people involved. Results: We describe a project through Dickinson and McIntyre's teamwork model, focusing on the interrelations between essential teamwork components. Problems with team orientation, team leadership and coordination in addition to highly specialized skills and corresponding division of work were important barriers for achieving team effectiveness. Conclusion: Transitioning from individual work to self-managing teams requires a reorientation not only by developers but also by management. This transition takes time and resources, but should not be neglected. In addition to Dickinson and McIntyre's teamwork components, we found trust and shared mental models to be of fundamental importance.</blockquote>

<h2 id="N">N</h2>

<p id="Nagappan2008" class="bib"><cite>Nagappan2008</cite>
Nachiappan Nagappan, E. Michael Maximilien, Thirumalesh Bhat, and Laurie Williams:
"<a href="https://doi.org/10.1007/s10664-008-9062-z">Realizing quality improvement through test driven development: results and experiences of four industrial teams</a>".
<em>Empirical Software Engineering</em>, 13(3), 2008,
<a class="doi" href="https://doi.org/10.1007/s10664-008-9062-z">10.1007/s10664-008-9062-z</a>.
</p>
<blockquote class="abstract">Test-driven development (TDD) is a software development practice that has been used sporadically for decades. With this practice, a software engineer cycles minute-by-minute between writing failing unit tests and writing implementation code to pass those tests. Test-driven development has recently re-emerged as a critical enabling practice of agile software development methodologies. However, little empirical evidence supports or refutes the utility of this practice in an industrial context. Case studies were conducted with three development teams at Microsoft and one at IBM that have adopted TDD. The results of the case studies indicate that the pre-release defect density of the four products decreased between 40% and 90% relative to similar projects that did not use the TDD practice. Subjectively, the teams experienced a 15--35% increase in initial development time after adopting TDD.</blockquote>

<p id="Nagappan2015" class="bib"><cite>Nagappan2015</cite>
Meiyappan Nagappan, Romain Robbes, Yasutaka Kamei, Éric Tanter, Shane McIntosh, Audris Mockus, and Ahmed E. Hassan:
"<a href="https://doi.org/10.1145/2786805.2786834">An empirical study of goto in C code from GitHub repositories</a>".
<em>Proceedings of the 2015 10th Joint Meeting on Foundations of Software Engineering</em>, <a class="doi" href="https://doi.org/10.1145/2786805.2786834">10.1145/2786805.2786834</a>.
</p>
<blockquote class="abstract">It is nearly 50 years since Dijkstra argued that goto obscures the flow of control in program execution and urged programmers to abandon the goto statement. While past research has shown that goto is still in use, little is known about whether goto is used in the unrestricted manner that Dijkstra feared, and if it is 'harmful' enough to be a part of a post-release bug. We, therefore, conduct a two part empirical study - (1) qualitatively analyze a statistically rep- resentative sample of 384 files from a population of almost 250K C programming language files collected from over 11K GitHub repositories and find that developers use goto in C files for error handling (80.21±5%) and cleaning up resources at the end of a procedure (40.36±5%); and (2) quantitatively analyze the commit history from the release branches of six OSS projects and find that no goto statement was re- moved/modified in the post-release phase of four of the six projects. We conclude that developers limit themselves to using goto appropriately in most cases, and not in an unrestricted manner like Dijkstra feared, thus suggesting that goto does not appear to be harmful in practice.</blockquote>

<p id="Nakshatri2016" class="bib"><cite>Nakshatri2016</cite>
Suman Nakshatri, Maithri Hegde, and Sahithi Thandra:
"<a href="https://doi.org/10.1145/2901739.2903499">Analysis of exception handling patterns in Java projects</a>".
<em>Proceedings of the 13th International Conference on Mining Software Repositories</em>, <a class="doi" href="https://doi.org/10.1145/2901739.2903499">10.1145/2901739.2903499</a>.
</p>
<blockquote class="abstract">Exception handling is a powerful tool provided by many pro- gramming languages to help developers deal with unforeseen conditions. Java is one of the few programming languages to enforce an additional compilation check on certain sub- classes of the Exception class through checked exceptions. As part of this study, empirical data was extracted from soft- ware projects developed in Java. The intent is to explore how developers respond to checked exceptions and identify common patterns used by them to deal with exceptions, checked or otherwise. Bloch's book - "Effective Java" [1] was used as reference for best practices in exception handling - these recommendations were compared against results from the empirical data. Results of this study indicate that most programmers ignore checked exceptions and leave them un- noticed. Additionally, it is observed that classes higher in the exception class hierarchy are more frequently used as compared to specific exception subclasses.</blockquote>

<p id="Near2016" class="bib"><cite>Near2016</cite>
Joseph P. Near and Daniel Jackson:
"<a href="https://doi.org/10.1145/2884781.2884836">Finding security bugs in web applications using a catalog of access control patterns</a>".
<em>Proceedings of the 38th International Conference on Software Engineering</em>, <a class="doi" href="https://doi.org/10.1145/2884781.2884836">10.1145/2884781.2884836</a>.
</p>
<blockquote class="abstract">We propose a specification-free technique for finding missing security checks in web applications using a catalog of access control patterns in which each pattern models a common access control use case. Our implementation, SPACE, checks that every data exposure allowed by an application's code matches an allowed exposure from a security pattern in our catalog. The only user-provided input is a mapping from application types to the types of the catalog; the rest of the process is entirely automatic. In an evaluation on the 50 most watched Ruby on Rails applications on Github, SPACE reported 33 possible bugs—23 previously unknown security bugs, and 10 false positives.</blockquote>

<p id="Nielebock2018" class="bib"><cite>Nielebock2018</cite>
Sebastian Nielebock, Dariusz Krolikowski, Jacob Krüger, Thomas Leich, and Frank Ortmeier:
"<a href="https://doi.org/10.1007/s10664-018-9664-z">Commenting source code: is it worth it for small programming tasks?</a>".
<em>Empirical Software Engineering</em>, 24(3), 2018,
<a class="doi" href="https://doi.org/10.1007/s10664-018-9664-z">10.1007/s10664-018-9664-z</a>.
</p>
<blockquote class="abstract">Maintaining a program is a time-consuming and expensive task in software engineering. Consequently, several approaches have been proposed to improve the comprehensibility of source code. One of such approaches are comments in the code that enable developers to explain the program with their own words or predefined tags. Some empirical studies indicate benefits of comments in certain situations, while others find no benefits at all. Thus, the real effect of comments on software development remains uncertain. In this article, we describe an experiment in which 277 participants, mainly professional software developers, performed small programming tasks on differently commented code. Based on quantitative and qualitative feedback, we i) partly replicate previous studies, ii) investigate performances of differently experienced participants when confronted with varying types of comments, and iii) discuss the opinions of developers on comments. Our results indicate that comments seem to be considered more important in previous studies and by our participants than they are for small programming tasks. While other mechanisms, such as proper identifiers, are considered more helpful by our participants, they also emphasize the necessity of comments in certain situations.</blockquote>

<p id="Nussli2012" class="bib"><cite>Nussli2012</cite>
Marc-Antoine Nüssli and Patrick Jermann:
"<a href="https://doi.org/10.1145/2145204.2145371">Effects of sharing text selections on gaze cross-recurrence and interaction quality in a pair programming task</a>".
<em>Proceedings of the ACM 2012 conference on Computer Supported Cooperative Work - CSCW '12</em>, <a class="doi" href="https://doi.org/10.1145/2145204.2145371">10.1145/2145204.2145371</a>.
</p>
<blockquote class="abstract">We present a dual eye-tracking study that demonstrates the effect of sharing selection among collaborators in a remote pair-programming scenario. Forty pairs of engineering students completed several program understanding tasks while their gaze was synchronously recorded. The coupling of the programmers' focus of attention was measured by a cross-recurrence analysis of gaze that captures how much programmers look at the same sequence of spots within a short time span. A high level of gaze cross-recurrence is typical for pairs who actively engage in grounding efforts to build and maintain shared understanding. As part of their grounding efforts, programmers may use text selection to perform collaborative references. Broadcast selections serve as indexing sites for the selector as they attract non-selector's gaze shortly after they become visible. Gaze cross-recurrence is highest when selectors accompany their selections with speech to produce a multimodal reference.</blockquote>

<h2 id="O">O</h2>

<p id="Oliveira2020" class="bib"><cite>Oliveira2020</cite>
Edson Oliveira, Eduardo Fernandes, Igor Steinmacher, Marco Cristo, Tayana Conte, and Alessandro Garcia:
"<a href="https://doi.org/10.1007/s10664-020-09820-z">Code and commit metrics of developer productivity: a study on team leaders perceptions</a>".
<em>Empirical Software Engineering</em>, 25(4), 2020,
<a class="doi" href="https://doi.org/10.1007/s10664-020-09820-z">10.1007/s10664-020-09820-z</a>.
</p>
<blockquote class="abstract">Context Developer productivity is essential to the success of software development organizations. Team leaders use developer productivity information for managing tasks in a software project. Developer productivity metrics can be computed from software repositories data to support leaders' decisions. We can classify these metrics in code-based metrics, which rely on the amount of produced code, and commit-based metrics, which rely on commit activity. Although metrics can assist a leader, organizations usually neglect their usage and end up sticking to the leaders' subjective perceptions only. Objective We aim to understand whether productivity metrics can complement the leaders' perceptions. We also aim to capture leaders' impressions about relevance and adoption of productivity metrics in practice. Method This paper presents a multi-case empirical study performed in two organizations active for more than 18 years. Eight leaders of nine projects have ranked the developers of their teams by productivity. We quantitatively assessed the correlation of leaders' rankings versus metric-based rankings. As a complement, we interviewed leaders for qualitatively understanding the leaders' impressions about relevance and adoption of productivity metrics given the computed correlations. Results Our quantitative data suggest a greater correlation of the leaders' perceptions with code-based metrics when compared to commit-based metrics. Our qualitative data reveal that leaders have positive impressions of code-based metrics and potentially would adopt them. Conclusions Data triangulation of productivity metrics and leaders' perceptions can strengthen the organization conviction about productive developers and can reveal productive developers not yet perceived by team leaders and probably underestimated in the organization.</blockquote>

<h2 id="P">P</h2>

<p id="Pan2008" class="bib"><cite>Pan2008</cite>
Kai Pan, Sunghun Kim, and E. James Whitehead:
"<a href="https://doi.org/10.1007/s10664-008-9077-5">Toward an understanding of bug fix patterns</a>".
<em>Empirical Software Engineering</em>, 14(3), 2008,
<a class="doi" href="https://doi.org/10.1007/s10664-008-9077-5">10.1007/s10664-008-9077-5</a>.
</p>
<blockquote class="abstract">Twenty-seven automatically extractable bug fix patterns are defined using the syntax components and context of the source code involved in bug fix changes. Bug fix patterns are extracted from the configuration management repositories of seven open source projects, all written in Java (Eclipse, Columba, JEdit, Scarab, ArgoUML, Lucene, and MegaMek). Defined bug fix patterns cover 45.7% to 63.3% of the total bug fix hunk pairs in these projects. The frequency of occurrence of each bug fix pattern is computed across all projects. The most common individual patterns are MC-DAP (method call with different actual parameter values) at 14.9–25.5%, IF-CC (change in if conditional) at 5.6–18.6%, and AS-CE (change of assignment expression) at 6.0–14.2%. A correlation analysis on the extracted pattern instances on the seven projects shows that six have very similar bug fix pattern frequencies. Analysis of if conditional bug fix sub-patterns shows a trend towards increasing conditional complexity in if conditional fixes. Analysis of five developers in the Eclipse projects shows overall consistency with project-level bug fix pattern frequencies, as well as distinct variations among developers in their rates of producing various bug patterns. Overall, data in the paper suggest that developers have difficulty with specific code situations at surprisingly consistent rates. There appear to be broad mechanisms causing the injection of bugs that are largely independent of the type of software being produced.</blockquote>

<p id="Pankratius2012" class="bib"><cite>Pankratius2012</cite>
Victor Pankratius, Felix Schmidt, and Gilda Garreton:
"<a href="https://doi.org/10.1109/icse.2012.6227200">Combining functional and imperative programming for multicore software: an empirical study evaluating Scala and Java</a>".
<em>2012 34th International Conference on Software Engineering (ICSE)</em>, <a class="doi" href="https://doi.org/10.1109/icse.2012.6227200">10.1109/icse.2012.6227200</a>.
</p>
<blockquote class="abstract">Recent multi-paradigm programming languages combine functional and imperative programming styles to make software development easier. Given today's proliferation of multicore processors, parallel programmers are supposed to benefit from this combination, as many difficult problems can be expressed more easily in a functional style while others match an imperative style. Due to a lack of empirical evidence from controlled studies, however, important software engineering questions are largely unanswered. Our paper is the first to provide thorough empirical results by using Scala and Java as a vehicle in a controlled comparative study on multicore software development. Scala combines functional and imperative programming while Java focuses on imperative shared-memory programming. We study thirteen programmers who worked on three projects, including an industrial application, in both Scala and Java. In addition to the resulting 39 Scala programs and 39 Java programs, we obtain data from an industry software engineer who worked on the same project in Scala. We analyze key issues such as effort, code, language usage, performance, and programmer satisfaction. Contrary to popular belief, the functional style does not lead to bad performance. Average Scala run-times are comparable to Java, lowest run-times are sometimes better, but Java scales better on parallel hardware. We confirm with statistical significance Scala's claim that Scala code is more compact than Java code, but clearly refute other claims of Scala on lower programming effort and lower debugging effort. Our study also provides explanations for these observations and shows directions on how to improve multi-paradigm languages in the future.</blockquote>

<p id="Parnin2012" class="bib"><cite>Parnin2012</cite>
Chris Parnin and Spencer Rugaber:
"<a href="https://doi.org/10.1109/icpc.2012.6240479">Programmer information needs after memory failure</a>".
<em>2012 20th IEEE International Conference on Program Comprehension (ICPC)</em>, <a class="doi" href="https://doi.org/10.1109/icpc.2012.6240479">10.1109/icpc.2012.6240479</a>.
</p>
<blockquote class="abstract">Despite its vast capacity and associative powers, the human brain does not deal well with interruptions. Particularly in situations where information density is high, such as during a programming task, recovering from an interruption requires extensive time and effort. Although modern program development environments have begun to recognize this problem, none of these tools take into account the brain's structure and limitations. In this paper, we present a conceptual framework for understanding the strengths and weaknesses of human memory, particularly with respect to it ability to deal with work interruptions. The framework explains empirical results obtained from experiments in which programmers were interrupted while working. Based on the framework, we discuss programmer information needs that development tools must satisfy and suggest several memory aids such tools could provide. We also describe our prototype implementation of these memory aids.</blockquote>

<p id="Patitsas2016" class="bib"><cite>Patitsas2016</cite>
Elizabeth Patitsas, Jesse Berlin, Michelle Craig, and Steve Easterbrook:
"<a href="https://doi.org/10.1145/2960310.2960312">Evidence that computer science grades are not bimodal</a>".
<em>Proceedings of the 2016 ACM Conference on International Computing Education Research</em>, <a class="doi" href="https://doi.org/10.1145/2960310.2960312">10.1145/2960310.2960312</a>.
</p>
<blockquote class="abstract">It is commonly thought that CS grades are bimodal. We statistically analyzed 778 distributions of final course grades from a large research university, and found only 5.8% of the distributions passed tests of multimodality. We then devised a psychology experiment to understand why CS educators believe their grades to be bimodal. We showed 53 CS professors a series of histograms displaying ambiguous distributions and asked them to categorize the distributions. A random half of participants were primed to think about the fact that CS grades are commonly thought to be bimodal; these participants were more likely to label ambiguous distributions as "bimodal". Participants were also more likely to label distributions as bimodal if they believed that some students are innately predisposed to do better at CS. These results suggest that bimodal grades are instructional folklore in CS, caused by confirmation bias and instructor beliefs about their students.</blockquote>

<p id="Peng2021" class="bib"><cite>Peng2021</cite>
Yun Peng, Yu Zhang, and Mingzhe Hu:
"<a href="https://doi.org/10.1109/saner50967.2021.00012">An empirical study for common language features used in Python projects</a>".
<em>2021 IEEE International Conference on Software Analysis, Evolution and Reengineering (SANER)</em>, <a class="doi" href="https://doi.org/10.1109/saner50967.2021.00012">10.1109/saner50967.2021.00012</a>.
</p>
<blockquote class="abstract">As a dynamic programming language, Python is widely used in many fields. For developers, various language features affect programming experience. For researchers, they affect the difficulty of developing tasks such as bug finding and compilation optimization. Former research has shown that programs with Python dynamic features are more change-prone. However, we know little about the use and impact of Python language features in real-world Python projects. To resolve these issues, we systematically analyze Python language features and propose a tool named PYSCAN to automatically identify the use of 22 kinds of common Python language features in 6 categories in Python source code. We conduct an empirical study on 35 popular Python projects from eight application domains, covering over 4.3 million lines of code, to investigate the the usage of these language features in the project. We find that single inheritance, decorator, keyword argument, for loops and nested classes are top 5 used language features. Meanwhile different domains of projects may prefer some certain language features. For example, projects in DevOps use exception handling frequently. We also conduct in-depth manual analysis to dig extensive using patterns of frequently but differently used language features: exceptions, decorators and nested classes/functions. We find that developers care most about ImportError when handling exceptions. With the empirical results and in-depth analysis, we conclude with some suggestions and a discussion of implications for three groups of persons in Python community: Python designers, Python compiler designers and Python developers.</blockquote>

<p id="PerezDeRosso2013" class="bib"><cite>PerezDeRosso2013</cite>
Santiago Perez De Rosso and Daniel Jackson:
"<a href="https://doi.org/10.1145/2509578.2509584">What's wrong with Git?</a>".
<em>Proceedings of the 2013 ACM international symposium on New ideas, new paradigms, and reflections on programming &amp; software - Onward! '13</em>, <a class="doi" href="https://doi.org/10.1145/2509578.2509584">10.1145/2509578.2509584</a>.
</p>
<blockquote class="abstract">It is commonly asserted that the success of a software development project, and the usability of the final product, depend on the quality of the concepts that underlie its design. Yet this hypothesis has not been systematically explored by researchers, and conceptual design has not played the central role in the research and teaching of software engineering that one might expect. As part of a new research project to explore conceptual design, we are engaging in a series of case studies. This paper reports on the early stages of our first study, on the Git version control system. Despite its widespread adoption, Git puzzles even experienced developers and is not regarded as easy to use. In an attempt to understand the root causes of its complexity, we analyze its conceptual model and identify some undesirable properties; we then propose a reworking of the conceptual model that forms the basis of (the first version of) Gitless, an ongoing effort to redesign Git and experiment with the effects of conceptual simplifications.</blockquote>

<p id="PerezDeRosso2016" class="bib"><cite>PerezDeRosso2016</cite>
Santiago Perez De Rosso and Daniel Jackson:
"<a href="https://doi.org/10.1145/2983990.2984018">Purposes, concepts, misfits, and a redesign of Git</a>".
<em>Proceedings of the 2016 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications</em>, <a class="doi" href="https://doi.org/10.1145/2983990.2984018">10.1145/2983990.2984018</a>.
</p>
<blockquote class="abstract">Git is a widely used version control system that is powerful but complicated. Its complexity may not be an inevitable consequence of its power but rather evidence of flaws in its design. To explore this hypothesis, we analyzed the design of Git using a theory that identifies concepts, purposes, and misfits. Some well-known difficulties with Git are described, and explained as misfits in which underlying concepts fail to meet their intended purpose. Based on this analysis, we designed a reworking of Git (called Gitless) that attempts to remedy these flaws. To correlate misfits with issues reported by users, we conducted a study of Stack Overflow questions. And to determine whether users experienced fewer complications using Gitless in place of Git, we conducted a small user study. Results suggest our approach can be profitable in identifying, analyzing, and fixing design problems.</blockquote>

<p id="Petre2013" class="bib"><cite>Petre2013</cite>
Marian Petre:
"<a href="https://doi.org/10.1109/icse.2013.6606618">UML in practice</a>".
<em>2013 35th International Conference on Software Engineering (ICSE)</em>, <a class="doi" href="https://doi.org/10.1109/icse.2013.6606618">10.1109/icse.2013.6606618</a>.
</p>
<blockquote class="abstract">UML has been described by some as "the lingua franca of software engineering". Evidence from industry does not necessarily support such endorsements. How exactly is UML being used in industry—if it is? This paper presents a corpus of interviews with 50 professional software engineers in 50 companies and identifies 5 patterns of UML use.</blockquote>

<p id="Philip2012" class="bib"><cite>Philip2012</cite>
Kavita Philip, Medha Umarji, Megha Agarwala, Susan Elliott Sim, Rosalva Gallardo-Valencia, Cristina V. Lopes, and Sukanya Ratanotayanon:
"<a href="https://doi.org/10.1145/2145204.2145407">Software reuse through methodical component reuse and amethodical snippet remixing</a>".
<em>Proceedings of the ACM 2012 conference on Computer Supported Cooperative Work - CSCW '12</em>, <a class="doi" href="https://doi.org/10.1145/2145204.2145407">10.1145/2145204.2145407</a>.
</p>
<blockquote class="abstract">Every method for developing software is a prescriptive model. Applying a deconstructionist analysis to methods reveals that there are two texts, or sets of assumptions and ideals: a set that is privileged by the method and a second set that is left out, or marginalized by the method. We apply this analytical lens to software reuse, a technique in software development that seeks to expedite one's own project by using programming artifacts created by others. By analyzing the methods prescribed by Component-Based Software Engineering (CBSE), we arrive at two texts: Methodical CBSE and Amethodical Remixing. Empirical data from four studies on code search on the web draws attention to four key points of tension: status of component boundaries; provenance of source code; planning and process; and evaluation criteria for candidate code. We conclude the paper with a discussion of the implications of this work for the limits of methods, structure of organizations that reuse software, and the design of search engines for source code.</blockquote>

<p id="Pietri2019" class="bib"><cite>Pietri2019</cite>
Antoine Pietri, Diomidis Spinellis, and Stefano Zacchiroli:
"<a href="https://doi.org/10.1109/msr.2019.00030">The software heritage graph dataset: public software development under one roof</a>".
<em>2019 IEEE/ACM 16th International Conference on Mining Software Repositories (MSR)</em>, <a class="doi" href="https://doi.org/10.1109/msr.2019.00030">10.1109/msr.2019.00030</a>.
</p>
<blockquote class="abstract">Software Heritage is the largest existing public archive of software source code and accompanying development history: it currently spans more than five billion unique source code files and one billion unique commits, coming from more than 80 million software projects. This paper introduces the Software Heritage graph dataset: a fully-deduplicated Merkle DAG representation of the Software Heritage archive. The dataset links together file content identifiers, source code directories, Version Control System (VCS) commits tracking evolution over time, up to the full states of VCS repositories as observed by Software Heritage during periodic crawls. The dataset's contents come from major development forges (including GitHub and GitLab), FOSS distributions (e.g., Debian), and language-specific package managers (e.g., PyPI). Crawling information is also included, providing timestamps about when and where all archived source code artifacts have been observed in the wild. The Software Heritage graph dataset is available in multiple formats, including downloadable CSV dumps and Apache Parquet files for local use, as well as a public instance on Amazon Athena interactive query service for ready-to-use powerful analytical processing. Source code file contents are cross-referenced at the graph leaves, and can be retrieved through individual requests using the Software Heritage archive API.</blockquote>

<p id="Porter2013" class="bib"><cite>Porter2013</cite>
Leo Porter, Cynthia Bailey Lee, and Beth Simon:
"<a href="https://doi.org/10.1145/2445196.2445250">Halving fail rates using peer instruction</a>".
<em>Proceeding of the 44th ACM technical symposium on Computer science education - SIGCSE '13</em>, <a class="doi" href="https://doi.org/10.1145/2445196.2445250">10.1145/2445196.2445250</a>.
</p>
<blockquote class="abstract">Peer Instruction (PI) is a teaching method that supports student-centric classrooms, where students construct their own understanding through a structured approach featuring questions with peer discussions. PI has been shown to increase learning in STEM disciplines such as physics and biology. In this report we look at another indicator of student success the rate at which students pass the course or, conversely, the rate at which they fail. Evaluating 10 years of instruction of 4 different courses spanning 16 PI course instances, we find that adoption of the PI methodology in the classroom reduces fail rates by a per-course average of 61% (20% reduced to 7%) compared to standard instruction (SI). Moreover, we also find statistically significant improvements within-instructor. For the same instructor teaching the same course, we find PI decreases the fail rate, on average, by 67% (from 23% to 8%) compared to SI. As an in-situ study, we discuss the various threats to the validity of this work and consider implications of wide-spread adoption of PI in computing programs.</blockquote>

<p id="Posnett2011" class="bib"><cite>Posnett2011</cite>
Daryl Posnett, Abram Hindle, and Premkumar Devanbu:
"<a href="https://doi.org/10.1109/wcre.2011.33">Got issues? Do new features and code improvements affect defects?</a>".
<em>2011 18th Working Conference on Reverse Engineering</em>, <a class="doi" href="https://doi.org/10.1109/wcre.2011.33">10.1109/wcre.2011.33</a>.
</p>
<blockquote class="abstract">There is a perception that when new features are added to a system that those added and modified parts of the source-code are more fault prone. Many have argued that new code and new features are defect prone due to immaturity, lack of testing, as well unstable requirements. Unfortunately most previous work does not investigate the link between a concrete requirement or new feature and the defects it causes, in particular the feature, the changed code and the subsequent defects are rarely investigated. In this paper we investigate the relationship between improvements, new features and defects recorded within an issue tracker. A manual case study is performed to validate the accuracy of these issue types. We combine defect issues and new feature issues with the code from version-control systems that introduces these features, we then explore the relationship of new features with the fault-proneness of their implementations. We describe properties and produce models of the relationship between new features and fault proneness, based on the analysis of issue trackers and version-control systems. We find, surprisingly, that neither improvements nor new features have any significant effect on later defect counts, when controlling for size and total number of changes.</blockquote>

<p id="Prabhu2011" class="bib"><cite>Prabhu2011</cite>
Prakash Prabhu, Yun Zhang, Soumyadeep Ghosh, David I. August, Jialu Huang, Stephen Beard, Hanjun Kim, Taewook Oh, Thomas B. Jablin, Nick P. Johnson, Matthew Zoufaly, Arun Raman, Feng Liu, and David Walker:
"<a href="https://doi.org/10.1145/2063348.2063374">A survey of the practice of computational science</a>".
<em>State of the Practice Reports on - SC '11</em>, <a class="doi" href="https://doi.org/10.1145/2063348.2063374">10.1145/2063348.2063374</a>.
</p>
<blockquote class="abstract">Computing plays an indispensable role in scientific research. Presently, researchers in science have different problems, needs, and beliefs about computation than professional programmers. In order to accelerate the progress of science, computer scientists must understand these problems, needs, and beliefs. To this end, this paper presents a survey of scientists from diverse disciplines, practicing computational science at a doctoral-granting university with very high re search activity. The survey covers many things, among them, prevalent programming practices within this scientific community, the importance of computational power in different fields, use of tools to enhance performance and soft ware productivity, computational resources leveraged, and prevalence of parallel computation. The results reveal several patterns that suggest interesting avenues to bridge the gap between scientific researchers and programming tools developers.</blockquote>

<p id="Prana2018" class="bib"><cite>Prana2018</cite>
Gede Artha Azriadi Prana, Christoph Treude, Ferdian Thung, Thushari Atapattu, and David Lo:
"<a href="https://doi.org/10.1007/s10664-018-9660-3">Categorizing the Content of GitHub README Files</a>".
<em>Empirical Software Engineering</em>, 24(3), 2018,
<a class="doi" href="https://doi.org/10.1007/s10664-018-9660-3">10.1007/s10664-018-9660-3</a>.
</p>
<blockquote class="abstract">README files play an essential role in shaping a developer's first impression of a software repository and in documenting the software project that the repository hosts. Yet, we lack a systematic understanding of the content of a typical README file as well as tools that can process these files automatically. To close this gap, we conduct a qualitative study involving the manual annotation of 4,226 README file sections from 393 randomly sampled GitHub repositories and we design and evaluate a classifier and a set of features that can categorize these sections automatically. We find that information discussing the 'What' and 'How' of a repository is very common, while many README files lack information regarding the purpose and status of a repository. Our multi-label classifier which can predict eight different categories achieves an F1 score of 0.746. To evaluate the usefulness of the classification, we used the automatically determined classes to label sections in GitHub README files using badges and showed files with and without these badges to twenty software professionals. The majority of participants perceived the automated labeling of sections based on our classifier to ease information discovery. This work enables the owners of software repositories to improve the quality of their documentation and it has the potential to make it easier for the software development community to discover relevant information in GitHub README files.</blockquote>

<p id="Pritchard2015" class="bib"><cite>Pritchard2015</cite>
David Pritchard:
"<a href="https://doi.org/10.1145/2846680.2846681">Frequency distribution of error messages</a>".
<em>Proceedings of the 6th Workshop on Evaluation and Usability of Programming Languages and Tools</em>, <a class="doi" href="https://doi.org/10.1145/2846680.2846681">10.1145/2846680.2846681</a>.
</p>
<blockquote class="abstract">Which programming error messages are the most common? We investigate this question, motivated by writing error explanations for novices. We consider large data sets in Python and Java that include both syntax and run-time errors. In both data sets, after grouping essentially identical messages, the error message frequencies empirically resemble Zipf-Mandelbrot distributions. We use a maximum-likelihood approach to fit the distribution parameters. This gives one possible way to contrast languages or compilers quantitatively.</blockquote>

<h2 id="Q">Q</h2>
<h2 id="R">R</h2>

<p id="Racheva2010" class="bib"><cite>Racheva2010</cite>
Zornitza Racheva, Maya Daneva, Klaas Sikkel, Andrea Herrmann, and Roel Wieringa:
"<a href="https://doi.org/10.1109/re.2010.27">Do we know enough about requirements prioritization in agile projects: insights from a case study</a>".
<em>2010 18th IEEE International Requirements Engineering Conference</em>, <a class="doi" href="https://doi.org/10.1109/re.2010.27">10.1109/re.2010.27</a>.
</p>
<blockquote class="abstract">Requirements prioritization is an essential mechanism of agile software development approaches. It maximizes the value delivered to the clients and accommodates changing requirements. This paper presents results of an exploratory cross-case study on agile prioritization and business value delivery processes in eight software organizations. We found that some explicit and fundamental assumptions of agile requirement prioritization approaches, as described in the agile literature on best practices, do not hold in all agile project contexts in our study. These are (i) the driving role of the client in the value creation process, (ii) the prevailing position of business value as a main prioritization criterion, (iii) the role of the prioritization process for project goal achievement. This implies that these assumptions have to be reframed and that the approaches to requirements prioritization for value creation need to be extended.</blockquote>

<p id="Ragkhitwetsagul2021" class="bib"><cite>Ragkhitwetsagul2021</cite>
Chaiyong Ragkhitwetsagul, Jens Krinke, Matheus Paixao, Giuseppe Bianco, and Rocco Oliveto:
"<a href="https://doi.org/10.1109/tse.2019.2900307">Toxic code snippets on Stack Overflow</a>".
<em>IEEE Transactions on Software Engineering</em>, 47(3), 2021,
<a class="doi" href="https://doi.org/10.1109/tse.2019.2900307">10.1109/tse.2019.2900307</a>.
</p>
<blockquote class="abstract">Online code clones are code fragments that are copied from software projects or online sources to Stack Overflow as examples. Due to an absence of a checking mechanism after the code has been copied to Stack Overflow, they can become toxic code snippets, e.g., they suffer from being outdated or violating the original software license. We present a study of online code clones on Stack Overflow and their toxicity by incorporating two developer surveys and a large-scale code clone detection. A survey of 201 high-reputation Stack Overflow answerers (33 percent response rate) showed that 131 participants (65 percent) have ever been notified of outdated code and 26 of them (20 percent) rarely or never fix the code. 138 answerers (69 percent) never check for licensing conflicts between their copied code snippets and Stack Overflow's CC BY-SA 3.0. A survey of 87 Stack Overflow visitors shows that they experienced several issues from Stack Overflow answers: mismatched solutions, outdated solutions, incorrect solutions, and buggy code. 85 percent of them are not aware of CC BY-SA 3.0 license enforced by Stack Overflow, and 66 percent never check for license conflicts when reusing code snippets. Our clone detection found online clone pairs between 72,365 Java code snippets on Stack Overflow and 111 open source projects in the curated Qualitas corpus. We analysed 2,289 non-trivial online clone candidates. Our investigation revealed strong evidence that 153 clones have been copied from a Qualitas project to Stack Overflow. We found 100 of them (66 percent) to be outdated, of which 10 were buggy and harmful for reuse. Furthermore, we found 214 code snippets that could potentially violate the license of their original software and appear 7,112 times in 2,427 GitHub projects.</blockquote>

<p id="Rahman2011" class="bib"><cite>Rahman2011</cite>
Foyzur Rahman and Premkumar Devanbu:
"<a href="https://doi.org/10.1145/1985793.1985860">Ownership, experience and defects: a fine-grained study of authorship</a>".
<em>Proceedings of the 33rd International Conference on Software Engineering</em>, <a class="doi" href="https://doi.org/10.1145/1985793.1985860">10.1145/1985793.1985860</a>.
</p>
<blockquote class="abstract">Recent research indicates that "people" factors such as ownership, experience, organizational structure, and geographic distribution have a big impact on software quality. Understanding these factors, and properly deploying people resources can help managers improve quality outcomes. This paper considers the impact of code ownership and developer experience on software quality. In a large project, a file might be entirely owned by a single developer, or worked on by many. Some previous research indicates that more developers working on a file might lead to more defects. Prior research considered this phenomenon at the level of modules or files, and thus does not tease apart and study the effect of contributions of different developers to each module or file. We exploit a modern version control system to examine this issue at a fine-grained level. Using version history, we examine contributions to code fragments that are actually repaired to fix bugs. Are these code fragments "implicated" in bugs the result of contributions from many? or from one? Does experience matter? What type of experience? We find that implicated code is more strongly associated with a single developer's contribution; our findings also indicate that an author's specialized experience in the target file is more important than general experience. Our findings suggest that quality control efforts could be profitably targeted at changes made by single developers with limited prior experience on that file.</blockquote>

<p id="Rahman2013" class="bib"><cite>Rahman2013</cite>
Foyzur Rahman and Premkumar Devanbu:
"<a href="https://doi.org/10.1109/icse.2013.6606589">How, and why, process metrics are better</a>".
<em>2013 35th International Conference on Software Engineering (ICSE)</em>, <a class="doi" href="https://doi.org/10.1109/icse.2013.6606589">10.1109/icse.2013.6606589</a>.
</p>
<blockquote class="abstract">Defect prediction techniques could potentially help us to focus quality-assurance efforts on the most defect-prone files. Modern statistical tools make it very easy to quickly build and deploy prediction models. Software metrics are at the heart of prediction models; understanding how and especially why different types of metrics are effective is very important for successful model deployment. In this paper we analyze the applicability and efficacy of process and code metrics from several different perspectives. We build many prediction models across 85 releases of 12 large open source projects to address the performance, stability, portability and stasis of different sets of metrics. Our results suggest that code metrics, despite widespread use in the defect prediction literature, are generally less useful than process metrics for prediction. Second, we find that code metrics have high stasis; they don't change very much from release to release. This leads to stagnation in the prediction models, leading to the same files being repeatedly predicted as defective; unfortunately, these recurringly defective files turn out to be comparatively less defect-dense.</blockquote>

<p id="Rahman2020a" class="bib"><cite>Rahman2020a</cite>
Akond Rahman, Effat Farhana, Chris Parnin, and Laurie Williams:
"<a href="https://doi.org/10.1145/3377811.3380409">Gang of eight: a defect taxonomy for infrastructure as code scripts</a>".
<em>Proceedings of the ACM/IEEE 42nd International Conference on Software Engineering</em>, <a class="doi" href="https://doi.org/10.1145/3377811.3380409">10.1145/3377811.3380409</a>.
</p>
<blockquote class="abstract">Defects in infrastructure as code (IaC) scripts can have serious consequences, for example, creating large-scale system outages. A taxonomy of IaC defects can be useful for understanding the nature of defects, and identifying activities needed to fix and prevent defects in IaC scripts. The goal of this paper is to help practitioners improve the quality of infrastructure as code (IaC) scripts by developing a defect taxonomy for IaC scripts through qualitative analysis. We develop a taxonomy of IaC defects by applying qualitative analysis on 1,448 defect-related commits collected from open source software (OSS) repositories of the Openstack organization. We conduct a survey with 66 practitioners to assess if they agree with the identified defect categories included in our taxonomy. We quantify the frequency of identified defect categories by analyzing 80,425 commits collected from 291 OSS repositories spanning across 2005 to 2019. Our defect taxonomy for IaC consists of eight categories, including a category specific to IaC called idempotency (i.e., defects that lead to incorrect system provisioning when the same IaC script is executed multiple times). We observe the surveyed 66 practitioners to agree most with idempotency. The most frequent defect category is configuration data i.e., providing erroneous configuration data in IaC scripts. Our taxonomy and the quantified frequency of the defect categories may help in advancing the science of IaC script quality.</blockquote>

<p id="Rigby2011" class="bib"><cite>Rigby2011</cite>
Peter C. Rigby and Margaret-Anne Storey:
"<a href="https://doi.org/10.1145/1985793.1985867">Understanding broadcast based peer review on open source software projects</a>".
<em>Proceedings of the 33rd International Conference on Software Engineering</em>, <a class="doi" href="https://doi.org/10.1145/1985793.1985867">10.1145/1985793.1985867</a>.
</p>
<blockquote class="abstract">Software peer review has proven to be a successful technique in open source software (OSS) development. In contrast to industry, where reviews are typically assigned to specific individuals, changes are broadcast to hundreds of potentially interested stakeholders. Despite concerns that reviews may be ignored, or that discussions will deadlock because too many uninformed stakeholders are involved, we find that this approach works well in practice. In this paper, we describe an empirical study to investigate the mechanisms and behaviours that developers use to find code changes they are competent to review. We also explore how stakeholders interact with one another during the review process. We manually examine hundreds of reviews across five high profile OSS projects. Our findings provide insights into the simple, community-wide techniques that developers use to effectively manage large quantities of reviews. The themes that emerge from our study are enriched and validated by interviewing long-serving core developers.</blockquote>

<p id="Rivers2016" class="bib"><cite>Rivers2016</cite>
Kelly Rivers, Erik Harpstead, and Ken Koedinger:
"<a href="https://doi.org/10.1145/2960310.2960333">Learning curve analysis for programming</a>".
<em>Proceedings of the 2016 ACM Conference on International Computing Education Research</em>, <a class="doi" href="https://doi.org/10.1145/2960310.2960333">10.1145/2960310.2960333</a>.
</p>
<blockquote class="abstract">The recent surge in interest in using educational data mining on student written programs has led to discoveries about which compiler errors students encounter while they are learning how to program. However, less attention has been paid to the actual code that students produce. In this paper, we investigate programming data by using learning curve analysis to determine which programming elements students struggle with the most when learning in Python. Our analysis extends the traditional use of learning curve analysis to include less structured data, and also reveals new possibilities for when to teach students new programming concepts. One particular discovery is that while we find evidence of student learning in some cases (for example, in function definitions and comparisons), there are other programming elements which do not demonstrate typical learning. In those cases, we discuss how further changes to the model could affect both demonstrated learning and our understanding of the different concepts that students learn.</blockquote>

<p id="Robillard2010" class="bib"><cite>Robillard2010</cite>
Martin P. Robillard and Rob DeLine:
"<a href="https://doi.org/10.1007/s10664-010-9150-8">A field study of API learning obstacles</a>".
<em>Empirical Software Engineering</em>, 16(6), 2010,
<a class="doi" href="https://doi.org/10.1007/s10664-010-9150-8">10.1007/s10664-010-9150-8</a>.
</p>
<blockquote class="abstract">Large APIs can be hard to learn, and this can lead to decreased programmer productivity. But what makes APIs hard to learn? We conducted a mixed approach, multi-phased study of the obstacles faced by Microsoft developers learning a wide variety of new APIs. The study involved a combination of surveys and in-person interviews, and collected the opinions and experiences of over 440 professional developers. We found that some of the most severe obstacles faced by developers learning new APIs pertained to the documentation and other learning resources. We report on the obstacles developers face when learning new APIs, with a special focus on obstacles related to API documentation. Our qualitative analysis elicited five important factors to consider when designing API documentation: documentation of intent; code examples; matching APIs with scenarios; penetrability of the API; and format and presentation. We analyzed how these factors can be interpreted to prioritize API documentation development efforts</blockquote>

<p id="Rossbach2010" class="bib"><cite>Rossbach2010</cite>
Christopher J. Rossbach, Owen S. Hofmann, and Emmett Witchel:
"<a href="https://doi.org/10.1145/1837853.1693462">Is transactional programming actually easier?</a>".
<em>ACM SIGPLAN Notices</em>, 45(5), 2010,
<a class="doi" href="https://doi.org/10.1145/1837853.1693462">10.1145/1837853.1693462</a>.
</p>
<blockquote class="abstract">Chip multi-processors (CMPs) have become ubiquitous, while tools that ease concurrent programming have not. The promise of increased performance for all applications through ever more parallel hardware requires good tools for concurrent programming, especially for average programmers. Transactional memory (TM) has enjoyed recent interest as a tool that can help programmers program concurrently. The transactional memory (TM) research community is heavily invested in the claim that programming with transactional memory is easier than alternatives (like locks), but evidence for or against the veracity of this claim is scant. In this paper, we describe a user-study in which 237 undergraduate students in an operating systems course implement the same programs using coarse and fine-grain locks, monitors, and transactions. We surveyed the students after the assignment, and examined their code to determine the types and frequency of programming errors for each synchronization technique. Inexperienced programmers found baroque syntax a barrier to entry for transactional programming. On average, subjective evaluation showed that students found transactions harder to use than coarse-grain locks, but slightly easier to use than fine-grained locks. Detailed examination of synchronization errors in the students' code tells a rather different story. Overwhelmingly, the number and types of programming errors the students made was much lower for transactions than for locks. On a similar programming problem, over 70% of students made errors with fine-grained locking, while less than 10% made errors with transactions.</blockquote>

<h2 id="S">S</h2>

<p id="Sadowski2019" class="bib"><cite>Sadowski2019</cite>
Caitlin Sadowski and Thomas Zimmermann (eds.):
<em><a href="https://link.springer.com/book/10.1007%2F978-1-4842-4221-6">Rethinking Productivity in Software Engineering</a></em>.
Apress, 2019, 978-1484242209.
</p>
<blockquote class="abstract">This open access book collects the wisdom of the 2017 Dagstuhl seminar on productivity in software engineering, a meeting of community leaders, who came together with the goal of rethinking traditional definitions and measures of productivity. The results of their work, Rethinking Productivity in Software Engineering, includes chapters covering definitions and core concepts related to productivity, guidelines for measuring productivity in specific contexts, best practices and pitfalls, and theories and open questions on productivity. You'll benefit from the many short chapters, each offering a focused discussion on one aspect of productivity in software engineering.</blockquote>

<p id="Scanniello2017" class="bib"><cite>Scanniello2017</cite>
Giuseppe Scanniello, Michele Risi, Porfirio Tramontana, and Simone Romano:
"<a href="https://doi.org/10.1145/3104029">Fixing faults in C and Java source code</a>".
<em>ACM Transactions on Software Engineering and Methodology</em>, 26(2), 2017,
<a class="doi" href="https://doi.org/10.1145/3104029">10.1145/3104029</a>.
</p>
<blockquote class="abstract">We carried out a family of controlled experiments to investigate whether the use of abbreviated identifier names, with respect to full-word identifier names, affects fault fixing in C and Java source code. This family consists of an original (or baseline) controlled experiment and three replications. We involved 100 participants with different backgrounds and experiences in total. Overall results suggested that there is no difference in terms of effort, effectiveness, and efficiency to fix faults, when source code contains either only abbreviated or only full-word identifier names. We also conducted a qualitative study to understand the values, beliefs, and assumptions that inform and shape fault fixing when identifier names are either abbreviated or full-word. We involved in this qualitative study six professional developers with 1--3 years of work experience. A number of insights emerged from this qualitative study and can be considered a useful complement to the quantitative results from our family of experiments. One of the most interesting insights is that developers, when working on source code with abbreviated identifier names, adopt a more methodical approach to identify and fix faults by extending their focus point and only in a few cases do they expand abbreviated identifiers.</blockquote>

<p id="Sedano2017" class="bib"><cite>Sedano2017</cite>
Todd Sedano, Paul Ralph, and Cecile Peraire:
"<a href="https://doi.org/10.1109/icse.2017.20">Software development waste</a>".
<em>2017 IEEE/ACM 39th International Conference on Software Engineering (ICSE)</em>, <a class="doi" href="https://doi.org/10.1109/icse.2017.20">10.1109/icse.2017.20</a>.
</p>
<blockquote class="abstract">Context: Since software development is a complex socio-technical activity that involves coordinating different disciplines and skill sets, it provides ample opportunities for waste to emerge. Waste is any activity that produces no value for the customer or user. Objective: The purpose of this paper is to identify and describe different types of waste in software development. Method: Following Constructivist Grounded Theory, we conducted a two-year five-month participant-observation study of eight software development projects at Pivotal, a software development consultancy. We also interviewed 33 software engineers, interaction designers, and product managers, and analyzed one year of retrospection topics. We iterated between analysis and theoretical sampling until achieving theoretical saturation. Results: This paper introduces the first empirical waste taxonomy. It identifies nine wastes and explores their causes, underlying tensions, and overall relationship to the waste taxonomy found in Lean Software Development. Limitations: Grounded Theory does not support statistical generalization. While the proposed taxonomy appears widely applicable, organizations with different software development cultures may experience different waste types. Conclusion: Software development projects manifest nine types of waste: building the wrong feature or product, mismanaging the backlog, rework, unnecessarily complex solutions, extraneous cognitive load, psychological distress, waiting/multitasking, knowledge loss, and ineffective communication.</blockquote>

<p id="Sharp2016" class="bib"><cite>Sharp2016</cite>
Helen Sharp, Yvonne Dittrich, and Cleidson R. B. de Souza:
"<a href="https://doi.org/10.1109/tse.2016.2519887">The role of ethnographic studies in empirical software engineering</a>".
<em>IEEE Transactions on Software Engineering</em>, 42(8), 2016,
<a class="doi" href="https://doi.org/10.1109/tse.2016.2519887">10.1109/tse.2016.2519887</a>.
</p>
<blockquote class="abstract">Ethnography is a qualitative research method used to study people and cultures. It is largely adopted in disciplines outside software engineering, including different areas of computer science. Ethnography can provide an in-depth understanding of the socio-technological realities surrounding everyday software development practice, i.e., it can help to uncover not only what practitioners do, but also why they do it. Despite its potential, ethnography has not been widely adopted by empirical software engineering researchers, and receives little attention in the related literature. The main goal of this paper is to explain how empirical software engineering researchers would benefit from adopting ethnography. This is achieved by explicating four roles that ethnography can play in furthering the goals of empirical software engineering: to strengthen investigations into the social and human aspects of software engineering; to inform the design of software engineering tools; to improve method and process development; and to inform research programmes. This article introduces ethnography, explains its origin, context, strengths and weaknesses, and presents a set of dimensions that position ethnography as a useful and usable approach to empirical software engineering research. Throughout the paper, relevant examples of ethnographic studies of software practice are used to illustrate the points being made.</blockquote>

<p id="Staples2013" class="bib"><cite>Staples2013</cite>
Mark Staples, Rafal Kolanski, Gerwin Klein, Corey Lewis, June Andronick, Toby Murray, Ross Jeffery, and Len Bass:
"<a href="https://doi.org/10.1109/icse.2013.6606692">Formal specifications better than function points for code sizing</a>".
<em>2013 35th International Conference on Software Engineering (ICSE)</em>, <a class="doi" href="https://doi.org/10.1109/icse.2013.6606692">10.1109/icse.2013.6606692</a>.
</p>
<blockquote class="abstract">Size and effort estimation is a significant challenge for the management of large-scale formal verification projects. We report on an initial study of relationships between the sizes of artefacts from the development of seL4, a formally-verified embedded systems microkernel. For each API function we first determined its COSMIC Function Point (CFP) count (based on the seL4 user manual), then sliced the formal specifications and source code, and performed a normalised line count on these artefact slices. We found strong and significant relationships between the sizes of the artefact slices, but no significant relationships between them and the CFP counts. Our finding that CFP is poorly correlated with lines of code is based on just one system, but is largely consistent with prior literature. We find CFP is also poorly correlated with the size of formal specifications. Nonetheless, lines of formal specification correlate with lines of source code, and this may provide a basis for size prediction in future formal verification projects. In future work we will investigate proof sizing.</blockquote>

<p id="Stefik2011" class="bib"><cite>Stefik2011</cite>
Andreas Stefik, Susanna Siebert, Melissa Stefik, and Kim Slattery:
"<a href="https://doi.org/10.1145/2089155.2089159">An empirical comparison of the accuracy rates of novices using the Quorum, Perl, and Randomo programming languages</a>".
<em>Proceedings of the 3rd ACM SIGPLAN workshop on Evaluation and usability of programming languages and tools - PLATEAU '11</em>, <a class="doi" href="https://doi.org/10.1145/2089155.2089159">10.1145/2089155.2089159</a>.
</p>
<blockquote class="abstract">We present here an empirical study comparing the accuracy rates of novices writing software in three programming languages: Quorum, Perl, and Randomo. The first language, Quorum, we call an evidence-based programming language, where the syntax, semantics, and API designs change in correspondence to the latest academic research and literature on programming language usability. Second, while Perl is well known, we call Randomo a Placebo-language, where some of the syntax was chosen with a random number generator and the ASCII table. We compared novices that were programming for the first time using each of these languages, testing how accurately they could write simple programs using common program constructs (e.g., loops, conditionals, functions, variables, parameters). Results showed that while Quorum users were afforded significantly greater accuracy compared to those using Perl and Randomo, Perl users were unable to write programs more accurately than those using a language designed by chance.</blockquote>

<p id="Stefik2013" class="bib"><cite>Stefik2013</cite>
Andreas Stefik and Susanna Siebert:
"<a href="https://doi.org/10.1145/2534973">An empirical investigation into programming language syntax</a>".
<em>ACM Transactions on Computing Education</em>, 13(4), 2013,
<a class="doi" href="https://doi.org/10.1145/2534973">10.1145/2534973</a>.
</p>
<blockquote class="abstract">Recent studies in the literature have shown that syntax remains a significant barrier to novice computer science students in the field. While this syntax barrier is known to exist, whether and how it varies across programming languages has not been carefully investigated. For this article, we conducted four empirical studies on programming language syntax as part of a larger analysis into the, so called, programming language wars. We first present two surveys conducted with students on the intuitiveness of syntax, which we used to garner formative clues on what words and symbols might be easy for novices to understand. We followed up with two studies on the accuracy rates of novices using a total of six programming languages: Ruby, Java, Perl, Python, Randomo, and Quorum. Randomo was designed by randomly choosing some keywords from the ASCII table (a metaphorical placebo). To our surprise, we found that languages using a more traditional C-style syntax (both Perl and Java) did not afford accuracy rates significantly higher than a language with randomly generated keywords, but that languages which deviate (Quorum, Python, and Ruby) did. These results, including the specifics of syntax that are particularly problematic for novices, may help teachers of introductory programming courses in choosing appropriate first languages and in helping students to overcome the challenges they face with syntax.</blockquote>

<p id="Stolee2011" class="bib"><cite>Stolee2011</cite>
Kathryn T. Stolee and Sebastian Elbaum:
"<a href="https://doi.org/10.1145/1985793.1985805">Refactoring pipe-like mashups for end-user programmers</a>".
<em>Proceedings of the 33rd International Conference on Software Engineering</em>, <a class="doi" href="https://doi.org/10.1145/1985793.1985805">10.1145/1985793.1985805</a>.
</p>
<blockquote class="abstract">Mashups are becoming increasingly popular as end users are able to easily access, manipulate, and compose data from many web sources. We have observed, however, that mashups tend to suffer from deficiencies that propagate as mashups are reused. To address these deficiencies, we would like to bring some of the benefits of software engineering techniques to the end users creating these programs. In this work, we focus on identifying code smells indicative of the deficiencies we observed in web mashups programmed in the popular Yahoo! Pipes environment. Through an empirical study, we explore the impact of those smells on end-user programmers and observe that users generally prefer mashups without smells. We then introduce refactorings targeting those smells, reducing the complexity of the mashup programs, increasing their abstraction, updating broken data sources and dated components, and standardizing their structures to fit the community development patterns. Our assessment of a large sample of mashups shows that smells are present in 81% of them and that the proposed refactorings can reduce the number of smelly mashups to 16%, illustrating the potential of refactoring to support the thousands of end users programming mashups.</blockquote>

<p id="Stylos2007" class="bib"><cite>Stylos2007</cite>
Jeffrey Stylos and Steven Clarke:
"<a href="https://doi.org/10.1109/icse.2007.92">Usability implications of requiring parameters in objects' constructors</a>".
<em>29th International Conference on Software Engineering (ICSE'07)</em>, <a class="doi" href="https://doi.org/10.1109/icse.2007.92">10.1109/icse.2007.92</a>.
</p>
<blockquote class="abstract">The usability of APIs is increasingly important to programmer productivity. Based on experience with usability studies of specific APIs, techniques were explored for studying the usability of design choices common to many APIs. A comparative study was performed to assess how professional programmers use APIs with required parameters in objects' constructors as opposed to parameterless "default" constructors. It was hypothesized that required parameters would create more usable and self- documenting APIs by guiding programmers toward the correct use of objects and preventing errors. However, in the study, it was found that, contrary to expectations, programmers strongly preferred and were more effective with APIs that did not require constructor parameters. Participants' behavior was analyzed using the cognitive dimensions framework, and revealing that required constructor parameters interfere with common learning strategies, causing undesirable premature commitment.</blockquote>

<h2 id="T">T</h2>

<p id="Taipalus2018" class="bib"><cite>Taipalus2018</cite>
Toni Taipalus, Mikko Siponen, and Tero Vartiainen:
"<a href="https://doi.org/10.1145/3231712">Errors and complications in SQL query formulation</a>".
<em>ACM Transactions on Computing Education</em>, 18(3), 2018,
<a class="doi" href="https://doi.org/10.1145/3231712">10.1145/3231712</a>.
</p>
<blockquote class="abstract">SQL is taught in almost all university level database courses, yet SQL has received relatively little attention in educational research. In this study, we present a database management system independent categorization of SQL query errors that students make in an introductory database course. We base the categorization on previous literature, present a class of logical errors that has not been studied in detail, and review and complement these findings by analyzing over 33,000 SQL queries submitted by students. Our analysis verifies error findings presented in previous literature and reveals new types of errors, namely logical errors recurring in similar manners among different students. We present a listing of fundamental SQL query concepts we have identified and based our exercises on, a categorization of different errors and complications, and an operational model for designing SQL exercises.</blockquote>

<p id="Tew2011" class="bib"><cite>Tew2011</cite>
Allison Elliott Tew and Mark Guzdial:
"<a href="https://doi.org/10.1145/1953163.1953200">The FCS1: a language independent assessment of CS1 knowledge</a>".
<em>Proceedings of the 42nd ACM technical symposium on Computer science education - SIGCSE '11</em>, <a class="doi" href="https://doi.org/10.1145/1953163.1953200">10.1145/1953163.1953200</a>.
</p>
<blockquote class="abstract">A primary goal of many CS education projects is to determine the extent to which a given intervention has had an impact on student learning. However, computing lacks valid assessments for pedagogical or research purposes. Without such valid assessments, it is difficult to accurately measure student learning or establish a relationship between the instructional setting and learning outcomes. We developed the Foundational CS1 (FCS1) Assessment instrument, the first assessment instrument for introductory computer science concepts that is applicable across a variety of current pedagogies and programming languages. We applied methods from educational and psychological test development, adapting them as necessary to fit the disciplinary context. We conducted a large scale empirical study to demonstrate that pseudo-code was an appropriate mechanism for achieving programming language independence. Finally, we established the validity of the assessment using a multi-faceted argument, combining interview data, statistical analysis of results on the assessment, and CS1 exam scores.</blockquote>

<p id="Thongtanunam2016" class="bib"><cite>Thongtanunam2016</cite>
Patanamon Thongtanunam, Shane McIntosh, Ahmed E. Hassan, and Hajimu Iida:
"<a href="https://doi.org/10.1145/2884781.2884852">Revisiting code ownership and its relationship with software quality in the scope of modern code review</a>".
<em>Proceedings of the 38th International Conference on Software Engineering</em>, <a class="doi" href="https://doi.org/10.1145/2884781.2884852">10.1145/2884781.2884852</a>.
</p>
<blockquote class="abstract">Code ownership establishes a chain of responsibility for modules in large software systems. Although prior work uncovers a link between code ownership heuristics and software quality, these heuristics rely solely on the authorship of code changes. In addition to authoring code changes, developers also make important contributions to a module by reviewing code changes. Indeed, recent work shows that reviewers are highly active in modern code review processes, often suggesting alternative solutions or providing updates to the code changes. In this paper, we complement traditional code ownership heuristics using code review activity. Through a case study of six releases of the large Qt and OpenStack systems, we find that: (1) 67%-86% of developers did not author any code changes for a module, but still actively contributed by reviewing 21%-39% of the code changes, (2) code ownership heuristics that are aware of reviewing activity share a relationship with software quality, and (3) the proportion of reviewers without expertise shares a strong, increasing relationship with the likelihood of having post-release defects. Our results suggest that reviewing activity captures an important aspect of code ownership, and should be included in approximations of it in future studies.</blockquote>

<p id="Tourani2017" class="bib"><cite>Tourani2017</cite>
Parastou Tourani, Bram Adams, and Alexander Serebrenik:
"<a href="https://doi.org/10.1109/saner.2017.7884606">Code of conduct in open source projects</a>".
<em>2017 IEEE 24th International Conference on Software Analysis, Evolution and Reengineering (SANER)</em>, <a class="doi" href="https://doi.org/10.1109/saner.2017.7884606">10.1109/saner.2017.7884606</a>.
</p>
<blockquote class="abstract">Open source projects rely on collaboration of members from all around the world using web technologies like GitHub and Gerrit. This mixture of people with a wide range of backgrounds including minorities like women, ethnic minorities, and people with disabilities may increase the risk of offensive and destroying behaviours in the community, potentially leading affected project members to leave towards a more welcoming and friendly environment. To counter these effects, open source projects increasingly are turning to codes of conduct, in an attempt to promote their expectations and standards of ethical behaviour. In this first of its kind empirical study of codes of conduct in open source software projects, we investigated the role, scope and influence of codes of conduct through a mixture of quantitative and qualitative analysis, supported by interviews with practitioners. We found that the top codes of conduct are adopted by hundreds to thousands of projects, while all of them share 5 common dimensions.</blockquote>

<p id="Tregubov2017" class="bib"><cite>Tregubov2017</cite>
Alexey Tregubov, Barry Boehm, Natalia Rodchenko, and Jo Ann Lane:
"<a href="https://doi.org/10.1145/3084100.3084116">Impact of task switching and work interruptions on software development processes</a>".
<em>Proceedings of the 2017 International Conference on Software and System Process</em>, <a class="doi" href="https://doi.org/10.1145/3084100.3084116">10.1145/3084100.3084116</a>.
</p>
<blockquote class="abstract">Software developers often work on multiple projects and tasks throughout a work day, which may affect their productivity and quality of work. Knowing how working on several projects at a time affects productivity can improve cost and schedule estimations. It also can provide additional insights for better work scheduling and the development process. We want to achieve a better productivity without losing the benefits of work interruptions and multitasking for developers involved in the process. To understand how the development process can be improved, first, we identify work interruptions that mostly have a negative effect on productivity, second, we need to quantitatively evaluate impact of multitasking (task switching, work context switching) and work interruptions on productivity. In this research we study cross-project multitasking among the developers working on multiple projects in an educational setting. We propose a way to evaluate the number of cross-project interruptions among software developers using self-reported work logs. This paper describes the research that found: a) software developers involved in two or more projects on average spend 17% of their development effort on cross-project interruptions, b) the amount of effort spent on interruptions is overestimated by the G. Weinberg's heuristic, c) the correlation between the number of projects and effort spent by developers on cross-project interruptions is relatively weak, and d) there is strong correlation between the number of projects and the number of interruptions developers reported.</blockquote>

<h2 id="U">U</h2>
<h2 id="V">V</h2>

<p id="Vanhanen2007" class="bib"><cite>Vanhanen2007</cite>
Jari Vanhanen and Harri Korpi:
"<a href="https://doi.org/10.1109/hicss.2007.218">Experiences of using pair programming in an agile project</a>".
<em>2007 40th Annual Hawaii International Conference on System Sciences (HICSS'07)</em>, <a class="doi" href="https://doi.org/10.1109/hicss.2007.218">10.1109/hicss.2007.218</a>.
</p>
<blockquote class="abstract">The interest in pair programming (PP) has increased recently, e.g. by the popularization of agile software development. However, many practicalities of PP are poorly understood. We present experiences of using PP extensively in an industrial project. The fact that the team had a limited number of high-end workstations forced it in a positive way to quick deployment and rigorous use of PP. The developers liked PP and learned it easily. Initially, the pairs were not rotated frequently but adopting daily, random rotation improved the situation. Frequent rotation seemed to improve knowledge transfer. The driver/navigator roles were switched seldom, but still the partners communicated actively. The navigator rarely spotted defects during coding, but the released code contained almost no defects. Test-driven development and design in pairs possibly decreased defects. The developers considered that PP improved quality and knowledge transfer, and was better suited for complex tasks than for easy tasks</blockquote>

<h2 id="W">W</h2>

<p id="Wang2016" class="bib"><cite>Wang2016</cite>
Xinyu Wang, Sumit Gulwani, and Rishabh Singh:
"<a href="https://doi.org/10.1145/2983990.2984030">FIDEX: filtering spreadsheet data using examples</a>".
<em>Proceedings of the 2016 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications</em>, <a class="doi" href="https://doi.org/10.1145/2983990.2984030">10.1145/2983990.2984030</a>.
</p>
<blockquote class="abstract">Data filtering in spreadsheets is a common problem faced by millions of end-users. The task of data filtering requires a computational model that can separate intended positive and negative string instances. We present a system, FIDEX, that can efficiently learn desired data filtering expressions from a small set of positive and negative string examples. There are two key ideas of our approach. First, we design an expressive DSL to represent disjunctive filter expressions needed for several real-world data filtering tasks. Second, we develop an efficient synthesis algorithm for incrementally learning consistent filter expressions in the DSL from very few positive and negative examples. A DAG-based data structure is used to succinctly represent a large number of filter expressions, and two corresponding operators are defined for algorithmically handling positive and negative examples, namely, the intersection and subtraction operators. FIDEX is able to learn data filters for 452 out of 460 real-world data filtering tasks in real time (0.22s), using only 2.2 positive string instances and 2.7 negative string instances on average.</blockquote>

<p id="Wang2020" class="bib"><cite>Wang2020</cite>
Peipei Wang, Chris Brown, Jamie A. Jennings, and Kathryn T. Stolee:
"<a href="https://doi.org/10.1145/3379597.3387464">An empirical study on regular expression bugs</a>".
<em>Proceedings of the 17th International Conference on Mining Software Repositories</em>, <a class="doi" href="https://doi.org/10.1145/3379597.3387464">10.1145/3379597.3387464</a>.
</p>
<blockquote class="abstract">Understanding the nature of regular expression (regex) issues is important to tackle practical issues developers face in regular expression usage. Knowledge about the nature and frequency of various types of regular expression issues, such as those related to performance, API misuse, and code smells, can guide testing, inform documentation writers, and motivate refactoring efforts. However, beyond ReDoS (Regular expression Denial of Service), little is known about to what extent regular expression issues affect software development and how these issues are addressed in practice. This paper presents a comprehensive empirical study of 350 merged regex-related pull requests from Apache, Mozilla, Facebook, and Google GitHub repositories. Through classifying the root causes and manifestations of those bugs, we show that incorrect regular expression behavior is the dominant root cause of regular expression bugs (165/356, 46.3%). The remaining root causes are incorrect API usage (9.3%) and other code issues that require regular expression changes in the fix (29.5%). By studying the code changes of regex-related pull requests, we observe that fixing regular expression bugs is nontrivial as it takes more time and more lines of code to fix them compared to the general pull requests. The results of this study contribute to a broader understanding of the practical problems faced by developers when using regular expressions.</blockquote>

<p id="Washburn2016" class="bib"><cite>Washburn2016</cite>
Michael Washburn, Pavithra Sathiyanarayanan, Meiyappan Nagappan, Thomas Zimmermann, and Christian Bird:
"<a href="https://doi.org/10.1145/2889160.2889253">What went right and what went wrong: an analysis of 155 postmortems from game development</a>".
<em>Proceedings of the 38th International Conference on Software Engineering Companion</em>, <a class="doi" href="https://doi.org/10.1145/2889160.2889253">10.1145/2889160.2889253</a>.
</p>
<blockquote class="abstract">In game development, software teams often conduct postmortems to reflect on what went well and what went wrong in a project. The postmortems are shared publicly on gaming sites or at developer conferences. In this paper, we present an analysis of 155 postmortems published on the gaming site Gamasutra.com. We identify characteristics of game development, link the characteristics to positive and negative experiences in the postmortems and distill a set of best practices and pitfalls for game development.</blockquote>

<p id="WeillTessier2021" class="bib"><cite>WeillTessier2021</cite>
Pierre Weill-Tessier, Alexandra Lucia Costache, and Neil C. C. Brown:
"<a href="https://doi.org/10.1145/3408877.3432408">Usage of the Java language by novices over time: implications for tool and language design</a>".
<em>Proceedings of the 52nd ACM Technical Symposium on Computer Science Education</em>, <a class="doi" href="https://doi.org/10.1145/3408877.3432408">10.1145/3408877.3432408</a>.
</p>
<blockquote class="abstract">Java is a popular programming language for teaching at university level. BlueJ is a popular tool for teaching Java to beginners. We provide several analyses of Java use in BlueJ to answer three questions: what use is made of different parts of Java by beginners when learning to program; how has this pattern of use changed between 2013 and 2019 in a longstanding language such as Java; and to what extent do beginners follow the specific style that BlueJ is designed to guide them into? These analyses allow us to see what features are important in object-oriented introductory programming languages, which could inform language and tool designers—and see to what extent the design of these programming tools can have an effect on the way the language is used. We find that many beginners disobey the guidelines that BlueJ promotes, and that patterns of Java use are generally stable over time—but we do see decreased exception use and a change in target application domains away from GUI programming towards text processing. We conclude that programming languages for novices could have fewer built-in types but should retain rich libraries.</blockquote>

<p id="Wicherts2011" class="bib"><cite>Wicherts2011</cite>
Jelte M. Wicherts, Marjan Bakker, and Dylan Molenaar:
"<a href="https://doi.org/10.1371/journal.pone.0026828">Willingness to share research data is related to the strength of the evidence and the quality of reporting of statistical results</a>".
<em>PLoS ONE</em>, 6(11), 2011,
<a class="doi" href="https://doi.org/10.1371/journal.pone.0026828">10.1371/journal.pone.0026828</a>.
</p>
<blockquote class="abstract">Background The widespread reluctance to share published research data is often hypothesized to be due to the authors' fear that reanalysis may expose errors in their work or may produce conclusions that contradict their own. However, these hypotheses have not previously been studied systematically. Methods and Findings We related the reluctance to share research data for reanalysis to 1148 statistically significant results reported in 49 papers published in two major psychology journals. We found the reluctance to share data to be associated with weaker evidence (against the null hypothesis of no effect) and a higher prevalence of apparent errors in the reporting of statistical results. The unwillingness to share data was particularly clear when reporting errors had a bearing on statistical significance. Conclusions Our findings on the basis of psychological papers suggest that statistical results are particularly hard to verify when reanalysis is more likely to lead to contrasting conclusions. This highlights the importance of establishing mandatory data archiving policies.</blockquote>

<p id="Wilkerson2012" class="bib"><cite>Wilkerson2012</cite>
Jerod W. Wilkerson, Jay F. Nunamaker, and Rick Mercer:
"<a href="https://doi.org/10.1109/tse.2011.46">Comparing the defect reduction benefits of code inspection and test-driven development</a>".
<em>IEEE Transactions on Software Engineering</em>, 38(3), 2012,
<a class="doi" href="https://doi.org/10.1109/tse.2011.46">10.1109/tse.2011.46</a>.
</p>
<blockquote class="abstract">This study is a quasi experiment comparing the software defect rates and implementation costs of two methods of software defect reduction: code inspection and test-driven development. We divided participants, consisting of junior and senior computer science students at a large Southwestern university, into four groups using a two-by-two, between-subjects, factorial design and asked them to complete the same programming assignment using either test-driven development, code inspection, both, or neither. We compared resulting defect counts and implementation costs across groups. We found that code inspection is more effective than test-driven development at reducing defects, but that code inspection is also more expensive. We also found that test-driven development was no more effective at reducing defects than traditional programming methods.</blockquote>

<h2 id="X">X</h2>

<p id="Xu2015" class="bib"><cite>Xu2015</cite>
Tianyin Xu, Long Jin, Xuepeng Fan, Yuanyuan Zhou, Shankar Pasupathy, and Rukma Talwadker:
"<a href="https://doi.org/10.1145/2786805.2786852">Hey, you have given me too many knobs!: understanding and dealing with over-designed configuration in system software</a>".
<em>Proceedings of the 2015 10th Joint Meeting on Foundations of Software Engineering</em>, <a class="doi" href="https://doi.org/10.1145/2786805.2786852">10.1145/2786805.2786852</a>.
</p>
<blockquote class="abstract">Configuration problems are not only prevalent, but also severely impair the reliability of today's system software. One fundamental reason is the ever-increasing complexity of configuration, reflected by the large number of configuration parameters ("knobs"). With hundreds of knobs, configuring system software to ensure high reliability and performance becomes a daunting, error-prone task. This paper makes a first step in understanding a fundamental question of configuration design: "do users really need so many knobs?" To provide the quantitatively answer, we study the configuration settings of real-world users, including thousands of customers of a commercial storage system (Storage-A), and hundreds of users of two widely-used open-source system software projects. Our study reveals a series of interesting findings to motivate software architects and developers to be more cautious and disciplined in configuration design. Motivated by these findings, we provide a few concrete, practical guidelines which can significantly reduce the configuration space. Take Storage-A as an example, the guidelines can remove 51.9% of its parameters and simplify 19.7% of the remaining ones with little impact on existing users. Also, we study the existing configuration navigation methods in the context of "too many knobs" to understand their effectiveness in dealing with the over-designed configuration, and to provide practices for building navigation support in system software.</blockquote>

<h2 id="Y">Y</h2>

<p id="Yin2011" class="bib"><cite>Yin2011</cite>
Zuoning Yin, Ding Yuan, Yuanyuan Zhou, Shankar Pasupathy, and Lakshmi Bairavasundaram:
"<a href="https://doi.org/10.1145/2025113.2025121">How do fixes become bugs?</a>".
<em>Proceedings of the 19th ACM SIGSOFT symposium and the 13th European conference on Foundations of software engineering - SIGSOFT/FSE '11</em>, <a class="doi" href="https://doi.org/10.1145/2025113.2025121">10.1145/2025113.2025121</a>.
</p>
<blockquote class="abstract">Software bugs affect system reliability. When a bug is exposed in the field, developers need to fix them. Unfortunately, the bug-fixing process can also introduce errors, which leads to buggy patches that further aggravate the damage to end users and erode software vendors' reputation. This paper presents a comprehensive characteristic study on incorrect bug-fixes from large operating system code bases including Linux, OpenSolaris, FreeBSD and also a mature commercial OS developed and evolved over the last 12 years, investigating not only themistake patterns during bug-fixing but also the possible human reasons in the development process when these incorrect bug-fixes were introduced. Our major findings include: (1) at least 14.8%--24.4% of sampled fixes for post-release bugs in these large OSes are incorrect and have made impacts to end users. (2) Among several common bug types, concurrency bugs are the most difficult to fix correctly: 39% of concurrency bug fixes are incorrect. (3) Developers and reviewers for incorrect fixes usually do not have enough knowledge about the involved code. For example, 27% of the incorrect fixes are made by developers who have never touched the source code files associated with the fix. Our results provide useful guidelines to design new tools and also to improve the development process. Based on our findings, the commercial software vendor whose OS code we evaluated is building a tool to improve the bug fixing and code reviewing process.</blockquote>

<p id="Yuan2014" class="bib"><cite>Yuan2014</cite>
Ding Yuan, Yu Luo, Xin Zhuang, Guilherme Renna Rodrigues, Xu Zhao, Pranay U. Jain, and Michael Stumm:
"<a href="https://doi.org/10.13140/2.1.2044.2889">Simple testing can prevent most critical failures—an analysis of production failures in distributed data-intensive systems</a>".
<em>11th USENIX Symposium on Operating System Design and Implementation (OSDI'14)</em>, <a class="doi" href="https://doi.org/10.13140/2.1.2044.2889">10.13140/2.1.2044.2889</a>.
</p>
<blockquote class="abstract">Large, production quality distributed systems still fail periodically, and do so sometimes catastrophically, where most or all users experience an outage or data loss. We present the result of a comprehensive study investigating 198 randomly selected, user-reported failures that occurred on Cassandra, HBase, Hadoop Distributed File System (HDFS), Hadoop MapReduce, and Redis, with the goal of understanding how one or multiple faults eventually evolve into a user-visible failures. We found that from a testing point of view, almost all failures require only 3 or fewer nodes to reproduce, which is good news considering that these services typically run on a very large number of nodes. However, multiple inputs are needed to trigger the failures with the order between them being important. Finally, we found the error logs of these systems typically contain sufficient data on both the errors and the input events that triggered the failure, enabling the diagnose and the reproduction of the production failures—often with unit tests. We found the majority of catastrophic failures could easily have been prevented by performing simple testing on error handling code—the last line of defense—even without an understanding of the software design. We extracted three simple rules from the bugs that have lead to some of the catastrophic failures, and developed a static checker, Aspirator, capable of locating these bugs. Over 30% of the catastrophic failures would have been prevented had Aspirator been used and the identified bugs fixed. Running Aspirator on the code of 9 distributed systems located 143 bugs and bad practices that have been fixed or confirmed by the developers.</blockquote>

<h2 id="Z">Z</h2>

<p id="Zhang2020" class="bib"><cite>Zhang2020</cite>
Haoxiang Zhang, Shaowei Wang, Tse-Hsun Chen, and Ahmed E. Hassan:
"<a href="https://doi.org/10.1109/tse.2019.2954319">Reading Answers on Stack Overflow: Not Enough!</a>".
<em>IEEE Transactions on Software Engineering</em>, 2020,
<a class="doi" href="https://doi.org/10.1109/tse.2019.2954319">10.1109/tse.2019.2954319</a>.
</p>
<blockquote class="abstract">Stack Overflow is one of the most active communities for developers to share their programming knowledge. Answers posted on Stack Overflow help developers solve issues during software development. In addition to posting answers, users can also post comments to further discuss their associated answers. As of Aug 2017, there are 32.3 million comments that are associated with answers, forming a large collection of crowdsourced repository of knowledge on top of the commonly-studied Stack Overflow answers. In this study, we wish to understand how the commenting activities contribute to the crowdsourced knowledge. We investigate what users discuss in comments, and analyze the characteristics of the commenting dynamics, (i.e., the timing of commenting activities and the roles of commenters). We find that: 1) the majority of comments are informative and thus can enhance their associated answers from a diverse range of perspectives. However, some comments contain content that is discouraged by Stack Overflow. 2) The majority of commenting activities occur after the acceptance of an answer. More than half of the comments are fast responses occurring within one day of the creation of an answer, while later comments tend to be more informative. Most comments are rarely integrated back into their associated answers, even though such comments are informative. 3) Insiders (i.e., users who posted questions/answers before posting a comment in a question thread) post the majority of comments within one month, and outsiders (i.e., users who never posted any question/answer before posting a comment) post the majority of comments after one month. Inexperienced users tend to raise limitations and concerns while experienced users tend to enhance the answer through commenting. Our study provides insights into the commenting activities in terms of their content, timing, and the individuals who perform the commenting. For the purpose of long-term knowledge maintenance and effective information retrieval for developers, we also provide actionable suggestions to encourage Stack Overflow users/engineers/moderators to leverage our insights for enhancing the current Stack Overflow commenting system for improving the maintenance and organization of the crowdsourced knowledge.</blockquote>

<p id="Zhu2021" class="bib"><cite>Zhu2021</cite>
Wenhan Zhu and Michael W. Godfrey:
"<a href="https://doi.org/10.1109/msr52588.2021.00065">Mea culpa: how developers fix their own simple bugs differently from other developers</a>".
<em>2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR)</em>, <a class="doi" href="https://doi.org/10.1109/msr52588.2021.00065">10.1109/msr52588.2021.00065</a>.
</p>
<blockquote class="abstract">In this work, we study how the authorship of code affects bug-fixing commits using the SStuBs dataset, a collection of single-statement bug fix changes in popular Java Maven projects. More specifically, we study the differences in characteristics between simple bug fixes by the original author—that is, the developer who submitted the bug-inducing commit—and by different developers (i.e., non-authors). Our study shows that nearly half (i.e., 44.3%) of simple bugs are fixed by a different developer. We found that bug fixes by the original author and by different developers differed qualitatively and quantitatively. We observed that bug-fixing time by authors is much shorter than that of other developers. We also found that bug-fixing commits by authors tended to be larger in size and scope, and address multiple issues, whereas bug-fixing commits by other developers tended to be smaller and more focused on the bug itself. Future research can further study the different patterns in bug-fixing and create more tailored tools based on the developer's needs.</blockquote>
